{"ast":null,"code":"import * as React from 'react';\nimport { forwardRef, useContext } from 'react';\nimport { useFeatures } from './features/use-features.js';\nimport { MotionConfigContext } from '../context/MotionConfigContext.js';\nimport { MotionContext } from '../context/MotionContext/index.js';\nimport { useVisualElement } from './utils/use-visual-element.js';\nimport { useMotionRef } from './utils/use-motion-ref.js';\nimport { useCreateMotionContext } from '../context/MotionContext/create.js';\nimport { loadFeatures } from './features/definitions.js';\nimport { isBrowser } from '../utils/is-browser.js';\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\n\nfunction createMotionComponent(_a) {\n  var preloadedFeatures = _a.preloadedFeatures,\n      createVisualElement = _a.createVisualElement,\n      useRender = _a.useRender,\n      useVisualState = _a.useVisualState,\n      Component = _a.Component;\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n\n  function MotionComponent(props, externalRef) {\n    /**\n     * If we're rendering in a static environment, we only visually update the component\n     * as a result of a React-rerender rather than interactions or animations. This\n     * means we don't need to load additional memory structures like VisualElement,\n     * or any gesture/animation features.\n     */\n    var isStatic = useContext(MotionConfigContext).isStatic;\n    var features = null;\n    /**\n     * Create the tree context. This is memoized and will only trigger renders\n     * when the current tree variant changes in static mode.\n     */\n\n    var context = useCreateMotionContext(props, isStatic);\n    /**\n     *\n     */\n\n    var visualState = useVisualState(props, isStatic);\n\n    if (!isStatic && isBrowser) {\n      /**\n       * Create a VisualElement for this component. A VisualElement provides a common\n       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n       * providing a way of rendering to these APIs outside of the React render loop\n       * for more performant animations and interactions\n       */\n      context.visualElement = useVisualElement(Component, visualState, props, createVisualElement);\n      /**\n       * Load Motion gesture and animation features. These are rendered as renderless\n       * components so each feature can optionally make use of React lifecycle methods.\n       *\n       * TODO: The intention is to move these away from a React-centric to a\n       * VisualElement-centric lifecycle scheme.\n       */\n\n      features = useFeatures(props, context.visualElement, preloadedFeatures);\n    }\n    /**\n     * The mount order and hierarchy is specific to ensure our element ref\n     * is hydrated by the time features fire their effects.\n     */\n\n\n    return React.createElement(React.Fragment, null, React.createElement(MotionContext.Provider, {\n      value: context\n    }, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)), features);\n  }\n\n  return forwardRef(MotionComponent);\n}\n\nexport { createMotionComponent };","map":{"version":3,"sources":["/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/framer-motion/dist/es/motion/index.js"],"names":["React","forwardRef","useContext","useFeatures","MotionConfigContext","MotionContext","useVisualElement","useMotionRef","useCreateMotionContext","loadFeatures","isBrowser","createMotionComponent","_a","preloadedFeatures","createVisualElement","useRender","useVisualState","Component","MotionComponent","props","externalRef","isStatic","features","context","visualState","visualElement","createElement","Fragment","Provider","value"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,UAAT,EAAqBC,UAArB,QAAuC,OAAvC;AACA,SAASC,WAAT,QAA4B,4BAA5B;AACA,SAASC,mBAAT,QAAoC,mCAApC;AACA,SAASC,aAAT,QAA8B,mCAA9B;AACA,SAASC,gBAAT,QAAiC,+BAAjC;AACA,SAASC,YAAT,QAA6B,2BAA7B;AACA,SAASC,sBAAT,QAAuC,oCAAvC;AACA,SAASC,YAAT,QAA6B,2BAA7B;AACA,SAASC,SAAT,QAA0B,wBAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,qBAAT,CAA+BC,EAA/B,EAAmC;AAC/B,MAAIC,iBAAiB,GAAGD,EAAE,CAACC,iBAA3B;AAAA,MAA8CC,mBAAmB,GAAGF,EAAE,CAACE,mBAAvE;AAAA,MAA4FC,SAAS,GAAGH,EAAE,CAACG,SAA3G;AAAA,MAAsHC,cAAc,GAAGJ,EAAE,CAACI,cAA1I;AAAA,MAA0JC,SAAS,GAAGL,EAAE,CAACK,SAAzK;AACAJ,EAAAA,iBAAiB,IAAIJ,YAAY,CAACI,iBAAD,CAAjC;;AACA,WAASK,eAAT,CAAyBC,KAAzB,EAAgCC,WAAhC,EAA6C;AACzC;AACR;AACA;AACA;AACA;AACA;AACQ,QAAIC,QAAQ,GAAGnB,UAAU,CAACE,mBAAD,CAAV,CAAgCiB,QAA/C;AACA,QAAIC,QAAQ,GAAG,IAAf;AACA;AACR;AACA;AACA;;AACQ,QAAIC,OAAO,GAAGf,sBAAsB,CAACW,KAAD,EAAQE,QAAR,CAApC;AACA;AACR;AACA;;AACQ,QAAIG,WAAW,GAAGR,cAAc,CAACG,KAAD,EAAQE,QAAR,CAAhC;;AACA,QAAI,CAACA,QAAD,IAAaX,SAAjB,EAA4B;AACxB;AACZ;AACA;AACA;AACA;AACA;AACYa,MAAAA,OAAO,CAACE,aAAR,GAAwBnB,gBAAgB,CAACW,SAAD,EAAYO,WAAZ,EAAyBL,KAAzB,EAAgCL,mBAAhC,CAAxC;AACA;AACZ;AACA;AACA;AACA;AACA;AACA;;AACYQ,MAAAA,QAAQ,GAAGnB,WAAW,CAACgB,KAAD,EAAQI,OAAO,CAACE,aAAhB,EAA+BZ,iBAA/B,CAAtB;AACH;AACD;AACR;AACA;AACA;;;AACQ,WAAQb,KAAK,CAAC0B,aAAN,CAAoB1B,KAAK,CAAC2B,QAA1B,EAAoC,IAApC,EACJ3B,KAAK,CAAC0B,aAAN,CAAoBrB,aAAa,CAACuB,QAAlC,EAA4C;AAAEC,MAAAA,KAAK,EAAEN;AAAT,KAA5C,EAAgER,SAAS,CAACE,SAAD,EAAYE,KAAZ,EAAmBZ,YAAY,CAACiB,WAAD,EAAcD,OAAO,CAACE,aAAtB,EAAqCL,WAArC,CAA/B,EAAkFI,WAAlF,EAA+FH,QAA/F,CAAzE,CADI,EAEJC,QAFI,CAAR;AAGH;;AACD,SAAOrB,UAAU,CAACiB,eAAD,CAAjB;AACH;;AAED,SAASP,qBAAT","sourcesContent":["import * as React from 'react';\nimport { forwardRef, useContext } from 'react';\nimport { useFeatures } from './features/use-features.js';\nimport { MotionConfigContext } from '../context/MotionConfigContext.js';\nimport { MotionContext } from '../context/MotionContext/index.js';\nimport { useVisualElement } from './utils/use-visual-element.js';\nimport { useMotionRef } from './utils/use-motion-ref.js';\nimport { useCreateMotionContext } from '../context/MotionContext/create.js';\nimport { loadFeatures } from './features/definitions.js';\nimport { isBrowser } from '../utils/is-browser.js';\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\nfunction createMotionComponent(_a) {\n    var preloadedFeatures = _a.preloadedFeatures, createVisualElement = _a.createVisualElement, useRender = _a.useRender, useVisualState = _a.useVisualState, Component = _a.Component;\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        /**\n         * If we're rendering in a static environment, we only visually update the component\n         * as a result of a React-rerender rather than interactions or animations. This\n         * means we don't need to load additional memory structures like VisualElement,\n         * or any gesture/animation features.\n         */\n        var isStatic = useContext(MotionConfigContext).isStatic;\n        var features = null;\n        /**\n         * Create the tree context. This is memoized and will only trigger renders\n         * when the current tree variant changes in static mode.\n         */\n        var context = useCreateMotionContext(props, isStatic);\n        /**\n         *\n         */\n        var visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, props, createVisualElement);\n            /**\n             * Load Motion gesture and animation features. These are rendered as renderless\n             * components so each feature can optionally make use of React lifecycle methods.\n             *\n             * TODO: The intention is to move these away from a React-centric to a\n             * VisualElement-centric lifecycle scheme.\n             */\n            features = useFeatures(props, context.visualElement, preloadedFeatures);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (React.createElement(React.Fragment, null,\n            React.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)),\n            features));\n    }\n    return forwardRef(MotionComponent);\n}\n\nexport { createMotionComponent };\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar react = require('react');\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\n\nvar IS_EQUAL_PROMISE = Symbol();\nvar INTERRUPT_PROMISE = Symbol();\n\nvar isInterruptablePromise = function isInterruptablePromise(promise) {\n  return !!promise[INTERRUPT_PROMISE];\n};\n\nvar createInterruptablePromise = function createInterruptablePromise(promise) {\n  var interrupt;\n  var interruptablePromise = new Promise(function (resolve, reject) {\n    interrupt = resolve;\n    promise.then(resolve, reject);\n  });\n\n  interruptablePromise[IS_EQUAL_PROMISE] = function (p) {\n    return p === interruptablePromise || p === promise;\n  };\n\n  interruptablePromise[INTERRUPT_PROMISE] = interrupt;\n  return interruptablePromise;\n};\n\nvar READ_ATOM = 'r';\nvar WRITE_ATOM = 'w';\nvar FLUSH_PENDING = 'f';\nvar SUBSCRIBE_ATOM = 's';\nvar RESTORE_ATOMS = 'h';\nvar DEV_GET_ATOM_STATE = 'a';\nvar DEV_GET_MOUNTED = 'm';\n\nvar createStore = function createStore(initialValues, stateListener) {\n  var _ref4;\n\n  var atomStateMap = new WeakMap();\n  var mountedMap = new WeakMap();\n  var pendingMap = new Map();\n\n  if (initialValues) {\n    for (var _iterator = _createForOfIteratorHelperLoose(initialValues), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n          atom = _step$value[0],\n          value = _step$value[1];\n      var atomState = {\n        v: value,\n        r: 0,\n        d: new Map()\n      };\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        Object.freeze(atomState);\n\n        if (!hasInitialValue(atom)) {\n          console.warn('Found initial value for derived atom which can cause unexpected behavior', atom);\n        }\n      }\n\n      atomStateMap.set(atom, atomState);\n    }\n  }\n\n  var getAtomState = function getAtomState(atom) {\n    return atomStateMap.get(atom);\n  };\n\n  var wipAtomState = function wipAtomState(atom, dependencies) {\n    var atomState = getAtomState(atom);\n\n    var nextAtomState = _extends({\n      r: 0\n    }, atomState, {\n      d: dependencies ? new Map(Array.from(dependencies).map(function (a) {\n        var _getAtomState$r, _getAtomState;\n\n        return [a, (_getAtomState$r = (_getAtomState = getAtomState(a)) == null ? void 0 : _getAtomState.r) != null ? _getAtomState$r : 0];\n      })) : (atomState == null ? void 0 : atomState.d) || new Map()\n    });\n\n    return [nextAtomState, (atomState == null ? void 0 : atomState.d) || new Map()];\n  };\n\n  var setAtomValue = function setAtomValue(atom, value, dependencies, promise) {\n    var _atomState$p;\n\n    var _wipAtomState = wipAtomState(atom, dependencies),\n        atomState = _wipAtomState[0],\n        prevDependencies = _wipAtomState[1];\n\n    if (promise && !((_atomState$p = atomState.p) != null && _atomState$p[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n    delete atomState.e;\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n\n    if (!('v' in atomState) || !Object.is(atomState.v, value)) {\n      atomState.v = value;\n      ++atomState.r;\n\n      if (atomState.d.has(atom)) {\n        atomState.d.set(atom, atomState.r);\n      }\n    }\n\n    commitAtomState(atom, atomState, dependencies && prevDependencies);\n  };\n\n  var setAtomReadError = function setAtomReadError(atom, error, dependencies, promise) {\n    var _atomState$p2;\n\n    var _wipAtomState2 = wipAtomState(atom, dependencies),\n        atomState = _wipAtomState2[0],\n        prevDependencies = _wipAtomState2[1];\n\n    if (promise && !((_atomState$p2 = atomState.p) != null && _atomState$p2[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n    atomState.e = error;\n    commitAtomState(atom, atomState, prevDependencies);\n  };\n\n  var setAtomReadPromise = function setAtomReadPromise(atom, promise, dependencies) {\n    var _atomState$p3;\n\n    var _wipAtomState3 = wipAtomState(atom, dependencies),\n        atomState = _wipAtomState3[0],\n        prevDependencies = _wipAtomState3[1];\n\n    if ((_atomState$p3 = atomState.p) != null && _atomState$p3[IS_EQUAL_PROMISE](promise)) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n\n    if (isInterruptablePromise(promise)) {\n      atomState.p = promise;\n      delete atomState.c;\n    } else {\n      var interruptablePromise = createInterruptablePromise(promise);\n      atomState.p = interruptablePromise;\n      atomState.c = interruptablePromise[INTERRUPT_PROMISE];\n    }\n\n    commitAtomState(atom, atomState, prevDependencies);\n  };\n\n  var setAtomInvalidated = function setAtomInvalidated(atom) {\n    var _wipAtomState4 = wipAtomState(atom),\n        atomState = _wipAtomState4[0];\n\n    atomState.i = atomState.r;\n    commitAtomState(atom, atomState);\n  };\n\n  var setAtomWritePromise = function setAtomWritePromise(atom, promise) {\n    var _wipAtomState5 = wipAtomState(atom),\n        atomState = _wipAtomState5[0];\n\n    if (promise) {\n      atomState.w = promise;\n    } else {\n      delete atomState.w;\n    }\n\n    commitAtomState(atom, atomState);\n  };\n\n  var scheduleReadAtomState = function scheduleReadAtomState(atom, promise) {\n    promise.finally(function () {\n      readAtomState(atom, true);\n    });\n  };\n\n  var readAtomState = function readAtomState(atom, force) {\n    if (!force) {\n      var _atomState = getAtomState(atom);\n\n      if (_atomState) {\n        _atomState.d.forEach(function (_, a) {\n          if (a !== atom) {\n            var aState = getAtomState(a);\n\n            if (aState && !aState.e && !aState.p && aState.r === aState.i) {\n              readAtomState(a, true);\n            }\n          }\n        });\n\n        if (Array.from(_atomState.d.entries()).every(function (_ref) {\n          var a = _ref[0],\n              r = _ref[1];\n          var aState = getAtomState(a);\n          return aState && !aState.e && !aState.p && aState.r !== aState.i && aState.r === r;\n        })) {\n          return _atomState;\n        }\n      }\n    }\n\n    var error;\n    var promise;\n    var value;\n    var dependencies = new Set();\n\n    try {\n      var promiseOrValue = atom.read(function (a) {\n        dependencies.add(a);\n        var aState = a === atom ? getAtomState(a) : readAtomState(a);\n\n        if (aState) {\n          if (aState.e) {\n            throw aState.e;\n          }\n\n          if (aState.p) {\n            throw aState.p;\n          }\n\n          return aState.v;\n        }\n\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n\n        throw new Error('no atom init');\n      });\n\n      if (promiseOrValue instanceof Promise) {\n        promise = promiseOrValue.then(function (value) {\n          setAtomValue(atom, value, dependencies, promise);\n          flushPending();\n        }).catch(function (e) {\n          if (e instanceof Promise) {\n            scheduleReadAtomState(atom, e);\n            return e;\n          }\n\n          setAtomReadError(atom, e instanceof Error ? e : new Error(e), dependencies, promise);\n          flushPending();\n        });\n      } else {\n        value = promiseOrValue;\n      }\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        promise = errorOrPromise;\n      } else if (errorOrPromise instanceof Error) {\n        error = errorOrPromise;\n      } else {\n        error = new Error(errorOrPromise);\n      }\n    }\n\n    if (error) {\n      setAtomReadError(atom, error, dependencies);\n    } else if (promise) {\n      setAtomReadPromise(atom, promise, dependencies);\n    } else {\n      setAtomValue(atom, value, dependencies);\n    }\n\n    return getAtomState(atom);\n  };\n\n  var readAtom = function readAtom(readingAtom) {\n    var atomState = readAtomState(readingAtom);\n    return atomState;\n  };\n\n  var addAtom = function addAtom(addingAtom) {\n    var mounted = mountedMap.get(addingAtom);\n\n    if (!mounted) {\n      mounted = mountAtom(addingAtom);\n    }\n\n    flushPending();\n    return mounted;\n  };\n\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.d.size || mounted.d.size === 1 && mounted.d.has(atom));\n  };\n\n  var delAtom = function delAtom(deletingAtom) {\n    var mounted = mountedMap.get(deletingAtom);\n\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(deletingAtom);\n    }\n\n    flushPending();\n  };\n\n  var invalidateDependents = function invalidateDependents(atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.d.forEach(function (dependent) {\n      if (dependent === atom) {\n        return;\n      }\n\n      setAtomInvalidated(dependent);\n      invalidateDependents(dependent);\n    });\n  };\n\n  var writeAtomState = function writeAtomState(atom, update) {\n    var _getAtomState2;\n\n    var writePromise = (_getAtomState2 = getAtomState(atom)) == null ? void 0 : _getAtomState2.w;\n\n    if (writePromise) {\n      writePromise.then(function () {\n        writeAtomState(atom, update);\n        flushPending();\n      });\n      return;\n    }\n\n    var writeGetter = function writeGetter(a, unstable_promise) {\n      if (unstable_promise === void 0) {\n        unstable_promise = false;\n      }\n\n      var aState = readAtomState(a);\n\n      if (aState.e) {\n        throw aState.e;\n      }\n\n      if (aState.p) {\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          if (unstable_promise) {\n            console.info('promise option in getter is an experimental feature.', a);\n          } else {\n            console.warn('Reading pending atom state in write operation. We throw a promise for now.', a);\n          }\n        }\n\n        if (unstable_promise) {\n          return aState.p.then(function () {\n            return writeGetter(a, unstable_promise);\n          });\n        }\n\n        throw aState.p;\n      }\n\n      if ('v' in aState) {\n        return aState.v;\n      }\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        console.warn('[Bug] no value found while reading atom in write operation. This is probably a bug.', a);\n      }\n\n      throw new Error('no value found');\n    };\n\n    var setter = function setter(a, v) {\n      var promiseOrVoid;\n\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error('no atom init');\n        }\n\n        if (v instanceof Promise) {\n          promiseOrVoid = v.then(function (resolvedValue) {\n            setAtomValue(a, resolvedValue);\n            invalidateDependents(a);\n            flushPending();\n          }).catch(function (e) {\n            setAtomReadError(atom, e instanceof Error ? e : new Error(e));\n            flushPending();\n          });\n          setAtomReadPromise(atom, promiseOrVoid);\n        } else {\n          setAtomValue(a, v);\n        }\n\n        invalidateDependents(a);\n      } else {\n        promiseOrVoid = writeAtomState(a, v);\n      }\n\n      flushPending();\n      return promiseOrVoid;\n    };\n\n    var promiseOrVoid = atom.write(writeGetter, setter, update);\n\n    if (promiseOrVoid instanceof Promise) {\n      var promise = promiseOrVoid.finally(function () {\n        setAtomWritePromise(atom);\n        flushPending();\n      });\n      setAtomWritePromise(atom, promise);\n    }\n\n    return promiseOrVoid;\n  };\n\n  var writeAtom = function writeAtom(writingAtom, update) {\n    var promiseOrVoid = writeAtomState(writingAtom, update);\n    flushPending();\n    return promiseOrVoid;\n  };\n\n  var isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n    return !!atom.write;\n  };\n\n  var mountAtom = function mountAtom(atom, initialDependent) {\n    var atomState = readAtomState(atom);\n    atomState.d.forEach(function (_, a) {\n      if (a !== atom) {\n        var aMounted = mountedMap.get(a);\n\n        if (aMounted) {\n          aMounted.d.add(atom);\n        } else {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    var mounted = {\n      d: new Set(initialDependent && [initialDependent]),\n      l: new Set(),\n      u: undefined\n    };\n    mountedMap.set(atom, mounted);\n\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var setAtom = function setAtom(update) {\n        return writeAtom(atom, update);\n      };\n\n      mounted.u = atom.onMount(setAtom);\n    }\n\n    return mounted;\n  };\n\n  var unmountAtom = function unmountAtom(atom) {\n    var _mountedMap$get;\n\n    var onUnmount = (_mountedMap$get = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get.u;\n\n    if (onUnmount) {\n      onUnmount();\n    }\n\n    mountedMap.delete(atom);\n    var atomState = getAtomState(atom);\n\n    if (atomState) {\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n\n          if (mounted) {\n            mounted.d.delete(atom);\n\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] could not find atom state to unmount', atom);\n    }\n  };\n\n  var mountDependencies = function mountDependencies(atom, atomState, prevDependencies) {\n    var dependencies = new Set(atomState.d.keys());\n    prevDependencies.forEach(function (_, a) {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.d.delete(atom);\n\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    dependencies.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        var dependents = mounted.d;\n        dependents.add(atom);\n      } else {\n        mountAtom(a, atom);\n      }\n    });\n  };\n\n  var commitAtomState = function commitAtomState(atom, atomState, prevDependencies) {\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      Object.freeze(atomState);\n    }\n\n    var isNewAtom = !atomStateMap.has(atom);\n    atomStateMap.set(atom, atomState);\n\n    if (stateListener) {\n      stateListener(atom, isNewAtom);\n    }\n\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevDependencies);\n    }\n  };\n\n  var flushPending = function flushPending() {\n    var pending = Array.from(pendingMap);\n    pendingMap.clear();\n    pending.forEach(function (_ref2) {\n      var atom = _ref2[0],\n          prevDependencies = _ref2[1];\n      var atomState = getAtomState(atom);\n\n      if (atomState) {\n        if (prevDependencies) {\n          mountDependencies(atom, atomState, prevDependencies);\n        }\n      } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        console.warn('[Bug] atom state not found in flush', atom);\n      }\n\n      var mounted = mountedMap.get(atom);\n      mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n        return listener();\n      });\n    });\n  };\n\n  var subscribeAtom = function subscribeAtom(atom, callback) {\n    var mounted = addAtom(atom);\n    var listeners = mounted.l;\n    listeners.add(callback);\n    return function () {\n      listeners.delete(callback);\n      delAtom(atom);\n    };\n  };\n\n  var restoreAtoms = function restoreAtoms(values) {\n    for (var _iterator2 = _createForOfIteratorHelperLoose(values), _step2; !(_step2 = _iterator2()).done;) {\n      var _step2$value = _step2.value,\n          _atom = _step2$value[0],\n          _value = _step2$value[1];\n\n      if (hasInitialValue(_atom)) {\n        setAtomValue(_atom, _value);\n        invalidateDependents(_atom);\n      }\n    }\n\n    flushPending();\n  };\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    var _ref3;\n\n    return _ref3 = {}, _ref3[READ_ATOM] = readAtom, _ref3[WRITE_ATOM] = writeAtom, _ref3[FLUSH_PENDING] = flushPending, _ref3[SUBSCRIBE_ATOM] = subscribeAtom, _ref3[RESTORE_ATOMS] = restoreAtoms, _ref3[DEV_GET_ATOM_STATE] = function (a) {\n      return atomStateMap.get(a);\n    }, _ref3[DEV_GET_MOUNTED] = function (a) {\n      return mountedMap.get(a);\n    }, _ref3;\n  }\n\n  return _ref4 = {}, _ref4[READ_ATOM] = readAtom, _ref4[WRITE_ATOM] = writeAtom, _ref4[FLUSH_PENDING] = flushPending, _ref4[SUBSCRIBE_ATOM] = subscribeAtom, _ref4[RESTORE_ATOMS] = restoreAtoms, _ref4;\n};\n\nvar createScopeContainerForProduction = function createScopeContainerForProduction(initialValues) {\n  var store = createStore(initialValues);\n  return [store];\n};\n\nvar createScopeContainerForDevelopment = function createScopeContainerForDevelopment(initialValues) {\n  var devStore = {\n    listeners: new Set(),\n    subscribe: function subscribe(callback) {\n      devStore.listeners.add(callback);\n      return function () {\n        devStore.listeners.delete(callback);\n      };\n    },\n    atoms: Array.from(initialValues != null ? initialValues : []).map(function (_ref) {\n      var a = _ref[0];\n      return a;\n    })\n  };\n\n  var stateListener = function stateListener(updatedAtom, isNewAtom) {\n    if (isNewAtom) {\n      devStore.atoms = [].concat(devStore.atoms, [updatedAtom]);\n    }\n\n    Promise.resolve().then(function () {\n      devStore.listeners.forEach(function (listener) {\n        return listener();\n      });\n    });\n  };\n\n  var store = createStore(initialValues, stateListener);\n  return [store, devStore];\n};\n\nvar isDevScopeContainer = function isDevScopeContainer(scopeContainer) {\n  return scopeContainer.length > 1;\n};\n\nvar createScopeContainer = typeof process === 'object' && process.env.NODE_ENV !== 'production' ? createScopeContainerForDevelopment : createScopeContainerForProduction;\nvar ScopeContextMap = new Map();\n\nvar getScopeContext = function getScopeContext(scope) {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, react.createContext(createScopeContainer()));\n  }\n\n  return ScopeContextMap.get(scope);\n};\n\nvar Provider = function Provider(_ref) {\n  var initialValues = _ref.initialValues,\n      scope = _ref.scope,\n      children = _ref.children;\n  var scopeContainerRef = react.useRef();\n\n  if (!scopeContainerRef.current) {\n    scopeContainerRef.current = createScopeContainer(initialValues);\n  }\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test' && isDevScopeContainer(scopeContainerRef.current)) {\n    useDebugState(scopeContainerRef.current);\n  }\n\n  var ScopeContainerContext = getScopeContext(scope);\n  return react.createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\n\nvar atomToPrintable = function atomToPrintable(atom) {\n  return atom.debugLabel || atom.toString();\n};\n\nvar stateToPrintable = function stateToPrintable(_ref2) {\n  var store = _ref2[0],\n      atoms = _ref2[1];\n  return Object.fromEntries(atoms.flatMap(function (atom) {\n    var _store$DEV_GET_MOUNTE, _store$DEV_GET_ATOM_S;\n\n    var mounted = (_store$DEV_GET_MOUNTE = store[DEV_GET_MOUNTED]) == null ? void 0 : _store$DEV_GET_MOUNTE.call(store, atom);\n\n    if (!mounted) {\n      return [];\n    }\n\n    var dependents = mounted.d;\n    var atomState = ((_store$DEV_GET_ATOM_S = store[DEV_GET_ATOM_STATE]) == null ? void 0 : _store$DEV_GET_ATOM_S.call(store, atom)) || {};\n    return [[atomToPrintable(atom), {\n      value: atomState.e || atomState.p || atomState.w || atomState.v,\n      dependents: Array.from(dependents).map(atomToPrintable)\n    }]];\n  }));\n};\n\nvar useDebugState = function useDebugState(scopeContainer) {\n  var store = scopeContainer[0],\n      devStore = scopeContainer[1];\n\n  var _useState = react.useState(devStore.atoms),\n      atoms = _useState[0],\n      setAtoms = _useState[1];\n\n  react.useEffect(function () {\n    var callback = function callback() {\n      return setAtoms([].concat(devStore.atoms));\n    };\n\n    var unsubscribe = devStore.subscribe(callback);\n    callback();\n    return unsubscribe;\n  }, [devStore]);\n  react.useDebugValue([store, atoms], stateToPrintable);\n};\n\nvar keyCount = 0;\n\nfunction atom(read, write) {\n  var key = \"atom\" + ++keyCount;\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n\n    config.read = function (get) {\n      return get(config);\n    };\n\n    config.write = function (get, set, update) {\n      set(config, typeof update === 'function' ? update(get(config)) : update);\n    };\n  }\n\n  if (write) {\n    config.write = write;\n  }\n\n  return config;\n}\n\nvar isWritable = function isWritable(atom) {\n  return !!atom.write;\n};\n\nfunction useAtom(atom, scope) {\n  if ('scope' in atom) {\n    console.warn('atom.scope is deprecated. Please do useAtom(atom, scope) instead.');\n    scope = atom.scope;\n  }\n\n  var ScopeContext = getScopeContext(scope);\n\n  var _useContext = react.useContext(ScopeContext),\n      store = _useContext[0];\n\n  var getAtomValue = react.useCallback(function () {\n    var atomState = store[READ_ATOM](atom);\n\n    if (atomState.e) {\n      throw atomState.e;\n    }\n\n    if (atomState.p) {\n      throw atomState.p;\n    }\n\n    if (atomState.w) {\n      throw atomState.w;\n    }\n\n    if ('v' in atomState) {\n      return atomState.v;\n    }\n\n    throw new Error('no atom value');\n  }, [store, atom]);\n\n  var _useReducer = react.useReducer(getAtomValue, undefined, getAtomValue),\n      value = _useReducer[0],\n      forceUpdate = _useReducer[1];\n\n  react.useEffect(function () {\n    var unsubscribe = store[SUBSCRIBE_ATOM](atom, forceUpdate);\n    forceUpdate();\n    return unsubscribe;\n  }, [store, atom]);\n  react.useEffect(function () {\n    store[FLUSH_PENDING]();\n  });\n  var setAtom = react.useCallback(function (update) {\n    if (isWritable(atom)) {\n      return store[WRITE_ATOM](atom, update);\n    } else {\n      throw new Error('not writable atom');\n    }\n  }, [store, atom]);\n  react.useDebugValue(value);\n  return [value, setAtom];\n}\n\nexports.Provider = Provider;\nexports.SECRET_INTERNAL_getScopeContext = getScopeContext;\nexports.atom = atom;\nexports.useAtom = useAtom;","map":{"version":3,"sources":["/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/jotai/index.js"],"names":["Object","defineProperty","exports","value","react","require","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_unsupportedIterableToArray","o","minLen","_arrayLikeToArray","n","toString","slice","constructor","name","Array","from","test","arr","len","arr2","_createForOfIteratorHelperLoose","allowArrayLike","it","Symbol","iterator","next","bind","isArray","done","TypeError","hasInitialValue","atom","IS_EQUAL_PROMISE","INTERRUPT_PROMISE","isInterruptablePromise","promise","createInterruptablePromise","interrupt","interruptablePromise","Promise","resolve","reject","then","p","READ_ATOM","WRITE_ATOM","FLUSH_PENDING","SUBSCRIBE_ATOM","RESTORE_ATOMS","DEV_GET_ATOM_STATE","DEV_GET_MOUNTED","createStore","initialValues","stateListener","_ref4","atomStateMap","WeakMap","mountedMap","pendingMap","Map","_iterator","_step","_step$value","atomState","v","r","d","process","env","NODE_ENV","freeze","console","warn","set","getAtomState","get","wipAtomState","dependencies","nextAtomState","map","a","_getAtomState$r","_getAtomState","setAtomValue","_atomState$p","_wipAtomState","prevDependencies","c","e","is","has","commitAtomState","setAtomReadError","error","_atomState$p2","_wipAtomState2","setAtomReadPromise","_atomState$p3","_wipAtomState3","setAtomInvalidated","_wipAtomState4","setAtomWritePromise","_wipAtomState5","w","scheduleReadAtomState","finally","readAtomState","force","_atomState","forEach","_","aState","entries","every","_ref","Set","promiseOrValue","read","add","init","Error","flushPending","catch","errorOrPromise","readAtom","readingAtom","addAtom","addingAtom","mounted","mountAtom","canUnmountAtom","l","size","delAtom","deletingAtom","unmountAtom","invalidateDependents","dependent","writeAtomState","update","_getAtomState2","writePromise","writeGetter","unstable_promise","info","setter","promiseOrVoid","resolvedValue","write","writeAtom","writingAtom","isActuallyWritableAtom","initialDependent","aMounted","u","undefined","onMount","setAtom","_mountedMap$get","onUnmount","delete","mountDependencies","keys","dependents","isNewAtom","pending","clear","_ref2","listener","subscribeAtom","callback","listeners","restoreAtoms","values","_iterator2","_step2","_step2$value","_atom","_value","_ref3","createScopeContainerForProduction","store","createScopeContainerForDevelopment","devStore","subscribe","atoms","updatedAtom","concat","isDevScopeContainer","scopeContainer","createScopeContainer","ScopeContextMap","getScopeContext","scope","createContext","Provider","children","scopeContainerRef","useRef","current","useDebugState","ScopeContainerContext","createElement","atomToPrintable","debugLabel","stateToPrintable","fromEntries","flatMap","_store$DEV_GET_MOUNTE","_store$DEV_GET_ATOM_S","_useState","useState","setAtoms","useEffect","unsubscribe","useDebugValue","keyCount","config","isWritable","useAtom","ScopeContext","_useContext","useContext","getAtomValue","useCallback","_useReducer","useReducer","forceUpdate","SECRET_INTERNAL_getScopeContext"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar react = require('react');\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\n\nvar IS_EQUAL_PROMISE = Symbol();\nvar INTERRUPT_PROMISE = Symbol();\n\nvar isInterruptablePromise = function isInterruptablePromise(promise) {\n  return !!promise[INTERRUPT_PROMISE];\n};\n\nvar createInterruptablePromise = function createInterruptablePromise(promise) {\n  var interrupt;\n  var interruptablePromise = new Promise(function (resolve, reject) {\n    interrupt = resolve;\n    promise.then(resolve, reject);\n  });\n\n  interruptablePromise[IS_EQUAL_PROMISE] = function (p) {\n    return p === interruptablePromise || p === promise;\n  };\n\n  interruptablePromise[INTERRUPT_PROMISE] = interrupt;\n  return interruptablePromise;\n};\n\nvar READ_ATOM = 'r';\nvar WRITE_ATOM = 'w';\nvar FLUSH_PENDING = 'f';\nvar SUBSCRIBE_ATOM = 's';\nvar RESTORE_ATOMS = 'h';\nvar DEV_GET_ATOM_STATE = 'a';\nvar DEV_GET_MOUNTED = 'm';\nvar createStore = function createStore(initialValues, stateListener) {\n  var _ref4;\n\n  var atomStateMap = new WeakMap();\n  var mountedMap = new WeakMap();\n  var pendingMap = new Map();\n\n  if (initialValues) {\n    for (var _iterator = _createForOfIteratorHelperLoose(initialValues), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n          atom = _step$value[0],\n          value = _step$value[1];\n      var atomState = {\n        v: value,\n        r: 0,\n        d: new Map()\n      };\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        Object.freeze(atomState);\n\n        if (!hasInitialValue(atom)) {\n          console.warn('Found initial value for derived atom which can cause unexpected behavior', atom);\n        }\n      }\n\n      atomStateMap.set(atom, atomState);\n    }\n  }\n\n  var getAtomState = function getAtomState(atom) {\n    return atomStateMap.get(atom);\n  };\n\n  var wipAtomState = function wipAtomState(atom, dependencies) {\n    var atomState = getAtomState(atom);\n\n    var nextAtomState = _extends({\n      r: 0\n    }, atomState, {\n      d: dependencies ? new Map(Array.from(dependencies).map(function (a) {\n        var _getAtomState$r, _getAtomState;\n\n        return [a, (_getAtomState$r = (_getAtomState = getAtomState(a)) == null ? void 0 : _getAtomState.r) != null ? _getAtomState$r : 0];\n      })) : (atomState == null ? void 0 : atomState.d) || new Map()\n    });\n\n    return [nextAtomState, (atomState == null ? void 0 : atomState.d) || new Map()];\n  };\n\n  var setAtomValue = function setAtomValue(atom, value, dependencies, promise) {\n    var _atomState$p;\n\n    var _wipAtomState = wipAtomState(atom, dependencies),\n        atomState = _wipAtomState[0],\n        prevDependencies = _wipAtomState[1];\n\n    if (promise && !((_atomState$p = atomState.p) != null && _atomState$p[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n    delete atomState.e;\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n\n    if (!('v' in atomState) || !Object.is(atomState.v, value)) {\n      atomState.v = value;\n      ++atomState.r;\n\n      if (atomState.d.has(atom)) {\n        atomState.d.set(atom, atomState.r);\n      }\n    }\n\n    commitAtomState(atom, atomState, dependencies && prevDependencies);\n  };\n\n  var setAtomReadError = function setAtomReadError(atom, error, dependencies, promise) {\n    var _atomState$p2;\n\n    var _wipAtomState2 = wipAtomState(atom, dependencies),\n        atomState = _wipAtomState2[0],\n        prevDependencies = _wipAtomState2[1];\n\n    if (promise && !((_atomState$p2 = atomState.p) != null && _atomState$p2[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n    atomState.e = error;\n    commitAtomState(atom, atomState, prevDependencies);\n  };\n\n  var setAtomReadPromise = function setAtomReadPromise(atom, promise, dependencies) {\n    var _atomState$p3;\n\n    var _wipAtomState3 = wipAtomState(atom, dependencies),\n        atomState = _wipAtomState3[0],\n        prevDependencies = _wipAtomState3[1];\n\n    if ((_atomState$p3 = atomState.p) != null && _atomState$p3[IS_EQUAL_PROMISE](promise)) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n\n    if (isInterruptablePromise(promise)) {\n      atomState.p = promise;\n      delete atomState.c;\n    } else {\n      var interruptablePromise = createInterruptablePromise(promise);\n      atomState.p = interruptablePromise;\n      atomState.c = interruptablePromise[INTERRUPT_PROMISE];\n    }\n\n    commitAtomState(atom, atomState, prevDependencies);\n  };\n\n  var setAtomInvalidated = function setAtomInvalidated(atom) {\n    var _wipAtomState4 = wipAtomState(atom),\n        atomState = _wipAtomState4[0];\n\n    atomState.i = atomState.r;\n    commitAtomState(atom, atomState);\n  };\n\n  var setAtomWritePromise = function setAtomWritePromise(atom, promise) {\n    var _wipAtomState5 = wipAtomState(atom),\n        atomState = _wipAtomState5[0];\n\n    if (promise) {\n      atomState.w = promise;\n    } else {\n      delete atomState.w;\n    }\n\n    commitAtomState(atom, atomState);\n  };\n\n  var scheduleReadAtomState = function scheduleReadAtomState(atom, promise) {\n    promise.finally(function () {\n      readAtomState(atom, true);\n    });\n  };\n\n  var readAtomState = function readAtomState(atom, force) {\n    if (!force) {\n      var _atomState = getAtomState(atom);\n\n      if (_atomState) {\n        _atomState.d.forEach(function (_, a) {\n          if (a !== atom) {\n            var aState = getAtomState(a);\n\n            if (aState && !aState.e && !aState.p && aState.r === aState.i) {\n              readAtomState(a, true);\n            }\n          }\n        });\n\n        if (Array.from(_atomState.d.entries()).every(function (_ref) {\n          var a = _ref[0],\n              r = _ref[1];\n          var aState = getAtomState(a);\n          return aState && !aState.e && !aState.p && aState.r !== aState.i && aState.r === r;\n        })) {\n          return _atomState;\n        }\n      }\n    }\n\n    var error;\n    var promise;\n    var value;\n    var dependencies = new Set();\n\n    try {\n      var promiseOrValue = atom.read(function (a) {\n        dependencies.add(a);\n        var aState = a === atom ? getAtomState(a) : readAtomState(a);\n\n        if (aState) {\n          if (aState.e) {\n            throw aState.e;\n          }\n\n          if (aState.p) {\n            throw aState.p;\n          }\n\n          return aState.v;\n        }\n\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n\n        throw new Error('no atom init');\n      });\n\n      if (promiseOrValue instanceof Promise) {\n        promise = promiseOrValue.then(function (value) {\n          setAtomValue(atom, value, dependencies, promise);\n          flushPending();\n        }).catch(function (e) {\n          if (e instanceof Promise) {\n            scheduleReadAtomState(atom, e);\n            return e;\n          }\n\n          setAtomReadError(atom, e instanceof Error ? e : new Error(e), dependencies, promise);\n          flushPending();\n        });\n      } else {\n        value = promiseOrValue;\n      }\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        promise = errorOrPromise;\n      } else if (errorOrPromise instanceof Error) {\n        error = errorOrPromise;\n      } else {\n        error = new Error(errorOrPromise);\n      }\n    }\n\n    if (error) {\n      setAtomReadError(atom, error, dependencies);\n    } else if (promise) {\n      setAtomReadPromise(atom, promise, dependencies);\n    } else {\n      setAtomValue(atom, value, dependencies);\n    }\n\n    return getAtomState(atom);\n  };\n\n  var readAtom = function readAtom(readingAtom) {\n    var atomState = readAtomState(readingAtom);\n    return atomState;\n  };\n\n  var addAtom = function addAtom(addingAtom) {\n    var mounted = mountedMap.get(addingAtom);\n\n    if (!mounted) {\n      mounted = mountAtom(addingAtom);\n    }\n\n    flushPending();\n    return mounted;\n  };\n\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.d.size || mounted.d.size === 1 && mounted.d.has(atom));\n  };\n\n  var delAtom = function delAtom(deletingAtom) {\n    var mounted = mountedMap.get(deletingAtom);\n\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(deletingAtom);\n    }\n\n    flushPending();\n  };\n\n  var invalidateDependents = function invalidateDependents(atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.d.forEach(function (dependent) {\n      if (dependent === atom) {\n        return;\n      }\n\n      setAtomInvalidated(dependent);\n      invalidateDependents(dependent);\n    });\n  };\n\n  var writeAtomState = function writeAtomState(atom, update) {\n    var _getAtomState2;\n\n    var writePromise = (_getAtomState2 = getAtomState(atom)) == null ? void 0 : _getAtomState2.w;\n\n    if (writePromise) {\n      writePromise.then(function () {\n        writeAtomState(atom, update);\n        flushPending();\n      });\n      return;\n    }\n\n    var writeGetter = function writeGetter(a, unstable_promise) {\n      if (unstable_promise === void 0) {\n        unstable_promise = false;\n      }\n\n      var aState = readAtomState(a);\n\n      if (aState.e) {\n        throw aState.e;\n      }\n\n      if (aState.p) {\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          if (unstable_promise) {\n            console.info('promise option in getter is an experimental feature.', a);\n          } else {\n            console.warn('Reading pending atom state in write operation. We throw a promise for now.', a);\n          }\n        }\n\n        if (unstable_promise) {\n          return aState.p.then(function () {\n            return writeGetter(a, unstable_promise);\n          });\n        }\n\n        throw aState.p;\n      }\n\n      if ('v' in aState) {\n        return aState.v;\n      }\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        console.warn('[Bug] no value found while reading atom in write operation. This is probably a bug.', a);\n      }\n\n      throw new Error('no value found');\n    };\n\n    var setter = function setter(a, v) {\n      var promiseOrVoid;\n\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error('no atom init');\n        }\n\n        if (v instanceof Promise) {\n          promiseOrVoid = v.then(function (resolvedValue) {\n            setAtomValue(a, resolvedValue);\n            invalidateDependents(a);\n            flushPending();\n          }).catch(function (e) {\n            setAtomReadError(atom, e instanceof Error ? e : new Error(e));\n            flushPending();\n          });\n          setAtomReadPromise(atom, promiseOrVoid);\n        } else {\n          setAtomValue(a, v);\n        }\n\n        invalidateDependents(a);\n      } else {\n        promiseOrVoid = writeAtomState(a, v);\n      }\n\n      flushPending();\n      return promiseOrVoid;\n    };\n\n    var promiseOrVoid = atom.write(writeGetter, setter, update);\n\n    if (promiseOrVoid instanceof Promise) {\n      var promise = promiseOrVoid.finally(function () {\n        setAtomWritePromise(atom);\n        flushPending();\n      });\n      setAtomWritePromise(atom, promise);\n    }\n\n    return promiseOrVoid;\n  };\n\n  var writeAtom = function writeAtom(writingAtom, update) {\n    var promiseOrVoid = writeAtomState(writingAtom, update);\n    flushPending();\n    return promiseOrVoid;\n  };\n\n  var isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n    return !!atom.write;\n  };\n\n  var mountAtom = function mountAtom(atom, initialDependent) {\n    var atomState = readAtomState(atom);\n    atomState.d.forEach(function (_, a) {\n      if (a !== atom) {\n        var aMounted = mountedMap.get(a);\n\n        if (aMounted) {\n          aMounted.d.add(atom);\n        } else {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    var mounted = {\n      d: new Set(initialDependent && [initialDependent]),\n      l: new Set(),\n      u: undefined\n    };\n    mountedMap.set(atom, mounted);\n\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var setAtom = function setAtom(update) {\n        return writeAtom(atom, update);\n      };\n\n      mounted.u = atom.onMount(setAtom);\n    }\n\n    return mounted;\n  };\n\n  var unmountAtom = function unmountAtom(atom) {\n    var _mountedMap$get;\n\n    var onUnmount = (_mountedMap$get = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get.u;\n\n    if (onUnmount) {\n      onUnmount();\n    }\n\n    mountedMap.delete(atom);\n    var atomState = getAtomState(atom);\n\n    if (atomState) {\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n\n          if (mounted) {\n            mounted.d.delete(atom);\n\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] could not find atom state to unmount', atom);\n    }\n  };\n\n  var mountDependencies = function mountDependencies(atom, atomState, prevDependencies) {\n    var dependencies = new Set(atomState.d.keys());\n    prevDependencies.forEach(function (_, a) {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.d.delete(atom);\n\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    dependencies.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        var dependents = mounted.d;\n        dependents.add(atom);\n      } else {\n        mountAtom(a, atom);\n      }\n    });\n  };\n\n  var commitAtomState = function commitAtomState(atom, atomState, prevDependencies) {\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      Object.freeze(atomState);\n    }\n\n    var isNewAtom = !atomStateMap.has(atom);\n    atomStateMap.set(atom, atomState);\n\n    if (stateListener) {\n      stateListener(atom, isNewAtom);\n    }\n\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevDependencies);\n    }\n  };\n\n  var flushPending = function flushPending() {\n    var pending = Array.from(pendingMap);\n    pendingMap.clear();\n    pending.forEach(function (_ref2) {\n      var atom = _ref2[0],\n          prevDependencies = _ref2[1];\n      var atomState = getAtomState(atom);\n\n      if (atomState) {\n        if (prevDependencies) {\n          mountDependencies(atom, atomState, prevDependencies);\n        }\n      } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        console.warn('[Bug] atom state not found in flush', atom);\n      }\n\n      var mounted = mountedMap.get(atom);\n      mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n        return listener();\n      });\n    });\n  };\n\n  var subscribeAtom = function subscribeAtom(atom, callback) {\n    var mounted = addAtom(atom);\n    var listeners = mounted.l;\n    listeners.add(callback);\n    return function () {\n      listeners.delete(callback);\n      delAtom(atom);\n    };\n  };\n\n  var restoreAtoms = function restoreAtoms(values) {\n    for (var _iterator2 = _createForOfIteratorHelperLoose(values), _step2; !(_step2 = _iterator2()).done;) {\n      var _step2$value = _step2.value,\n          _atom = _step2$value[0],\n          _value = _step2$value[1];\n\n      if (hasInitialValue(_atom)) {\n        setAtomValue(_atom, _value);\n        invalidateDependents(_atom);\n      }\n    }\n\n    flushPending();\n  };\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    var _ref3;\n\n    return _ref3 = {}, _ref3[READ_ATOM] = readAtom, _ref3[WRITE_ATOM] = writeAtom, _ref3[FLUSH_PENDING] = flushPending, _ref3[SUBSCRIBE_ATOM] = subscribeAtom, _ref3[RESTORE_ATOMS] = restoreAtoms, _ref3[DEV_GET_ATOM_STATE] = function (a) {\n      return atomStateMap.get(a);\n    }, _ref3[DEV_GET_MOUNTED] = function (a) {\n      return mountedMap.get(a);\n    }, _ref3;\n  }\n\n  return _ref4 = {}, _ref4[READ_ATOM] = readAtom, _ref4[WRITE_ATOM] = writeAtom, _ref4[FLUSH_PENDING] = flushPending, _ref4[SUBSCRIBE_ATOM] = subscribeAtom, _ref4[RESTORE_ATOMS] = restoreAtoms, _ref4;\n};\n\nvar createScopeContainerForProduction = function createScopeContainerForProduction(initialValues) {\n  var store = createStore(initialValues);\n  return [store];\n};\n\nvar createScopeContainerForDevelopment = function createScopeContainerForDevelopment(initialValues) {\n  var devStore = {\n    listeners: new Set(),\n    subscribe: function subscribe(callback) {\n      devStore.listeners.add(callback);\n      return function () {\n        devStore.listeners.delete(callback);\n      };\n    },\n    atoms: Array.from(initialValues != null ? initialValues : []).map(function (_ref) {\n      var a = _ref[0];\n      return a;\n    })\n  };\n\n  var stateListener = function stateListener(updatedAtom, isNewAtom) {\n    if (isNewAtom) {\n      devStore.atoms = [].concat(devStore.atoms, [updatedAtom]);\n    }\n\n    Promise.resolve().then(function () {\n      devStore.listeners.forEach(function (listener) {\n        return listener();\n      });\n    });\n  };\n\n  var store = createStore(initialValues, stateListener);\n  return [store, devStore];\n};\n\nvar isDevScopeContainer = function isDevScopeContainer(scopeContainer) {\n  return scopeContainer.length > 1;\n};\nvar createScopeContainer = typeof process === 'object' && process.env.NODE_ENV !== 'production' ? createScopeContainerForDevelopment : createScopeContainerForProduction;\nvar ScopeContextMap = new Map();\nvar getScopeContext = function getScopeContext(scope) {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, react.createContext(createScopeContainer()));\n  }\n\n  return ScopeContextMap.get(scope);\n};\n\nvar Provider = function Provider(_ref) {\n  var initialValues = _ref.initialValues,\n      scope = _ref.scope,\n      children = _ref.children;\n  var scopeContainerRef = react.useRef();\n\n  if (!scopeContainerRef.current) {\n    scopeContainerRef.current = createScopeContainer(initialValues);\n  }\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test' && isDevScopeContainer(scopeContainerRef.current)) {\n    useDebugState(scopeContainerRef.current);\n  }\n\n  var ScopeContainerContext = getScopeContext(scope);\n  return react.createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\n\nvar atomToPrintable = function atomToPrintable(atom) {\n  return atom.debugLabel || atom.toString();\n};\n\nvar stateToPrintable = function stateToPrintable(_ref2) {\n  var store = _ref2[0],\n      atoms = _ref2[1];\n  return Object.fromEntries(atoms.flatMap(function (atom) {\n    var _store$DEV_GET_MOUNTE, _store$DEV_GET_ATOM_S;\n\n    var mounted = (_store$DEV_GET_MOUNTE = store[DEV_GET_MOUNTED]) == null ? void 0 : _store$DEV_GET_MOUNTE.call(store, atom);\n\n    if (!mounted) {\n      return [];\n    }\n\n    var dependents = mounted.d;\n    var atomState = ((_store$DEV_GET_ATOM_S = store[DEV_GET_ATOM_STATE]) == null ? void 0 : _store$DEV_GET_ATOM_S.call(store, atom)) || {};\n    return [[atomToPrintable(atom), {\n      value: atomState.e || atomState.p || atomState.w || atomState.v,\n      dependents: Array.from(dependents).map(atomToPrintable)\n    }]];\n  }));\n};\n\nvar useDebugState = function useDebugState(scopeContainer) {\n  var store = scopeContainer[0],\n      devStore = scopeContainer[1];\n\n  var _useState = react.useState(devStore.atoms),\n      atoms = _useState[0],\n      setAtoms = _useState[1];\n\n  react.useEffect(function () {\n    var callback = function callback() {\n      return setAtoms([].concat(devStore.atoms));\n    };\n\n    var unsubscribe = devStore.subscribe(callback);\n    callback();\n    return unsubscribe;\n  }, [devStore]);\n  react.useDebugValue([store, atoms], stateToPrintable);\n};\n\nvar keyCount = 0;\nfunction atom(read, write) {\n  var key = \"atom\" + ++keyCount;\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n\n    config.read = function (get) {\n      return get(config);\n    };\n\n    config.write = function (get, set, update) {\n      set(config, typeof update === 'function' ? update(get(config)) : update);\n    };\n  }\n\n  if (write) {\n    config.write = write;\n  }\n\n  return config;\n}\n\nvar isWritable = function isWritable(atom) {\n  return !!atom.write;\n};\n\nfunction useAtom(atom, scope) {\n  if ('scope' in atom) {\n    console.warn('atom.scope is deprecated. Please do useAtom(atom, scope) instead.');\n    scope = atom.scope;\n  }\n\n  var ScopeContext = getScopeContext(scope);\n\n  var _useContext = react.useContext(ScopeContext),\n      store = _useContext[0];\n\n  var getAtomValue = react.useCallback(function () {\n    var atomState = store[READ_ATOM](atom);\n\n    if (atomState.e) {\n      throw atomState.e;\n    }\n\n    if (atomState.p) {\n      throw atomState.p;\n    }\n\n    if (atomState.w) {\n      throw atomState.w;\n    }\n\n    if ('v' in atomState) {\n      return atomState.v;\n    }\n\n    throw new Error('no atom value');\n  }, [store, atom]);\n\n  var _useReducer = react.useReducer(getAtomValue, undefined, getAtomValue),\n      value = _useReducer[0],\n      forceUpdate = _useReducer[1];\n\n  react.useEffect(function () {\n    var unsubscribe = store[SUBSCRIBE_ATOM](atom, forceUpdate);\n    forceUpdate();\n    return unsubscribe;\n  }, [store, atom]);\n  react.useEffect(function () {\n    store[FLUSH_PENDING]();\n  });\n  var setAtom = react.useCallback(function (update) {\n    if (isWritable(atom)) {\n      return store[WRITE_ATOM](atom, update);\n    } else {\n      throw new Error('not writable atom');\n    }\n  }, [store, atom]);\n  react.useDebugValue(value);\n  return [value, setAtom];\n}\n\nexports.Provider = Provider;\nexports.SECRET_INTERNAL_getScopeContext = getScopeContext;\nexports.atom = atom;\nexports.useAtom = useAtom;\n"]},"metadata":{},"sourceType":"script"}
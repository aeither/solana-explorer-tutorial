{"ast":null,"code":"import { __assign } from 'tslib';\nimport { complex, px } from 'style-value-types';\nimport { mix } from 'popmotion';\nimport { cssVariableRegex } from '../utils/css-variables-conversion.js';\n\nfunction pixelsToPercent(pixels, axis) {\n  return pixels / (axis.max - axis.min) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\n\n\nfunction correctBorderRadius(latest, _layoutState, _a) {\n  var target = _a.target;\n  /**\n   * If latest is a string, if it's a percentage we can return immediately as it's\n   * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n   */\n\n  if (typeof latest === \"string\") {\n    if (px.test(latest)) {\n      latest = parseFloat(latest);\n    } else {\n      return latest;\n    }\n  }\n  /**\n   * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n   * pixel value as a percentage of each axis\n   */\n\n\n  var x = pixelsToPercent(latest, target.x);\n  var y = pixelsToPercent(latest, target.y);\n  return x + \"% \" + y + \"%\";\n}\n\nvar varToken = \"_$css\";\n\nfunction correctBoxShadow(latest, _a) {\n  var delta = _a.delta,\n      treeScale = _a.treeScale;\n  var original = latest;\n  /**\n   * We need to first strip and store CSS variables from the string.\n   */\n\n  var containsCSSVariables = latest.includes(\"var(\");\n  var cssVariables = [];\n\n  if (containsCSSVariables) {\n    latest = latest.replace(cssVariableRegex, function (match) {\n      cssVariables.push(match);\n      return varToken;\n    });\n  }\n\n  var shadow = complex.parse(latest); // TODO: Doesn't support multiple shadows\n\n  if (shadow.length > 5) return original;\n  var template = complex.createTransformer(latest);\n  var offset = typeof shadow[0] !== \"number\" ? 1 : 0; // Calculate the overall context scale\n\n  var xScale = delta.x.scale * treeScale.x;\n  var yScale = delta.y.scale * treeScale.y;\n  shadow[0 + offset] /= xScale;\n  shadow[1 + offset] /= yScale;\n  /**\n   * Ideally we'd correct x and y scales individually, but because blur and\n   * spread apply to both we have to take a scale average and apply that instead.\n   * We could potentially improve the outcome of this by incorporating the ratio between\n   * the two scales.\n   */\n\n  var averageScale = mix(xScale, yScale, 0.5); // Blur\n\n  if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale; // Spread\n\n  if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n  var output = template(shadow);\n\n  if (containsCSSVariables) {\n    var i_1 = 0;\n    output = output.replace(varToken, function () {\n      var cssVariable = cssVariables[i_1];\n      i_1++;\n      return cssVariable;\n    });\n  }\n\n  return output;\n}\n\nvar borderCorrectionDefinition = {\n  process: correctBorderRadius\n};\nvar defaultScaleCorrectors = {\n  borderRadius: __assign(__assign({}, borderCorrectionDefinition), {\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  }),\n  borderTopLeftRadius: borderCorrectionDefinition,\n  borderTopRightRadius: borderCorrectionDefinition,\n  borderBottomLeftRadius: borderCorrectionDefinition,\n  borderBottomRightRadius: borderCorrectionDefinition,\n  boxShadow: {\n    process: correctBoxShadow\n  }\n};\nexport { correctBorderRadius, correctBoxShadow, defaultScaleCorrectors, pixelsToPercent };","map":{"version":3,"sources":["/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/framer-motion/dist/es/render/dom/projection/default-scale-correctors.js"],"names":["__assign","complex","px","mix","cssVariableRegex","pixelsToPercent","pixels","axis","max","min","correctBorderRadius","latest","_layoutState","_a","target","test","parseFloat","x","y","varToken","correctBoxShadow","delta","treeScale","original","containsCSSVariables","includes","cssVariables","replace","match","push","shadow","parse","length","template","createTransformer","offset","xScale","scale","yScale","averageScale","output","i_1","cssVariable","borderCorrectionDefinition","process","defaultScaleCorrectors","borderRadius","applyTo","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","boxShadow"],"mappings":"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","sourcesContent":["import { __assign } from 'tslib';\nimport { complex, px } from 'style-value-types';\nimport { mix } from 'popmotion';\nimport { cssVariableRegex } from '../utils/css-variables-conversion.js';\n\nfunction pixelsToPercent(pixels, axis) {\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nfunction correctBorderRadius(latest, _layoutState, _a) {\n    var target = _a.target;\n    /**\n     * If latest is a string, if it's a percentage we can return immediately as it's\n     * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n     */\n    if (typeof latest === \"string\") {\n        if (px.test(latest)) {\n            latest = parseFloat(latest);\n        }\n        else {\n            return latest;\n        }\n    }\n    /**\n     * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n     * pixel value as a percentage of each axis\n     */\n    var x = pixelsToPercent(latest, target.x);\n    var y = pixelsToPercent(latest, target.y);\n    return x + \"% \" + y + \"%\";\n}\nvar varToken = \"_$css\";\nfunction correctBoxShadow(latest, _a) {\n    var delta = _a.delta, treeScale = _a.treeScale;\n    var original = latest;\n    /**\n     * We need to first strip and store CSS variables from the string.\n     */\n    var containsCSSVariables = latest.includes(\"var(\");\n    var cssVariables = [];\n    if (containsCSSVariables) {\n        latest = latest.replace(cssVariableRegex, function (match) {\n            cssVariables.push(match);\n            return varToken;\n        });\n    }\n    var shadow = complex.parse(latest);\n    // TODO: Doesn't support multiple shadows\n    if (shadow.length > 5)\n        return original;\n    var template = complex.createTransformer(latest);\n    var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n    // Calculate the overall context scale\n    var xScale = delta.x.scale * treeScale.x;\n    var yScale = delta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    /**\n     * Ideally we'd correct x and y scales individually, but because blur and\n     * spread apply to both we have to take a scale average and apply that instead.\n     * We could potentially improve the outcome of this by incorporating the ratio between\n     * the two scales.\n     */\n    var averageScale = mix(xScale, yScale, 0.5);\n    // Blur\n    if (typeof shadow[2 + offset] === \"number\")\n        shadow[2 + offset] /= averageScale;\n    // Spread\n    if (typeof shadow[3 + offset] === \"number\")\n        shadow[3 + offset] /= averageScale;\n    var output = template(shadow);\n    if (containsCSSVariables) {\n        var i_1 = 0;\n        output = output.replace(varToken, function () {\n            var cssVariable = cssVariables[i_1];\n            i_1++;\n            return cssVariable;\n        });\n    }\n    return output;\n}\nvar borderCorrectionDefinition = {\n    process: correctBorderRadius,\n};\nvar defaultScaleCorrectors = {\n    borderRadius: __assign(__assign({}, borderCorrectionDefinition), { applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ] }),\n    borderTopLeftRadius: borderCorrectionDefinition,\n    borderTopRightRadius: borderCorrectionDefinition,\n    borderBottomLeftRadius: borderCorrectionDefinition,\n    borderBottomRightRadius: borderCorrectionDefinition,\n    boxShadow: {\n        process: correctBoxShadow,\n    },\n};\n\nexport { correctBorderRadius, correctBoxShadow, defaultScaleCorrectors, pixelsToPercent };\n"]},"metadata":{},"sourceType":"module"}
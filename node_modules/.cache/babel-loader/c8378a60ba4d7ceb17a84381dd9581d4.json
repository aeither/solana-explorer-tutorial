{"ast":null,"code":"import _toConsumableArray from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nexport function getFirstItem(array) {\n  return array != null && array.length ? array[0] : undefined;\n}\nexport function getLastItem(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\nexport function getPrevItem(index, array, loop) {\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  var prevIndex = getPrevIndex(index, array.length, loop);\n  return array[prevIndex];\n}\nexport function getNextItem(index, array, loop) {\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  var nextIndex = getNextIndex(index, array.length, 1, loop);\n  return array[nextIndex];\n}\nexport function removeIndex(array, index) {\n  return array.filter(function (_, idx) {\n    return idx !== index;\n  });\n}\nexport function addItem(array, item) {\n  return [].concat(_toConsumableArray(array), [item]);\n}\nexport function removeItem(array, item) {\n  return array.filter(function (eachItem) {\n    return eachItem !== item;\n  });\n}\n/**\n * Get the next index based on the current index and step.\n *\n * @param currentIndex the current index\n * @param length the total length or count of items\n * @param step the number of steps\n * @param loop whether to circle back once `currentIndex` is at the start/end\n */\n\nexport function getNextIndex(currentIndex, length, step, loop) {\n  if (step === void 0) {\n    step = 1;\n  }\n\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  var lastIndex = length - 1;\n\n  if (currentIndex === -1) {\n    return step > 0 ? 0 : lastIndex;\n  }\n\n  var nextIndex = currentIndex + step;\n\n  if (nextIndex < 0) {\n    return loop ? lastIndex : 0;\n  }\n\n  if (nextIndex >= length) {\n    if (loop) return 0;\n    return currentIndex > length ? length : currentIndex;\n  }\n\n  return nextIndex;\n}\n/**\n * Get's the previous index based on the current index.\n * Mostly used for keyboard navigation.\n *\n * @param index - the current index\n * @param count - the length or total count of items in the array\n * @param loop - whether we should circle back to the\n * first/last once `currentIndex` is at the start/end\n */\n\nexport function getPrevIndex(index, count, loop) {\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  return getNextIndex(index, count, -1, loop);\n}\n/**\n * Converts an array into smaller chunks or groups.\n *\n * @param array the array to chunk into group\n * @param size the length of each chunk\n */\n\nexport function chunk(array, size) {\n  return array.reduce(function (rows, currentValue, index) {\n    if (index % size === 0) {\n      rows.push([currentValue]);\n    } else {\n      rows[rows.length - 1].push(currentValue);\n    }\n\n    return rows;\n  }, []);\n}\n/**\n * Gets the next item based on a search string\n *\n * @param items array of items\n * @param searchString the search string\n * @param itemToString resolves an item to string\n * @param currentItem the current selected item\n */\n\nexport function getNextItemFromSearch(items, searchString, itemToString, currentItem) {\n  if (searchString == null) {\n    return currentItem;\n  } // If current item doesn't exist, find the item that matches the search string\n\n\n  if (!currentItem) {\n    var foundItem = items.find(function (item) {\n      return itemToString(item).toLowerCase().startsWith(searchString.toLowerCase());\n    });\n    return foundItem;\n  } // Filter items for ones that match the search string (case insensitive)\n\n\n  var matchingItems = items.filter(function (item) {\n    return itemToString(item).toLowerCase().startsWith(searchString.toLowerCase());\n  }); // If there's a match, let's get the next item to select\n\n  if (matchingItems.length > 0) {\n    var nextIndex; // If the currentItem is in the available items, we move to the next available option\n\n    if (matchingItems.includes(currentItem)) {\n      var currentIndex = matchingItems.indexOf(currentItem);\n      nextIndex = currentIndex + 1;\n\n      if (nextIndex === matchingItems.length) {\n        nextIndex = 0;\n      }\n\n      return matchingItems[nextIndex];\n    } // Else, we pick the first item in the available items\n\n\n    nextIndex = items.indexOf(matchingItems[0]);\n    return items[nextIndex];\n  } // a decent fallback to the currentItem\n\n\n  return currentItem;\n}","map":{"version":3,"sources":["../../src/array.ts"],"names":["array","length","loop","prevIndex","getPrevIndex","nextIndex","getNextIndex","idx","eachItem","step","lastIndex","currentIndex","index","rows","searchString","foundItem","items","item","itemToString","matchingItems"],"mappings":"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","sourcesContent":["export function getFirstItem<T>(array: T[]): T | undefined {\n  return array != null && array.length ? array[0] : undefined\n}\n\nexport function getLastItem<T>(array: T[]): T | undefined {\n  const length = array == null ? 0 : array.length\n  return length ? array[length - 1] : undefined\n}\n\nexport function getPrevItem<T>(index: number, array: T[], loop = true): T {\n  const prevIndex = getPrevIndex(index, array.length, loop)\n  return array[prevIndex]\n}\n\nexport function getNextItem<T>(index: number, array: T[], loop = true): T {\n  const nextIndex = getNextIndex(index, array.length, 1, loop)\n  return array[nextIndex]\n}\n\nexport function removeIndex<T>(array: T[], index: number): T[] {\n  return array.filter((_, idx) => idx !== index)\n}\n\nexport function addItem<T>(array: T[], item: T): T[] {\n  return [...array, item]\n}\n\nexport function removeItem<T>(array: T[], item: T): T[] {\n  return array.filter((eachItem) => eachItem !== item)\n}\n\n/**\n * Get the next index based on the current index and step.\n *\n * @param currentIndex the current index\n * @param length the total length or count of items\n * @param step the number of steps\n * @param loop whether to circle back once `currentIndex` is at the start/end\n */\nexport function getNextIndex(\n  currentIndex: number,\n  length: number,\n  step = 1,\n  loop = true,\n): number {\n  const lastIndex = length - 1\n\n  if (currentIndex === -1) {\n    return step > 0 ? 0 : lastIndex\n  }\n\n  const nextIndex = currentIndex + step\n\n  if (nextIndex < 0) {\n    return loop ? lastIndex : 0\n  }\n\n  if (nextIndex >= length) {\n    if (loop) return 0\n    return currentIndex > length ? length : currentIndex\n  }\n\n  return nextIndex\n}\n\n/**\n * Get's the previous index based on the current index.\n * Mostly used for keyboard navigation.\n *\n * @param index - the current index\n * @param count - the length or total count of items in the array\n * @param loop - whether we should circle back to the\n * first/last once `currentIndex` is at the start/end\n */\nexport function getPrevIndex(\n  index: number,\n  count: number,\n  loop = true,\n): number {\n  return getNextIndex(index, count, -1, loop)\n}\n\n/**\n * Converts an array into smaller chunks or groups.\n *\n * @param array the array to chunk into group\n * @param size the length of each chunk\n */\nexport function chunk<T>(array: T[], size: number): T[][] {\n  return array.reduce((rows: T[][], currentValue: T, index: number) => {\n    if (index % size === 0) {\n      rows.push([currentValue])\n    } else {\n      rows[rows.length - 1].push(currentValue)\n    }\n    return rows\n  }, [] as T[][])\n}\n\n/**\n * Gets the next item based on a search string\n *\n * @param items array of items\n * @param searchString the search string\n * @param itemToString resolves an item to string\n * @param currentItem the current selected item\n */\nexport function getNextItemFromSearch<T>(\n  items: T[],\n  searchString: string,\n  itemToString: (item: T) => string,\n  currentItem: T,\n): T | undefined {\n  if (searchString == null) {\n    return currentItem\n  }\n\n  // If current item doesn't exist, find the item that matches the search string\n  if (!currentItem) {\n    const foundItem = items.find((item) =>\n      itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()),\n    )\n    return foundItem\n  }\n\n  // Filter items for ones that match the search string (case insensitive)\n  const matchingItems = items.filter((item) =>\n    itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()),\n  )\n\n  // If there's a match, let's get the next item to select\n  if (matchingItems.length > 0) {\n    let nextIndex: number\n\n    // If the currentItem is in the available items, we move to the next available option\n    if (matchingItems.includes(currentItem)) {\n      const currentIndex = matchingItems.indexOf(currentItem)\n      nextIndex = currentIndex + 1\n      if (nextIndex === matchingItems.length) {\n        nextIndex = 0\n      }\n      return matchingItems[nextIndex]\n    }\n    // Else, we pick the first item in the available items\n    nextIndex = items.indexOf(matchingItems[0])\n    return items[nextIndex]\n  }\n\n  // a decent fallback to the currentItem\n  return currentItem\n}\n"]},"metadata":{},"sourceType":"module"}
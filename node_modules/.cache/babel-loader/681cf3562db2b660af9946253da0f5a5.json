{"ast":null,"code":"import _slicedToArray from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { useCallbackRef, useControllableProp } from \"@chakra-ui/hooks\";\nimport { clampValue, countDecimalPlaces, maxSafeInteger, minSafeInteger, toPrecision } from \"@chakra-ui/utils\";\nimport { useCallback, useState } from \"react\";\nexport function useCounter(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var _props = props,\n      onChange = _props.onChange,\n      precisionProp = _props.precision,\n      defaultValue = _props.defaultValue,\n      valueProp = _props.value,\n      _props$step = _props.step,\n      stepProp = _props$step === void 0 ? 1 : _props$step,\n      _props$min = _props.min,\n      min = _props$min === void 0 ? minSafeInteger : _props$min,\n      _props$max = _props.max,\n      max = _props$max === void 0 ? maxSafeInteger : _props$max,\n      _props$keepWithinRang = _props.keepWithinRange,\n      keepWithinRange = _props$keepWithinRang === void 0 ? true : _props$keepWithinRang;\n  var onChangeProp = useCallbackRef(onChange);\n\n  var _useState = useState(function () {\n    var _cast;\n\n    if (defaultValue == null) return \"\";\n    return (_cast = cast(defaultValue, stepProp, precisionProp)) != null ? _cast : \"\";\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      valueState = _useState2[0],\n      setValue = _useState2[1];\n  /**\n   * Because the component that consumes this hook can be controlled or uncontrolled\n   * we'll keep track of that\n   */\n\n\n  var _useControllableProp = useControllableProp(valueProp, valueState),\n      _useControllableProp2 = _slicedToArray(_useControllableProp, 2),\n      isControlled = _useControllableProp2[0],\n      value = _useControllableProp2[1];\n\n  var decimalPlaces = getDecimalPlaces(parse(value), stepProp);\n  var precision = precisionProp != null ? precisionProp : decimalPlaces;\n  var update = useCallback(function (next) {\n    if (next === value) return;\n\n    if (!isControlled) {\n      setValue(next.toString());\n    }\n\n    onChangeProp == null ? void 0 : onChangeProp(next.toString(), parse(next));\n  }, [onChangeProp, isControlled, value]); // Function to clamp the value and round it to the precision\n\n  var clamp = useCallback(function (value) {\n    var nextValue = value;\n\n    if (keepWithinRange) {\n      nextValue = clampValue(nextValue, min, max);\n    }\n\n    return toPrecision(nextValue, precision);\n  }, [precision, keepWithinRange, max, min]);\n  var increment = useCallback(function (step) {\n    if (step === void 0) {\n      step = stepProp;\n    }\n\n    var next;\n    /**\n     * Let's follow the native browser behavior for\n     * scenarios where the input starts empty (\"\")\n     */\n\n    if (value === \"\") {\n      /**\n       * If `min` is set, native input, starts at the `min`.\n       * Else, it starts at `step`\n       */\n      next = parse(step);\n    } else {\n      next = parse(value) + step;\n    }\n\n    next = clamp(next);\n    update(next);\n  }, [clamp, stepProp, update, value]);\n  var decrement = useCallback(function (step) {\n    if (step === void 0) {\n      step = stepProp;\n    }\n\n    var next; // Same thing here. We'll follow native implementation\n\n    if (value === \"\") {\n      next = parse(-step);\n    } else {\n      next = parse(value) - step;\n    }\n\n    next = clamp(next);\n    update(next);\n  }, [clamp, stepProp, update, value]);\n  var reset = useCallback(function () {\n    var next;\n\n    if (defaultValue == null) {\n      next = \"\";\n    } else {\n      var _cast2;\n\n      next = (_cast2 = cast(defaultValue, stepProp, precisionProp)) != null ? _cast2 : min;\n    }\n\n    update(next);\n  }, [defaultValue, precisionProp, stepProp, update, min]);\n  var castValue = useCallback(function (value) {\n    var _cast3;\n\n    var nextValue = (_cast3 = cast(value, stepProp, precision)) != null ? _cast3 : min;\n    update(nextValue);\n  }, [precision, stepProp, update, min]);\n  var valueAsNumber = parse(value);\n  /**\n   * Common range checks\n   */\n\n  var isOutOfRange = valueAsNumber > max || valueAsNumber < min;\n  var isAtMax = valueAsNumber === max;\n  var isAtMin = valueAsNumber === min;\n  return {\n    isOutOfRange: isOutOfRange,\n    isAtMax: isAtMax,\n    isAtMin: isAtMin,\n    precision: precision,\n    value: value,\n    valueAsNumber: valueAsNumber,\n    update: update,\n    reset: reset,\n    increment: increment,\n    decrement: decrement,\n    clamp: clamp,\n    cast: castValue,\n    setValue: setValue\n  };\n}\n\nfunction parse(value) {\n  return parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"));\n}\n\nfunction getDecimalPlaces(value, step) {\n  return Math.max(countDecimalPlaces(step), countDecimalPlaces(value));\n}\n\nfunction cast(value, step, precision) {\n  var parsedValue = parse(value);\n  if (Number.isNaN(parsedValue)) return undefined;\n  var decimalPlaces = getDecimalPlaces(parsedValue, step);\n  return toPrecision(parsedValue, precision != null ? precision : decimalPlaces);\n}","map":{"version":3,"sources":["../../src/use-counter.ts"],"names":["props","precision","value","step","stepProp","min","max","keepWithinRange","onChangeProp","useCallbackRef","useState","defaultValue","cast","useControllableProp","decimalPlaces","getDecimalPlaces","parse","precisionProp","update","useCallback","next","setValue","clamp","nextValue","clampValue","toPrecision","increment","decrement","reset","castValue","valueAsNumber","isOutOfRange","isAtMax","isAtMin","parseFloat","Math","countDecimalPlaces","parsedValue","Number"],"mappings":"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","sourcesContent":["import { useCallbackRef, useControllableProp } from \"@chakra-ui/hooks\"\nimport {\n  clampValue,\n  countDecimalPlaces,\n  maxSafeInteger,\n  minSafeInteger,\n  StringOrNumber,\n  toPrecision,\n} from \"@chakra-ui/utils\"\nimport { useCallback, useState } from \"react\"\n\nexport interface UseCounterProps {\n  /**\n   * The callback fired when the value changes\n   */\n  onChange?(valueAsString: string, valueAsNumber: number): void\n  /**\n   * The number of decimal points used to round the value\n   */\n  precision?: number\n  /**\n   * The initial value of the counter. Should be less than `max` and greater than `min`\n   */\n  defaultValue?: StringOrNumber\n  /**\n   * The value of the counter. Should be less than `max` and greater than `min`\n   */\n  value?: StringOrNumber\n  /**\n   * The step used to increment or decrement the value\n   * @default 1\n   */\n  step?: number\n  /**\n   * The minimum value of the counter\n   * @default -Infinity\n   */\n  min?: number\n  /**\n   * The maximum value of the counter\n   * @default Infinity\n   */\n  max?: number\n  /**\n   * This controls the value update behavior in general.\n   *\n   * - If `true` and you use the stepper or up/down arrow keys,\n   *  the value will not exceed the `max` or go lower than `min`\n   *\n   * - If `false`, the value will be allowed to go out of range.\n   *\n   * @default true\n   */\n  keepWithinRange?: boolean\n}\n\nexport function useCounter(props: UseCounterProps = {}) {\n  const {\n    onChange,\n    precision: precisionProp,\n    defaultValue,\n    value: valueProp,\n    step: stepProp = 1,\n    min = minSafeInteger,\n    max = maxSafeInteger,\n    keepWithinRange = true,\n  } = props\n\n  const onChangeProp = useCallbackRef(onChange)\n\n  const [valueState, setValue] = useState<StringOrNumber>(() => {\n    if (defaultValue == null) return \"\"\n    return cast(defaultValue, stepProp, precisionProp) ?? \"\"\n  })\n\n  /**\n   * Because the component that consumes this hook can be controlled or uncontrolled\n   * we'll keep track of that\n   */\n  const [isControlled, value] = useControllableProp(valueProp, valueState)\n\n  const decimalPlaces = getDecimalPlaces(parse(value), stepProp)\n\n  const precision = precisionProp ?? decimalPlaces\n\n  const update = useCallback(\n    (next: StringOrNumber) => {\n      if (next === value) return\n      if (!isControlled) {\n        setValue(next.toString())\n      }\n      onChangeProp?.(next.toString(), parse(next))\n    },\n    [onChangeProp, isControlled, value],\n  )\n\n  // Function to clamp the value and round it to the precision\n  const clamp = useCallback(\n    (value: number) => {\n      let nextValue = value\n\n      if (keepWithinRange) {\n        nextValue = clampValue(nextValue, min, max)\n      }\n\n      return toPrecision(nextValue, precision)\n    },\n    [precision, keepWithinRange, max, min],\n  )\n\n  const increment = useCallback(\n    (step = stepProp) => {\n      let next: StringOrNumber\n\n      /**\n       * Let's follow the native browser behavior for\n       * scenarios where the input starts empty (\"\")\n       */\n      if (value === \"\") {\n        /**\n         * If `min` is set, native input, starts at the `min`.\n         * Else, it starts at `step`\n         */\n        next = parse(step)\n      } else {\n        next = parse(value) + step\n      }\n\n      next = clamp(next as number)\n      update(next)\n    },\n    [clamp, stepProp, update, value],\n  )\n\n  const decrement = useCallback(\n    (step = stepProp) => {\n      let next: StringOrNumber\n\n      // Same thing here. We'll follow native implementation\n      if (value === \"\") {\n        next = parse(-step)\n      } else {\n        next = parse(value) - step\n      }\n\n      next = clamp(next as number)\n      update(next)\n    },\n    [clamp, stepProp, update, value],\n  )\n\n  const reset = useCallback(() => {\n    let next: StringOrNumber\n    if (defaultValue == null) {\n      next = \"\"\n    } else {\n      next = cast(defaultValue, stepProp, precisionProp) ?? min\n    }\n    update(next)\n  }, [defaultValue, precisionProp, stepProp, update, min])\n\n  const castValue = useCallback(\n    (value: StringOrNumber) => {\n      const nextValue = cast(value, stepProp, precision) ?? min\n      update(nextValue)\n    },\n    [precision, stepProp, update, min],\n  )\n\n  const valueAsNumber = parse(value)\n\n  /**\n   * Common range checks\n   */\n  const isOutOfRange = valueAsNumber > max || valueAsNumber < min\n  const isAtMax = valueAsNumber === max\n  const isAtMin = valueAsNumber === min\n\n  return {\n    isOutOfRange,\n    isAtMax,\n    isAtMin,\n    precision,\n    value,\n    valueAsNumber,\n    update,\n    reset,\n    increment,\n    decrement,\n    clamp,\n    cast: castValue,\n    setValue,\n  }\n}\n\nexport type UseCounterReturn = ReturnType<typeof useCounter>\n\nfunction parse(value: StringOrNumber) {\n  return parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"))\n}\n\nfunction getDecimalPlaces(value: number, step: number) {\n  return Math.max(countDecimalPlaces(step), countDecimalPlaces(value))\n}\n\nfunction cast(value: StringOrNumber, step: number, precision?: number) {\n  const parsedValue = parse(value)\n  if (Number.isNaN(parsedValue)) return undefined\n  const decimalPlaces = getDecimalPlaces(parsedValue, step)\n  return toPrecision(parsedValue, precision ?? decimalPlaces)\n}\n"]},"metadata":{},"sourceType":"module"}
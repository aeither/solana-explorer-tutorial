{"ast":null,"code":"import _classCallCheck from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * This is a modified version of `PanSession` from `framer-motion`.\n *\n * Credit goes to `framer-motion` of this useful utilities.\n * License can be found here: https://github.com/framer/motion\n */\n\n\nimport sync, { cancelSync, getFrameData } from \"framesync\";\nimport { isMouseEvent, extractEventInfo, addPointerEvent, isMultiTouchEvent } from \"./pointer-event\";\nimport { pipe, distance, noop } from \"./function\";\n/**\n * The event information passed to pan event handlers like `onPan`, `onPanStart`.\n *\n * It contains information about the current state of the tap gesture such as its\n * `point`, `delta`, and `offset`\n */\n\n/**\n * @internal\n *\n * A Pan Session is recognized when the pointer is down\n * and moved in the allowed direction.\n */\n\nexport var PanSession = /*#__PURE__*/function () {\n  /**\n   * We use this to keep track of the `x` and `y` pan session history\n   * as the pan event happens. It helps to calculate the `offset` and `delta`\n   */\n  // The pointer event that started the pan session\n  // The current pointer event for the pan session\n  // The current pointer event info for the pan session\n\n  /**\n   * Minimal pan distance required before recognizing the pan.\n   * @default \"3px\"\n   */\n  function PanSession(_event, handlers, threshold) {\n    var _this = this;\n\n    _classCallCheck(this, PanSession);\n\n    _defineProperty(this, \"history\", []);\n\n    _defineProperty(this, \"startEvent\", null);\n\n    _defineProperty(this, \"lastEvent\", null);\n\n    _defineProperty(this, \"lastEventInfo\", null);\n\n    _defineProperty(this, \"handlers\", {});\n\n    _defineProperty(this, \"removeListeners\", noop);\n\n    _defineProperty(this, \"threshold\", 3);\n\n    _defineProperty(this, \"updatePoint\", function () {\n      if (!(_this.lastEvent && _this.lastEventInfo)) return;\n      var info = getPanInfo(_this.lastEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null;\n\n      var isDistancePastThreshold = distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= _this.threshold;\n\n      if (!isPanStarted && !isDistancePastThreshold) return;\n\n      var _getFrameData = getFrameData(),\n          timestamp = _getFrameData.timestamp;\n\n      _this.history.push(_extends({}, info.point, {\n        timestamp: timestamp\n      }));\n\n      var _this$handlers = _this.handlers,\n          onStart = _this$handlers.onStart,\n          onMove = _this$handlers.onMove;\n\n      if (!isPanStarted) {\n        onStart == null ? void 0 : onStart(_this.lastEvent, info);\n        _this.startEvent = _this.lastEvent;\n      }\n\n      onMove == null ? void 0 : onMove(_this.lastEvent, info);\n    });\n\n    _defineProperty(this, \"onPointerMove\", function (event, info) {\n      _this.lastEvent = event;\n      _this.lastEventInfo = info; // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n\n      if (isMouseEvent(event) && event.buttons === 0) {\n        _this.onPointerUp(event, info);\n\n        return;\n      } // Throttle mouse move event to once per frame\n\n\n      sync.update(_this.updatePoint, true);\n    });\n\n    _defineProperty(this, \"onPointerUp\", function (event, info) {\n      // notify pan session ended\n      var panInfo = getPanInfo(info, _this.history);\n      var _this$handlers2 = _this.handlers,\n          onEnd = _this$handlers2.onEnd,\n          onSessionEnd = _this$handlers2.onSessionEnd;\n      onSessionEnd == null ? void 0 : onSessionEnd(event, panInfo);\n\n      _this.end(); // if panning never started, no need to call `onEnd`\n      // panning requires a pointermove of at least 3px\n\n\n      if (!onEnd || !_this.startEvent) return;\n      onEnd == null ? void 0 : onEnd(event, panInfo);\n    }); // If we have more than one touch, don't start detecting this gesture\n\n\n    if (isMultiTouchEvent(_event)) return;\n    this.handlers = handlers;\n\n    if (threshold) {\n      this.threshold = threshold;\n    } // stop default browser behavior\n\n\n    _event.stopPropagation();\n\n    _event.preventDefault(); // get and save the `pointerdown` event info in history\n    // we'll use it to compute the `offset`\n\n\n    var _info = extractEventInfo(_event);\n\n    var _getFrameData2 = getFrameData(),\n        _timestamp = _getFrameData2.timestamp;\n\n    this.history = [_extends({}, _info.point, {\n      timestamp: _timestamp\n    })]; // notify pan session start\n\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart == null ? void 0 : onSessionStart(_event, getPanInfo(_info, this.history)); // attach event listeners and return a single function to remove them all\n\n    this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.onPointerMove), addPointerEvent(window, \"pointerup\", this.onPointerUp), addPointerEvent(window, \"pointercancel\", this.onPointerUp));\n  }\n\n  _createClass(PanSession, [{\n    key: \"updateHandlers\",\n    value: function updateHandlers(handlers) {\n      this.handlers = handlers;\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      var _this$removeListeners;\n\n      (_this$removeListeners = this.removeListeners) == null ? void 0 : _this$removeListeners.call(this);\n      cancelSync.update(this.updatePoint);\n    }\n  }]);\n\n  return PanSession;\n}();\n\nfunction subtractPoint(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\n\nfunction startPanPoint(history) {\n  return history[0];\n}\n\nfunction lastPanPoint(history) {\n  return history[history.length - 1];\n}\n\nfunction getPanInfo(info, history) {\n  return {\n    point: info.point,\n    delta: subtractPoint(info.point, lastPanPoint(history)),\n    offset: subtractPoint(info.point, startPanPoint(history)),\n    velocity: getVelocity(history, 0.1)\n  };\n}\n\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\n\nvar toMilliseconds = function toMilliseconds(seconds) {\n  return seconds * 1000;\n};\n\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = lastDevicePoint(history);\n\n  while (i >= 0) {\n    timestampedPoint = history[i];\n\n    if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {\n      break;\n    }\n\n    i--;\n  }\n\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n\n  return currentVelocity;\n}","map":{"version":3,"sources":["../../src/pan-event.ts"],"names":["noop","constructor","isMultiTouchEvent","event","info","extractEventInfo","timestamp","getFrameData","onSessionStart","getPanInfo","pipe","addPointerEvent","isPanStarted","isDistancePastThreshold","x","y","onMove","onStart","isMouseEvent","sync","panInfo","onSessionEnd","onEnd","updateHandlers","end","cancelSync","a","b","history","point","delta","subtractPoint","lastPanPoint","offset","startPanPoint","velocity","getVelocity","toMilliseconds","seconds","i","timestampedPoint","lastPoint","lastDevicePoint","time","currentVelocity"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAEA,OAAA,IAAA,IAAA,UAAA,EAAA,YAAA,QAAA,WAAA;AACA,SAAA,YAAA,EAAA,gBAAA,EAAA,eAAA,EAAA,iBAAA,QAAA,iBAAA;AASA,SAAA,IAAA,EAAA,QAAA,EAAA,IAAA,QAAA,YAAA;AAEA;AACA;AACA;AACA;AACA;AACA;;AA8DA;AACA;AACA;AACA;AACA;AACA;;AACA,WAAO,UAAP;AACE;AACF;AACA;AACA;AAGE;AAGA;AAGA;;AAOA;AACF;AACA;AACA;AAGEC,sBAAW,MAAXA,EAAW,QAAXA,EAAW,SAAXA,EAIE;AAAA;;AAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,SAAA,EAzBmC,EAyBnC,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,YAAA,EAtB2C,IAsB3C,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,WAAA,EAnB0C,IAmB1C,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,eAAA,EAhB+C,IAgB/C,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,UAAA,EAd8C,EAc9C,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,iBAAA,EAZkCD,IAYlC,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,WAAA,EANkB,CAMlB,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,aAAA,EAgCoB,YAAM;AAC1B,UAAI,EAAE,KAAA,CAAA,SAAA,IAAkB,KAAA,CAAxB,aAAI,CAAJ,EAA6C;AAE7C,UAAMI,IAAI,GAAGK,UAAU,CAAC,KAAA,CAAD,aAAA,EAAqB,KAAA,CAA5C,OAAuB,CAAvB;AAEA,UAAMG,YAAY,GAAG,KAAA,CAAA,UAAA,KAArB,IAAA;;AAEA,UAAMC,uBAAuB,GAC3B,QAAQ,CAACT,IAAI,CAAL,MAAA,EAAc;AAAEU,QAAAA,CAAC,EAAH,CAAA;AAAQC,QAAAA,CAAC,EAAE;AAAX,OAAd,CAAR,IAAyC,KAAA,CAD3C,SAAA;;AAGA,UAAI,CAAA,YAAA,IAAiB,CAArB,uBAAA,EAA+C;;AAE/C,0BAAsBR,YAAtB,EAAA;AAAA,UAAQD,SAAR,iBAAQA,SAAR;;AACA,MAAA,KAAA,CAAA,OAAA,CAAA,IAAA,CAAA,QAAA,CAAA,EAAA,EAAuBF,IAAI,CAA3B,KAAA,EAAA;AAAmCE,QAAAA,SAAAA,EAAAA;AAAnC,OAAA,CAAA;;AAEA,2BAA4B,KAAA,CAA5B,QAAA;AAAA,UAAM,OAAN,kBAAM,OAAN;AAAA,UAAiBU,MAAjB,kBAAiBA,MAAjB;;AAEA,UAAI,CAAJ,YAAA,EAAmB;AACjBC,QAAAA,OAAO,IAAPA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,OAAO,CAAG,KAAA,CAAH,SAAA,EAAPA,IAAO,CAAPA;AACA,QAAA,KAAA,CAAA,UAAA,GAAkB,KAAA,CAAlB,SAAA;AACD;;AAEDD,MAAAA,MAAM,IAANA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,MAAM,CAAG,KAAA,CAAH,SAAA,EAANA,IAAM,CAANA;AAtDA,KAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,eAAA,EAyDsB,UAAA,KAAA,EAAA,IAAA,EAAoD;AAC1E,MAAA,KAAA,CAAA,SAAA,GAAA,KAAA;AACA,MAAA,KAAA,CAAA,aAAA,GAF0E,IAE1E,CAF0E,CAI1E;;AACA,UAAIE,YAAY,CAAZA,KAAY,CAAZA,IAAuBf,KAAK,CAALA,OAAAA,KAA3B,CAAA,EAAgD;AAC9C,QAAA,KAAA,CAAA,WAAA,CAAA,KAAA,EAAA,IAAA;;AACA;AAPwE,OAAA,CAU1E;;;AACAgB,MAAAA,IAAI,CAAJA,MAAAA,CAAY,KAAA,CAAZA,WAAAA,EAAAA,IAAAA;AApEA,KAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,aAAA,EAuEoB,UAAA,KAAA,EAAA,IAAA,EAAoD;AACxE;AACA,UAAMC,OAAO,GAAGX,UAAU,CAAA,IAAA,EAAO,KAAA,CAAjC,OAA0B,CAA1B;AACA,4BAAgC,KAAA,CAAhC,QAAA;AAAA,UAAM,KAAN,mBAAM,KAAN;AAAA,UAAeY,YAAf,mBAAeA,YAAf;AAEAA,MAAAA,YAAY,IAAZA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,YAAY,CAAA,KAAA,EAAZA,OAAY,CAAZA;;AACA,MAAA,KAAA,CANwE,GAMxE,GANwE,CAQxE;AACA;;;AACA,UAAI,CAAA,KAAA,IAAU,CAAC,KAAA,CAAf,UAAA,EAAgC;AAEhCC,MAAAA,KAAK,IAALA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,KAAK,CAAA,KAAA,EAALA,OAAK,CAALA;AAnFA,KAAA,CAAA,CAAA,CACA;;;AACA,QAAIpB,iBAAiB,CAArB,MAAqB,CAArB,EAA8B;AAE9B,SAAA,QAAA,GAAA,QAAA;;AAEA,QAAA,SAAA,EAAe;AACb,WAAA,SAAA,GAAA,SAAA;AAPF,KAAA,CAUA;;;AACAC,IAAAA,MAAK,CAALA,eAAAA;;AACAA,IAAAA,MAAK,CAZL,cAYAA,GAZA,CAcA;AACA;;;AACA,QAAMC,KAAI,GAAGC,gBAAgB,CAA7B,MAA6B,CAA7B;;AACA,yBAAsBE,YAAtB,EAAA;AAAA,QAAQD,UAAR,kBAAQA,SAAR;;AACA,SAAA,OAAA,GAAe,CAAA,QAAA,CAAA,EAAA,EAAMF,KAAI,CAAV,KAAA,EAAA;AAAkBE,MAAAA,SAAS,EAATA;AAAlB,KAAA,CAAA,CAAf,CAlBA,CAoBA;;AACA,QAAQE,cAAR,GAAA,QAAA,CAAQA,cAAR;AACAA,IAAAA,cAAc,IAAdA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,cAAc,CAAA,MAAA,EAAUC,UAAU,CAAA,KAAA,EAAO,KAtBzC,OAsBkC,CAApB,CAAdD,CAtBA,CAwBA;;AACA,SAAA,eAAA,GAAuBE,IAAI,CACzBC,eAAe,CAAA,MAAA,EAAA,aAAA,EAAwB,KADd,aACV,CADU,EAEzBA,eAAe,CAAA,MAAA,EAAA,WAAA,EAAsB,KAFZ,WAEV,CAFU,EAGzBA,eAAe,CAAA,MAAA,EAAA,eAAA,EAA0B,KAH3C,WAGiB,CAHU,CAA3B;AAKD;;AA5DH;AAAA;AAAA,WAoHEY,wBAAc,QAAdA,EAAsD;AACpD,WAAA,QAAA,GAAA,QAAA;AACD;AAtHH;AAAA;AAAA,WAwHEC,eAAM;AAAA,UAAA,qBAAA;;AACJ,OAAA,qBAAA,GAAA,KAAA,eAAA,KAAA,IAAA,GAAA,KAAA,CAAA,GAAA,qBAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AACAC,MAAAA,UAAU,CAAVA,MAAAA,CAAkB,KAAlBA,WAAAA;AACD;AA3HH;;AAAA;AAAA;;AA8HA,SAAA,aAAA,CAAA,CAAA,EAAA,CAAA,EAA2C;AACzC,SAAO;AAAEX,IAAAA,CAAC,EAAEY,CAAC,CAADA,CAAAA,GAAMC,CAAC,CAAZ,CAAA;AAAgBZ,IAAAA,CAAC,EAAEW,CAAC,CAADA,CAAAA,GAAMC,CAAC,CAACZ;AAA3B,GAAP;AACD;;AAED,SAAA,aAAA,CAAA,OAAA,EAAmD;AACjD,SAAOa,OAAO,CAAd,CAAc,CAAd;AACD;;AAED,SAAA,YAAA,CAAA,OAAA,EAAkD;AAChD,SAAOA,OAAO,CAACA,OAAO,CAAPA,MAAAA,GAAf,CAAc,CAAd;AACD;;AAED,SAAA,UAAA,CAAA,IAAA,EAAA,OAAA,EAAwE;AACtE,SAAO;AACLC,IAAAA,KAAK,EAAEzB,IAAI,CADN,KAAA;AAEL0B,IAAAA,KAAK,EAAEC,aAAa,CAAC3B,IAAI,CAAL,KAAA,EAAa4B,YAAY,CAFxC,OAEwC,CAAzB,CAFf;AAGLC,IAAAA,MAAM,EAAEF,aAAa,CAAC3B,IAAI,CAAL,KAAA,EAAa8B,aAAa,CAH1C,OAG0C,CAA1B,CAHhB;AAILC,IAAAA,QAAQ,EAAEC,WAAW,CAAA,OAAA,EAAA,GAAA;AAJhB,GAAP;AAMD;;AAED,SAAA,eAAA,CAAA,OAAA,EAAwE;AACtE,SAAOR,OAAO,CAACA,OAAO,CAAPA,MAAAA,GAAf,CAAc,CAAd;AACD;;AAED,IAAMS,cAAc,GAAIC,SAAlBD,cAAkBC,CAAAA,OAAD;AAAA,SAAqBA,OAAO,GAAnD,IAAuB;AAAA,CAAvB;;AAEA,SAAA,WAAA,CAAA,OAAA,EAAA,SAAA,EAA4E;AAC1E,MAAIV,OAAO,CAAPA,MAAAA,GAAJ,CAAA,EAAwB;AACtB,WAAO;AAAEd,MAAAA,CAAC,EAAH,CAAA;AAAQC,MAAAA,CAAC,EAAE;AAAX,KAAP;AACD;;AAED,MAAIwB,CAAC,GAAGX,OAAO,CAAPA,MAAAA,GAAR,CAAA;AACA,MAAIY,gBAAyC,GAA7C,IAAA;AACA,MAAMC,SAAS,GAAGC,eAAe,CAAjC,OAAiC,CAAjC;;AACA,SAAOH,CAAC,IAAR,CAAA,EAAe;AACbC,IAAAA,gBAAgB,GAAGZ,OAAO,CAA1BY,CAA0B,CAA1BA;;AACA,QACEC,SAAS,CAATA,SAAAA,GAAsBD,gBAAgB,CAAtCC,SAAAA,GACAJ,cAAc,CAFhB,SAEgB,CAFhB,EAGE;AACA;AACD;;AACDE,IAAAA,CAAC;AACF;;AAED,MAAI,CAAJ,gBAAA,EAAuB;AACrB,WAAO;AAAEzB,MAAAA,CAAC,EAAH,CAAA;AAAQC,MAAAA,CAAC,EAAE;AAAX,KAAP;AACD;;AAED,MAAM4B,IAAI,GAAG,CAACF,SAAS,CAATA,SAAAA,GAAsBD,gBAAgB,CAAvC,SAAA,IAAb,IAAA;;AACA,MAAIG,IAAI,KAAR,CAAA,EAAgB;AACd,WAAO;AAAE7B,MAAAA,CAAC,EAAH,CAAA;AAAQC,MAAAA,CAAC,EAAE;AAAX,KAAP;AACD;;AAED,MAAM6B,eAAe,GAAG;AACtB9B,IAAAA,CAAC,EAAE,CAAC2B,SAAS,CAATA,CAAAA,GAAcD,gBAAgB,CAA/B,CAAA,IADmB,IAAA;AAEtBzB,IAAAA,CAAC,EAAE,CAAC0B,SAAS,CAATA,CAAAA,GAAcD,gBAAgB,CAA/B,CAAA,IAAqCG;AAFlB,GAAxB;;AAKA,MAAIC,eAAe,CAAfA,CAAAA,KAAJ,QAAA,EAAoC;AAClCA,IAAAA,eAAe,CAAfA,CAAAA,GAAAA,CAAAA;AACD;;AACD,MAAIA,eAAe,CAAfA,CAAAA,KAAJ,QAAA,EAAoC;AAClCA,IAAAA,eAAe,CAAfA,CAAAA,GAAAA,CAAAA;AACD;;AAED,SAAA,eAAA;AACD","sourcesContent":["/**\n * This is a modified version of `PanSession` from `framer-motion`.\n *\n * Credit goes to `framer-motion` of this useful utilities.\n * License can be found here: https://github.com/framer/motion\n */\n\nimport sync, { cancelSync, getFrameData } from \"framesync\"\nimport {\n  isMouseEvent,\n  extractEventInfo,\n  addPointerEvent,\n  AnyPointerEvent,\n  Point,\n  PointerEventInfo,\n  isMultiTouchEvent,\n} from \"./pointer-event\"\nimport { pipe, distance, noop } from \"./function\"\n\n/**\n * The event information passed to pan event handlers like `onPan`, `onPanStart`.\n *\n * It contains information about the current state of the tap gesture such as its\n * `point`, `delta`, and `offset`\n */\nexport interface PanEventInfo {\n  /**\n   * Contains `x` and `y` values for the current pan position relative\n   * to the device or page.\n   */\n  point: Point\n  /**\n   * Contains `x` and `y` values for the distance moved since\n   * the last pan event.\n   */\n  delta: Point\n  /**\n   * Contains `x` and `y` values for the distance moved from\n   * the first pan event.\n   */\n  offset: Point\n  /**\n   * Contains `x` and `y` values for the current velocity of the pointer.\n   */\n  velocity: Point\n}\n\nexport type PanEventHandler = (\n  event: AnyPointerEvent,\n  info: PanEventInfo,\n) => void\n\ninterface TimestampedPoint extends Point {\n  timestamp: number\n}\n\nexport interface PanSessionHandlers {\n  /**\n   * Callback fired when the pan session is created.\n   * This is typically called once `pointerdown` event is fired.\n   */\n  onSessionStart: PanEventHandler\n  /**\n   * Callback fired when the pan session is detached.\n   * This is typically called once `pointerup` event is fired.\n   */\n  onSessionEnd: PanEventHandler\n  /**\n   * Callback fired when the pan session has started.\n   * The pan session when the pan offset is greater than\n   * the threshold (allowable move distance to detect pan)\n   */\n  onStart: PanEventHandler\n  /**\n   * Callback fired while panning\n   */\n  onMove: PanEventHandler\n  /**\n   * Callback fired when the current pan session has end.\n   * This is typically called once `pointerup` event is fired.\n   */\n  onEnd: PanEventHandler\n}\n\ntype PanSessionHistory = TimestampedPoint[]\n\n/**\n * @internal\n *\n * A Pan Session is recognized when the pointer is down\n * and moved in the allowed direction.\n */\nexport class PanSession {\n  /**\n   * We use this to keep track of the `x` and `y` pan session history\n   * as the pan event happens. It helps to calculate the `offset` and `delta`\n   */\n  private history: PanSessionHistory = []\n\n  // The pointer event that started the pan session\n  private startEvent: AnyPointerEvent | null = null\n\n  // The current pointer event for the pan session\n  private lastEvent: AnyPointerEvent | null = null\n\n  // The current pointer event info for the pan session\n  private lastEventInfo: PointerEventInfo | null = null\n\n  private handlers: Partial<PanSessionHandlers> = {}\n\n  private removeListeners: Function = noop\n\n  /**\n   * Minimal pan distance required before recognizing the pan.\n   * @default \"3px\"\n   */\n  private threshold = 3\n\n  constructor(\n    event: AnyPointerEvent,\n    handlers: Partial<PanSessionHandlers>,\n    threshold?: number,\n  ) {\n    // If we have more than one touch, don't start detecting this gesture\n    if (isMultiTouchEvent(event)) return\n\n    this.handlers = handlers\n\n    if (threshold) {\n      this.threshold = threshold\n    }\n\n    // stop default browser behavior\n    event.stopPropagation()\n    event.preventDefault()\n\n    // get and save the `pointerdown` event info in history\n    // we'll use it to compute the `offset`\n    const info = extractEventInfo(event)\n    const { timestamp } = getFrameData()\n    this.history = [{ ...info.point, timestamp }]\n\n    // notify pan session start\n    const { onSessionStart } = handlers\n    onSessionStart?.(event, getPanInfo(info, this.history))\n\n    // attach event listeners and return a single function to remove them all\n    this.removeListeners = pipe(\n      addPointerEvent(window, \"pointermove\", this.onPointerMove),\n      addPointerEvent(window, \"pointerup\", this.onPointerUp),\n      addPointerEvent(window, \"pointercancel\", this.onPointerUp),\n    )\n  }\n\n  private updatePoint = () => {\n    if (!(this.lastEvent && this.lastEventInfo)) return\n\n    const info = getPanInfo(this.lastEventInfo, this.history)\n\n    const isPanStarted = this.startEvent !== null\n\n    const isDistancePastThreshold =\n      distance(info.offset, { x: 0, y: 0 }) >= this.threshold\n\n    if (!isPanStarted && !isDistancePastThreshold) return\n\n    const { timestamp } = getFrameData()\n    this.history.push({ ...info.point, timestamp })\n\n    const { onStart, onMove } = this.handlers\n\n    if (!isPanStarted) {\n      onStart?.(this.lastEvent, info)\n      this.startEvent = this.lastEvent\n    }\n\n    onMove?.(this.lastEvent, info)\n  }\n\n  private onPointerMove = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    this.lastEvent = event\n    this.lastEventInfo = info\n\n    // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n    if (isMouseEvent(event) && event.buttons === 0) {\n      this.onPointerUp(event, info)\n      return\n    }\n\n    // Throttle mouse move event to once per frame\n    sync.update(this.updatePoint, true)\n  }\n\n  private onPointerUp = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    // notify pan session ended\n    const panInfo = getPanInfo(info, this.history)\n    const { onEnd, onSessionEnd } = this.handlers\n\n    onSessionEnd?.(event, panInfo)\n    this.end()\n\n    // if panning never started, no need to call `onEnd`\n    // panning requires a pointermove of at least 3px\n    if (!onEnd || !this.startEvent) return\n\n    onEnd?.(event, panInfo)\n  }\n\n  updateHandlers(handlers: Partial<PanSessionHandlers>) {\n    this.handlers = handlers\n  }\n\n  end() {\n    this.removeListeners?.()\n    cancelSync.update(this.updatePoint)\n  }\n}\n\nfunction subtractPoint(a: Point, b: Point) {\n  return { x: a.x - b.x, y: a.y - b.y }\n}\n\nfunction startPanPoint(history: PanSessionHistory) {\n  return history[0]\n}\n\nfunction lastPanPoint(history: PanSessionHistory) {\n  return history[history.length - 1]\n}\n\nfunction getPanInfo(info: PointerEventInfo, history: PanSessionHistory) {\n  return {\n    point: info.point,\n    delta: subtractPoint(info.point, lastPanPoint(history)),\n    offset: subtractPoint(info.point, startPanPoint(history)),\n    velocity: getVelocity(history, 0.1),\n  }\n}\n\nfunction lastDevicePoint(history: TimestampedPoint[]): TimestampedPoint {\n  return history[history.length - 1]\n}\n\nconst toMilliseconds = (seconds: number) => seconds * 1000\n\nfunction getVelocity(history: TimestampedPoint[], timeDelta: number): Point {\n  if (history.length < 2) {\n    return { x: 0, y: 0 }\n  }\n\n  let i = history.length - 1\n  let timestampedPoint: TimestampedPoint | null = null\n  const lastPoint = lastDevicePoint(history)\n  while (i >= 0) {\n    timestampedPoint = history[i]\n    if (\n      lastPoint.timestamp - timestampedPoint.timestamp >\n      toMilliseconds(timeDelta)\n    ) {\n      break\n    }\n    i--\n  }\n\n  if (!timestampedPoint) {\n    return { x: 0, y: 0 }\n  }\n\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000\n  if (time === 0) {\n    return { x: 0, y: 0 }\n  }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time,\n  }\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0\n  }\n\n  return currentVelocity\n}\n"]},"metadata":{},"sourceType":"module"}
{"version":3,"sources":["../../../src/utils/parse-gradient.ts"],"names":["directionMap","valueSet","Set","Object","values","globalSet","trimSpace","str","trim","parseGradient","value","theme","has","regex","exec","groups","type","_type","includes","split","map","filter","Boolean","maybeDirection","stops","length","direction","unshift","_values","stop","firstStop","indexOf","substr","_color","_stop","_stopOrFunc","isCSSFunction","key","color","__cssMap","varRef","join","gradientTransform"],"mappings":"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","sourcesContent":["import { Dict, isString } from \"@chakra-ui/utils\"\nimport { Transform } from \"./types\"\n\nconst directionMap = {\n  \"to-t\": \"to top\",\n  \"to-tr\": \"to top right\",\n  \"to-r\": \"to right\",\n  \"to-br\": \"to bottom right\",\n  \"to-b\": \"to bottom\",\n  \"to-bl\": \"to bottom left\",\n  \"to-l\": \"to left\",\n  \"to-tl\": \"to top left\",\n}\n\nconst valueSet = new Set(Object.values(directionMap))\n\nexport const globalSet = new Set([\n  \"none\",\n  \"-moz-initial\",\n  \"inherit\",\n  \"initial\",\n  \"revert\",\n  \"unset\",\n])\n\nconst trimSpace = (str: string) => str.trim()\n\nexport function parseGradient(value: string | null | undefined, theme: Dict) {\n  if (value == null || globalSet.has(value)) return value\n  const regex = /(?<type>^[a-z-A-Z]+)\\((?<values>(.*))\\)/g\n  const { type, values } = regex.exec(value)?.groups ?? {}\n\n  if (!type || !values) return value\n\n  const _type = type.includes(\"-gradient\") ? type : `${type}-gradient`\n  const [maybeDirection, ...stops] = values\n    .split(\",\")\n    .map(trimSpace)\n    .filter(Boolean)\n\n  if (stops?.length === 0) return value\n\n  const direction =\n    maybeDirection in directionMap\n      ? directionMap[maybeDirection]\n      : maybeDirection\n\n  stops.unshift(direction)\n\n  const _values = stops.map((stop) => {\n    // if stop is valid shorthand direction, return it\n    if (valueSet.has(stop)) return stop\n\n    const firstStop = stop.indexOf(\" \")\n\n    // color stop could be `red.200 20%` based on css gradient spec\n    const [_color, _stop] =\n      firstStop !== -1\n        ? [stop.substr(0, firstStop), stop.substr(firstStop + 1)]\n        : [stop]\n\n    const _stopOrFunc = isCSSFunction(_stop) ? _stop : _stop && _stop.split(\" \")\n\n    // else, get and transform the color token or css value\n    const key = `colors.${_color}`\n    const color = key in theme.__cssMap ? theme.__cssMap[key].varRef : _color\n    return _stopOrFunc ? [color, _stopOrFunc].join(\" \") : color\n  })\n\n  return `${_type}(${_values.join(\", \")})`\n}\n\nexport const isCSSFunction = (value: unknown) => {\n  return isString(value) && value.includes(\"(\") && value.includes(\")\")\n}\n\nexport const gradientTransform: Transform = (value, theme) =>\n  parseGradient(value, theme ?? {})\n"],"file":"parse-gradient.js"}
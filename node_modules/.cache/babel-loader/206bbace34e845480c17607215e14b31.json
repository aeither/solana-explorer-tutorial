{"ast":null,"code":"import _classCallCheck from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { useEffect } from \"react\";\n/**\n * Proper state management for nested modals.\n * Simplified, but inspired by material-ui's ModalManager class.\n */\n\nvar ModalManager = /*#__PURE__*/function () {\n  function ModalManager() {\n    _classCallCheck(this, ModalManager);\n\n    _defineProperty(this, \"modals\", void 0);\n\n    this.modals = [];\n  }\n\n  _createClass(ModalManager, [{\n    key: \"add\",\n    value: function add(modal) {\n      this.modals.push(modal);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(modal) {\n      this.modals = this.modals.filter(function (_modal) {\n        return _modal !== modal;\n      });\n    }\n  }, {\n    key: \"isTopModal\",\n    value: function isTopModal(modal) {\n      var topmostModal = this.modals[this.modals.length - 1];\n      return topmostModal === modal;\n    }\n  }]);\n\n  return ModalManager;\n}();\n\nexport var manager = new ModalManager();\nexport function useModalManager(ref, isOpen) {\n  useEffect(function () {\n    if (isOpen) {\n      manager.add(ref);\n    }\n\n    return function () {\n      manager.remove(ref);\n    };\n  }, [isOpen, ref]);\n}","map":{"version":3,"sources":["../../src/modal-manager.ts"],"names":["constructor","add","remove","_modal","isTopModal","topmostModal","manager","useEffect"],"mappings":";;;;;;;;;;;;;;;;;;AAAA,SAAA,SAAA,QAAA,OAAA;AAEA;AACA;AACA;AACA;;IACA,Y;AAEEA,0BAAc;AAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,QAAA,EAAA,KAAA,CAAA,CAAA;;AACZ,SAAA,MAAA,GAAA,EAAA;AACD;;;;WAEDC,aAAG,KAAHA,EAAgB;AACd,WAAA,MAAA,CAAA,IAAA,CAAA,KAAA;AACD;;;WAEDC,gBAAM,KAANA,EAAmB;AACjB,WAAA,MAAA,GAAc,KAAA,MAAA,CAAA,MAAA,CAAoBC,UAAAA,MAAD;AAAA,eAAYA,MAAM,KAAnD,KAAiC;AAAA,OAAnB,CAAd;AACD;;;WAEDC,oBAAU,KAAVA,EAAuB;AACrB,UAAMC,YAAY,GAAG,KAAA,MAAA,CAAY,KAAA,MAAA,CAAA,MAAA,GAAjC,CAAqB,CAArB;AACA,aAAOA,YAAY,KAAnB,KAAA;AACD;;;;;;AAGH,OAAO,IAAMC,OAAO,GAAG,IAAhB,YAAgB,EAAhB;AAEP,OAAO,SAAA,eAAA,CAAA,GAAA,EAAA,MAAA,EAA0D;AAC/DC,EAAAA,SAAS,CAAC,YAAM;AACd,QAAA,MAAA,EAAY;AACVD,MAAAA,OAAO,CAAPA,GAAAA,CAAAA,GAAAA;AACD;;AACD,WAAO,YAAM;AACXA,MAAAA,OAAO,CAAPA,MAAAA,CAAAA,GAAAA;AADF,KAAA;AAJO,GAAA,EAON,CAAA,MAAA,EAPHC,GAOG,CAPM,CAATA;AAQD","sourcesContent":["import { useEffect, Ref } from \"react\"\n\n/**\n * Proper state management for nested modals.\n * Simplified, but inspired by material-ui's ModalManager class.\n */\nclass ModalManager {\n  modals: any[]\n  constructor() {\n    this.modals = []\n  }\n\n  add(modal: any) {\n    this.modals.push(modal)\n  }\n\n  remove(modal: any) {\n    this.modals = this.modals.filter((_modal) => _modal !== modal)\n  }\n\n  isTopModal(modal: any) {\n    const topmostModal = this.modals[this.modals.length - 1]\n    return topmostModal === modal\n  }\n}\n\nexport const manager = new ModalManager()\n\nexport function useModalManager(ref: Ref<any>, isOpen?: boolean) {\n  useEffect(() => {\n    if (isOpen) {\n      manager.add(ref)\n    }\n    return () => {\n      manager.remove(ref)\n    }\n  }, [isOpen, ref])\n}\n"]},"metadata":{},"sourceType":"module"}
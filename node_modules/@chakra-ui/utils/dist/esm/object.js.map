{"version":3,"sources":["../../src/object.ts"],"names":["default","mergeWith","omit","object","keys","result","Object","forEach","key","includes","pick","split","picked","omitted","get","obj","path","fallback","index","length","undefined","memoize","fn","cache","WeakMap","memoizedFn","has","set","Map","map","value","memoizedGet","getWithDefault","scale","objectFilter","shouldPass","filterUndefined","val","objectKeys","fromEntries","entries","reduce","carry","getCSSVar","theme","__cssMap","varRef"],"mappings":"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","sourcesContent":["import type { Dict, Omit } from \"./types\"\n\nexport { default as mergeWith } from \"lodash.mergewith\"\n\nexport function omit<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    if (keys.includes(key as K)) return\n    result[key] = object[key]\n  })\n\n  return result as Omit<T, K>\n}\n\nexport function pick<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result = {} as { [P in K]: T[P] }\n\n  keys.forEach((key) => {\n    if (key in object) {\n      result[key] = object[key]\n    }\n  })\n\n  return result\n}\n\nexport function split<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const picked: Dict = {}\n  const omitted: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    if (keys.includes(key as T[K])) {\n      picked[key] = object[key]\n    } else {\n      omitted[key] = object[key]\n    }\n  })\n\n  return [picked, omitted] as [{ [P in K]: T[P] }, Omit<T, K>]\n}\n\n/**\n * Get value from a deeply nested object using a string path.\n * Memoizes the value.\n * @param obj - the object\n * @param path - the string path\n * @param def  - the fallback value\n */\nexport function get(\n  obj: object,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) {\n  const key = typeof path === \"string\" ? path.split(\".\") : [path]\n\n  for (index = 0; index < key.length; index += 1) {\n    if (!obj) break\n    obj = obj[key[index]]\n  }\n\n  return obj === undefined ? fallback : obj\n}\n\ntype Get = (\n  obj: Readonly<object>,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) => any\n\nexport const memoize = (fn: Get) => {\n  const cache = new WeakMap()\n\n  const memoizedFn: Get = (obj, path, fallback, index) => {\n    if (typeof obj === \"undefined\") {\n      return fn(obj, path, fallback)\n    }\n\n    if (!cache.has(obj)) {\n      cache.set(obj, new Map())\n    }\n\n    const map = cache.get(obj)\n\n    if (map.has(path)) {\n      return map.get(path)\n    }\n\n    const value = fn(obj, path, fallback, index)\n\n    map.set(path, value)\n\n    return value\n  }\n\n  return memoizedFn\n}\n\nexport const memoizedGet = memoize(get)\n\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\nexport function getWithDefault(path: any, scale: any) {\n  return memoizedGet(scale, path, path)\n}\n\ntype FilterFn<T> = (value: any, key: string, object: T) => boolean\n\n/**\n * Returns the items of an object that meet the condition specified in a callback function.\n *\n * @param object the object to loop through\n * @param fn The filter function\n */\nexport function objectFilter<T extends Dict>(object: T, fn: FilterFn<T>) {\n  const result: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    const value = object[key]\n    const shouldPass = fn(value, key, object)\n    if (shouldPass) {\n      result[key] = value\n    }\n  })\n\n  return result\n}\n\nexport const filterUndefined = (object: Dict) =>\n  objectFilter(object, (val) => val !== null && val !== undefined)\n\nexport const objectKeys = <T extends Dict>(obj: T) =>\n  (Object.keys(obj) as unknown) as (keyof T)[]\n\n/**\n * Object.entries polyfill for Nodev10 compatibility\n */\nexport const fromEntries = <T extends unknown>(entries: [string, any][]) =>\n  entries.reduce((carry, [key, value]) => {\n    carry[key] = value\n    return carry\n  }, {}) as T\n\n/**\n * Get the CSS variable ref stored in the theme\n */\nexport const getCSSVar = (theme: Dict, scale: string, value: any) =>\n  theme.__cssMap[`${scale}.${value}`]?.varRef ?? value\n"],"file":"object.js"}
{"ast":null,"code":"import { __spreadArray, __read, __assign, __rest } from 'tslib';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.js';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.js';\nimport { shallowCompare } from '../../utils/shallow-compare.js';\nimport { animateVisualElement } from './animation.js';\nimport { AnimationType } from './types.js';\nimport { isVariantLabels, resolveVariant, isVariantLabel } from './variants.js';\nvar variantPriorityOrder = [AnimationType.Animate, AnimationType.Hover, AnimationType.Tap, AnimationType.Drag, AnimationType.Focus, AnimationType.Exit];\n\nvar reversePriorityOrder = __spreadArray([], __read(variantPriorityOrder)).reverse();\n\nvar numAnimationTypes = variantPriorityOrder.length;\n\nfunction animateList(visualElement) {\n  return function (animations) {\n    return Promise.all(animations.map(function (_a) {\n      var animation = _a.animation,\n          options = _a.options;\n      return animateVisualElement(visualElement, animation, options);\n    }));\n  };\n}\n\nfunction createAnimationState(visualElement) {\n  var animate = animateList(visualElement);\n  var state = createState();\n  var allAnimatedKeys = {};\n  var isInitialRender = true;\n  /**\n   * This function will be used to reduce the animation definitions for\n   * each active animation type into an object of resolved values for it.\n   */\n\n  var buildResolvedTypeValues = function buildResolvedTypeValues(acc, definition) {\n    var resolved = resolveVariant(visualElement, definition);\n\n    if (resolved) {\n      resolved.transition;\n\n      var transitionEnd = resolved.transitionEnd,\n          target = __rest(resolved, [\"transition\", \"transitionEnd\"]);\n\n      acc = __assign(__assign(__assign({}, acc), target), transitionEnd);\n    }\n\n    return acc;\n  };\n\n  function isAnimated(key) {\n    return allAnimatedKeys[key] !== undefined;\n  }\n  /**\n   * This just allows us to inject mocked animation functions\n   * @internal\n   */\n\n\n  function setAnimateFunction(makeAnimator) {\n    animate = makeAnimator(visualElement);\n  }\n  /**\n   * When we receive new props, we need to:\n   * 1. Create a list of protected keys for each type. This is a directory of\n   *    value keys that are currently being \"handled\" by types of a higher priority\n   *    so that whenever an animation is played of a given type, these values are\n   *    protected from being animated.\n   * 2. Determine if an animation type needs animating.\n   * 3. Determine if any values have been removed from a type and figure out\n   *    what to animate those to.\n   */\n\n\n  function animateChanges(options, changedActiveType) {\n    var _a;\n\n    var props = visualElement.getProps();\n    var context = visualElement.getVariantContext(true) || {};\n    /**\n     * A list of animations that we'll build into as we iterate through the animation\n     * types. This will get executed at the end of the function.\n     */\n\n    var animations = [];\n    /**\n     * Keep track of which values have been removed. Then, as we hit lower priority\n     * animation types, we can check if they contain removed values and animate to that.\n     */\n\n    var removedKeys = new Set();\n    /**\n     * A dictionary of all encountered keys. This is an object to let us build into and\n     * copy it without iteration. Each time we hit an animation type we set its protected\n     * keys - the keys its not allowed to animate - to the latest version of this object.\n     */\n\n    var encounteredKeys = {};\n    /**\n     * If a variant has been removed at a given index, and this component is controlling\n     * variant animations, we want to ensure lower-priority variants are forced to animate.\n     */\n\n    var removedVariantIndex = Infinity;\n\n    var _loop_1 = function _loop_1(i) {\n      var type = reversePriorityOrder[i];\n      var typeState = state[type];\n      var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n      var propIsVariant = isVariantLabel(prop);\n      /**\n       * If this type has *just* changed isActive status, set activeDelta\n       * to that status. Otherwise set to null.\n       */\n\n      var activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false) removedVariantIndex = i;\n      /**\n       * If this prop is an inherited variant, rather than been set directly on the\n       * component itself, we want to make sure we allow the parent to trigger animations.\n       *\n       * TODO: Can probably change this to a !isControllingVariants check\n       */\n\n      var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      /**\n       *\n       */\n\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      /**\n       * Set all encountered keys so far as the protected keys for this type. This will\n       * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n       */\n\n\n      typeState.protectedKeys = __assign({}, encounteredKeys); // Check if we can skip analysing this prop early\n\n      if ( // If it isn't active and hasn't *just* been set as inactive\n      !typeState.isActive && activeDelta === null || !prop && !typeState.prevProp || // Or if the prop doesn't define an animation\n      isAnimationControls(prop) || typeof prop === \"boolean\") {\n        return \"continue\";\n      }\n      /**\n       * As we go look through the values defined on this type, if we detect\n       * a changed value or a value that was removed in a higher priority, we set\n       * this to true and add this prop to the animation list.\n       */\n\n\n      var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i > removedVariantIndex && propIsVariant;\n      /**\n       * As animations can be set as variant lists, variants or target objects, we\n       * coerce everything to an array if it isn't one already\n       */\n\n      var definitionList = Array.isArray(prop) ? prop : [prop];\n      /**\n       * Build an object of all the resolved values. We'll use this in the subsequent\n       * animateChanges calls to determine whether a value has changed.\n       */\n\n      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n      if (activeDelta === false) resolvedValues = {};\n      /**\n       * Now we need to loop through all the keys in the prev prop and this prop,\n       * and decide:\n       * 1. If the value has changed, and needs animating\n       * 2. If it has been removed, and needs adding to the removedKeys set\n       * 3. If it has been removed in a higher priority type and needs animating\n       * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n       *    needs adding to the type's protectedKeys list.\n       */\n\n      var _b = typeState.prevResolvedValues,\n          prevResolvedValues = _b === void 0 ? {} : _b;\n\n      var allKeys = __assign(__assign({}, prevResolvedValues), resolvedValues);\n\n      var markToAnimate = function markToAnimate(key) {\n        shouldAnimateType = true;\n        removedKeys.delete(key);\n        typeState.needsAnimating[key] = true;\n      };\n\n      for (var key in allKeys) {\n        var next = resolvedValues[key];\n        var prev = prevResolvedValues[key]; // If we've already handled this we can just skip ahead\n\n        if (encounteredKeys.hasOwnProperty(key)) continue;\n        /**\n         * If the value has changed, we probably want to animate it.\n         */\n\n        if (next !== prev) {\n          /**\n           * If both values are keyframes, we need to shallow compare them to\n           * detect whether any value has changed. If it has, we animate it.\n           */\n          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n            if (!shallowCompare(next, prev)) {\n              markToAnimate(key);\n            } else {\n              /**\n               * If it hasn't changed, we want to ensure it doesn't animate by\n               * adding it to the list of protected keys.\n               */\n              typeState.protectedKeys[key] = true;\n            }\n          } else if (next !== undefined) {\n            // If next is defined and doesn't equal prev, it needs animating\n            markToAnimate(key);\n          } else {\n            // If it's undefined, it's been removed.\n            removedKeys.add(key);\n          }\n        } else if (next !== undefined && removedKeys.has(key)) {\n          /**\n           * If next hasn't changed and it isn't undefined, we want to check if it's\n           * been removed by a higher priority\n           */\n          markToAnimate(key);\n        } else {\n          /**\n           * If it hasn't changed, we add it to the list of protected values\n           * to ensure it doesn't get animated.\n           */\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      /**\n       * Update the typeState so next time animateChanges is called we can compare the\n       * latest prop and resolvedValues to these.\n       */\n\n\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      /**\n       *\n       */\n\n      if (typeState.isActive) {\n        encounteredKeys = __assign(__assign({}, encounteredKeys), resolvedValues);\n      }\n\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      /**\n       * If this is an inherited prop we want to hard-block animations\n       * TODO: Test as this should probably still handle animations triggered\n       * by removed values?\n       */\n\n\n      if (shouldAnimateType && !isInherited) {\n        animations.push.apply(animations, __spreadArray([], __read(definitionList.map(function (animation) {\n          return {\n            animation: animation,\n            options: __assign({\n              type: type\n            }, options)\n          };\n        }))));\n      }\n    };\n    /**\n     * Iterate through all animation types in reverse priority order. For each, we want to\n     * detect which values it's handling and whether or not they've changed (and therefore\n     * need to be animated). If any values have been removed, we want to detect those in\n     * lower priority props and flag for animation.\n     */\n\n\n    for (var i = 0; i < numAnimationTypes; i++) {\n      _loop_1(i);\n    }\n\n    allAnimatedKeys = __assign({}, encounteredKeys);\n    /**\n     * If there are some removed value that haven't been dealt with,\n     * we need to create a new animation that falls back either to the value\n     * defined in the style prop, or the last read value.\n     */\n\n    if (removedKeys.size) {\n      var fallbackAnimation_1 = {};\n      removedKeys.forEach(function (key) {\n        var fallbackTarget = visualElement.getBaseTarget(key);\n\n        if (fallbackTarget !== undefined) {\n          fallbackAnimation_1[key] = fallbackTarget;\n        }\n      });\n      animations.push({\n        animation: fallbackAnimation_1\n      });\n    }\n\n    var shouldAnimate = Boolean(animations.length);\n\n    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n\n    isInitialRender = false;\n    return shouldAnimate ? animate(animations) : Promise.resolve();\n  }\n  /**\n   * Change whether a certain animation type is active.\n   */\n\n\n  function setActive(type, isActive, options) {\n    var _a; // If the active state hasn't changed, we can safely do nothing here\n\n\n    if (state[type].isActive === isActive) return Promise.resolve(); // Propagate active change to children\n\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      var _a;\n\n      return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    return animateChanges(options, type);\n  }\n\n  return {\n    isAnimated: isAnimated,\n    animateChanges: animateChanges,\n    setActive: setActive,\n    setAnimateFunction: setAnimateFunction,\n    getState: function getState() {\n      return state;\n    }\n  };\n}\n\nfunction variantsHaveChanged(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (isVariantLabels(next)) {\n    return !shallowCompare(next, prev);\n  }\n\n  return false;\n}\n\nfunction createTypeState(isActive) {\n  if (isActive === void 0) {\n    isActive = false;\n  }\n\n  return {\n    isActive: isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\n\nfunction createState() {\n  var _a;\n\n  return _a = {}, _a[AnimationType.Animate] = createTypeState(true), _a[AnimationType.Hover] = createTypeState(), _a[AnimationType.Tap] = createTypeState(), _a[AnimationType.Drag] = createTypeState(), _a[AnimationType.Focus] = createTypeState(), _a[AnimationType.Exit] = createTypeState(), _a;\n}\n\nexport { createAnimationState, variantPriorityOrder, variantsHaveChanged };","map":{"version":3,"sources":["/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/framer-motion/dist/es/render/utils/animation-state.js"],"names":["__spreadArray","__read","__assign","__rest","isAnimationControls","isKeyframesTarget","shallowCompare","animateVisualElement","AnimationType","isVariantLabels","resolveVariant","isVariantLabel","variantPriorityOrder","Animate","Hover","Tap","Drag","Focus","Exit","reversePriorityOrder","reverse","numAnimationTypes","length","animateList","visualElement","animations","Promise","all","map","_a","animation","options","createAnimationState","animate","state","createState","allAnimatedKeys","isInitialRender","buildResolvedTypeValues","acc","definition","resolved","transition","transitionEnd","target","isAnimated","key","undefined","setAnimateFunction","makeAnimator","animateChanges","changedActiveType","props","getProps","context","getVariantContext","removedKeys","Set","encounteredKeys","removedVariantIndex","Infinity","_loop_1","i","type","typeState","prop","propIsVariant","activeDelta","isActive","isInherited","manuallyAnimateOnMount","protectedKeys","prevProp","shouldAnimateType","variantsHaveChanged","definitionList","Array","isArray","resolvedValues","reduce","_b","prevResolvedValues","allKeys","markToAnimate","delete","needsAnimating","next","prev","hasOwnProperty","add","has","blockInitialAnimation","push","apply","size","fallbackAnimation_1","forEach","fallbackTarget","getBaseTarget","shouldAnimate","Boolean","initial","resolve","setActive","variantChildren","child","animationState","getState","createTypeState"],"mappings":"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","sourcesContent":["import { __spreadArray, __read, __assign, __rest } from 'tslib';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.js';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.js';\nimport { shallowCompare } from '../../utils/shallow-compare.js';\nimport { animateVisualElement } from './animation.js';\nimport { AnimationType } from './types.js';\nimport { isVariantLabels, resolveVariant, isVariantLabel } from './variants.js';\n\nvar variantPriorityOrder = [\n    AnimationType.Animate,\n    AnimationType.Hover,\n    AnimationType.Tap,\n    AnimationType.Drag,\n    AnimationType.Focus,\n    AnimationType.Exit,\n];\nvar reversePriorityOrder = __spreadArray([], __read(variantPriorityOrder)).reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return function (animations) {\n        return Promise.all(animations.map(function (_a) {\n            var animation = _a.animation, options = _a.options;\n            return animateVisualElement(visualElement, animation, options);\n        }));\n    };\n}\nfunction createAnimationState(visualElement) {\n    var animate = animateList(visualElement);\n    var state = createState();\n    var allAnimatedKeys = {};\n    var isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    var buildResolvedTypeValues = function (acc, definition) {\n        var resolved = resolveVariant(visualElement, definition);\n        if (resolved) {\n            resolved.transition; var transitionEnd = resolved.transitionEnd, target = __rest(resolved, [\"transition\", \"transitionEnd\"]);\n            acc = __assign(__assign(__assign({}, acc), target), transitionEnd);\n        }\n        return acc;\n    };\n    function isAnimated(key) {\n        return allAnimatedKeys[key] !== undefined;\n    }\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(options, changedActiveType) {\n        var _a;\n        var props = visualElement.getProps();\n        var context = visualElement.getVariantContext(true) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        var animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        var removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        var encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        var removedVariantIndex = Infinity;\n        var _loop_1 = function (i) {\n            var type = reversePriorityOrder[i];\n            var typeState = state[type];\n            var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n            var propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            var activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = __assign({}, encounteredKeys);\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                return \"continue\";\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            var definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;\n            var allKeys = __assign(__assign({}, prevResolvedValues), resolvedValues);\n            var markToAnimate = function (key) {\n                shouldAnimateType = true;\n                removedKeys.delete(key);\n                typeState.needsAnimating[key] = true;\n            };\n            for (var key in allKeys) {\n                var next = resolvedValues[key];\n                var prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                if (next !== prev) {\n                    /**\n                     * If both values are keyframes, we need to shallow compare them to\n                     * detect whether any value has changed. If it has, we animate it.\n                     */\n                    if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                        if (!shallowCompare(next, prev)) {\n                            markToAnimate(key);\n                        }\n                        else {\n                            /**\n                             * If it hasn't changed, we want to ensure it doesn't animate by\n                             * adding it to the list of protected keys.\n                             */\n                            typeState.protectedKeys[key] = true;\n                        }\n                    }\n                    else if (next !== undefined) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = __assign(__assign({}, encounteredKeys), resolvedValues);\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to hard-block animations\n             * TODO: Test as this should probably still handle animations triggered\n             * by removed values?\n             */\n            if (shouldAnimateType && !isInherited) {\n                animations.push.apply(animations, __spreadArray([], __read(definitionList.map(function (animation) { return ({\n                    animation: animation,\n                    options: __assign({ type: type }, options),\n                }); }))));\n            }\n        };\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (var i = 0; i < numAnimationTypes; i++) {\n            _loop_1(i);\n        }\n        allAnimatedKeys = __assign({}, encounteredKeys);\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            var fallbackAnimation_1 = {};\n            removedKeys.forEach(function (key) {\n                var fallbackTarget = visualElement.getBaseTarget(key);\n                if (fallbackTarget !== undefined) {\n                    fallbackAnimation_1[key] = fallbackTarget;\n                }\n            });\n            animations.push({ animation: fallbackAnimation_1 });\n        }\n        var shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            props.initial === false &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive, options) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        return animateChanges(options, type);\n    }\n    return {\n        isAnimated: isAnimated,\n        animateChanges: animateChanges,\n        setActive: setActive,\n        setAnimateFunction: setAnimateFunction,\n        getState: function () { return state; },\n    };\n}\nfunction variantsHaveChanged(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (isVariantLabels(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive) {\n    if (isActive === void 0) { isActive = false; }\n    return {\n        isActive: isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    var _a;\n    return _a = {},\n        _a[AnimationType.Animate] = createTypeState(true),\n        _a[AnimationType.Hover] = createTypeState(),\n        _a[AnimationType.Tap] = createTypeState(),\n        _a[AnimationType.Drag] = createTypeState(),\n        _a[AnimationType.Focus] = createTypeState(),\n        _a[AnimationType.Exit] = createTypeState(),\n        _a;\n}\n\nexport { createAnimationState, variantPriorityOrder, variantsHaveChanged };\n"]},"metadata":{},"sourceType":"module"}
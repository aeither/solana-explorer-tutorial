{"ast":null,"code":"var _createForOfIteratorHelper = require(\"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar errors = {\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\n  TWEAK_ADD: 'The tweak was out of range or the resulted private key is invalid',\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\n  SECKEY_INVALID: 'Private Key is invalid',\n  PUBKEY_PARSE: 'Public Key could not be parsed',\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\n  SIG_PARSE: 'Signature could not be parsed',\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\n  RECOVER: 'Public key could not be recover',\n  ECDH: 'Scalar was invalid (zero or overflow)'\n};\n\nfunction assert(cond, msg) {\n  if (!cond) throw new Error(msg);\n}\n\nfunction isUint8Array(name, value, length) {\n  assert(value instanceof Uint8Array, \"Expected \".concat(name, \" to be an Uint8Array\"));\n\n  if (length !== undefined) {\n    if (Array.isArray(length)) {\n      var numbers = length.join(', ');\n      var msg = \"Expected \".concat(name, \" to be an Uint8Array with length [\").concat(numbers, \"]\");\n      assert(length.includes(value.length), msg);\n    } else {\n      var _msg = \"Expected \".concat(name, \" to be an Uint8Array with length \").concat(length);\n\n      assert(value.length === length, _msg);\n    }\n  }\n}\n\nfunction isCompressed(value) {\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean');\n}\n\nfunction getAssertedOutput() {\n  var output = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (len) {\n    return new Uint8Array(len);\n  };\n  var length = arguments.length > 1 ? arguments[1] : undefined;\n  if (typeof output === 'function') output = output(length);\n  isUint8Array('output', output, length);\n  return output;\n}\n\nfunction toTypeString(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\n\nmodule.exports = function (secp256k1) {\n  return {\n    contextRandomize: function contextRandomize(seed) {\n      assert(seed === null || seed instanceof Uint8Array, 'Expected seed to be an Uint8Array or null');\n      if (seed !== null) isUint8Array('seed', seed, 32);\n\n      switch (secp256k1.contextRandomize(seed)) {\n        case 1:\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);\n      }\n    },\n    privateKeyVerify: function privateKeyVerify(seckey) {\n      isUint8Array('private key', seckey, 32);\n      return secp256k1.privateKeyVerify(seckey) === 0;\n    },\n    privateKeyNegate: function privateKeyNegate(seckey) {\n      isUint8Array('private key', seckey, 32);\n\n      switch (secp256k1.privateKeyNegate(seckey)) {\n        case 0:\n          return seckey;\n\n        case 1:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    privateKeyTweakAdd: function privateKeyTweakAdd(seckey, tweak) {\n      isUint8Array('private key', seckey, 32);\n      isUint8Array('tweak', tweak, 32);\n\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\n        case 0:\n          return seckey;\n\n        case 1:\n          throw new Error(errors.TWEAK_ADD);\n      }\n    },\n    privateKeyTweakMul: function privateKeyTweakMul(seckey, tweak) {\n      isUint8Array('private key', seckey, 32);\n      isUint8Array('tweak', tweak, 32);\n\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\n        case 0:\n          return seckey;\n\n        case 1:\n          throw new Error(errors.TWEAK_MUL);\n      }\n    },\n    publicKeyVerify: function publicKeyVerify(pubkey) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      return secp256k1.publicKeyVerify(pubkey) === 0;\n    },\n    publicKeyCreate: function publicKeyCreate(seckey) {\n      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var output = arguments.length > 2 ? arguments[2] : undefined;\n      isUint8Array('private key', seckey, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.SECKEY_INVALID);\n\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyConvert: function publicKeyConvert(pubkey) {\n      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var output = arguments.length > 2 ? arguments[2] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyNegate: function publicKeyNegate(pubkey) {\n      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var output = arguments.length > 2 ? arguments[2] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyCombine: function publicKeyCombine(pubkeys) {\n      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var output = arguments.length > 2 ? arguments[2] : undefined;\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array');\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items');\n\n      var _iterator = _createForOfIteratorHelper(pubkeys),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pubkey = _step.value;\n          isUint8Array('public key', pubkey, [33, 65]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.PUBKEY_COMBINE);\n\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyTweakAdd: function publicKeyTweakAdd(pubkey, tweak) {\n      var compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('tweak', tweak, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.TWEAK_ADD);\n      }\n    },\n    publicKeyTweakMul: function publicKeyTweakMul(pubkey, tweak) {\n      var compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('tweak', tweak, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.TWEAK_MUL);\n      }\n    },\n    signatureNormalize: function signatureNormalize(sig) {\n      isUint8Array('signature', sig, 64);\n\n      switch (secp256k1.signatureNormalize(sig)) {\n        case 0:\n          return sig;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n      }\n    },\n    signatureExport: function signatureExport(sig, output) {\n      isUint8Array('signature', sig, 64);\n      output = getAssertedOutput(output, 72);\n      var obj = {\n        output: output,\n        outputlen: 72\n      };\n\n      switch (secp256k1.signatureExport(obj, sig)) {\n        case 0:\n          return output.slice(0, obj.outputlen);\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    signatureImport: function signatureImport(sig, output) {\n      isUint8Array('signature', sig);\n      output = getAssertedOutput(output, 64);\n\n      switch (secp256k1.signatureImport(output, sig)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    ecdsaSign: function ecdsaSign(msg32, seckey) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('message', msg32, 32);\n      isUint8Array('private key', seckey, 32);\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');\n      if (options.data !== undefined) isUint8Array('options.data', options.data);\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function');\n      output = getAssertedOutput(output, 64);\n      var obj = {\n        signature: output,\n        recid: null\n      };\n\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\n        case 0:\n          return obj;\n\n        case 1:\n          throw new Error(errors.SIGN);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    ecdsaVerify: function ecdsaVerify(sig, msg32, pubkey) {\n      isUint8Array('signature', sig, 64);\n      isUint8Array('message', msg32, 32);\n      isUint8Array('public key', pubkey, [33, 65]);\n\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\n        case 0:\n          return true;\n\n        case 3:\n          return false;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.PUBKEY_PARSE);\n      }\n    },\n    ecdsaRecover: function ecdsaRecover(sig, recid, msg32) {\n      var compressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var output = arguments.length > 4 ? arguments[4] : undefined;\n      isUint8Array('signature', sig, 64);\n      assert(toTypeString(recid) === 'Number' && recid >= 0 && recid <= 3, 'Expected recovery id to be a Number within interval [0, 3]');\n      isUint8Array('message', msg32, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.RECOVER);\n\n        case 3:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    ecdh: function ecdh(pubkey, seckey) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('private key', seckey, 32);\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');\n      if (options.data !== undefined) isUint8Array('options.data', options.data);\n\n      if (options.hashfn !== undefined) {\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function');\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32);\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32);\n        isUint8Array('output', output);\n      } else {\n        output = getAssertedOutput(output, 32);\n      }\n\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.ECDH);\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/secp256k1/lib/index.js"],"names":["errors","IMPOSSIBLE_CASE","TWEAK_ADD","TWEAK_MUL","CONTEXT_RANDOMIZE_UNKNOW","SECKEY_INVALID","PUBKEY_PARSE","PUBKEY_SERIALIZE","PUBKEY_COMBINE","SIG_PARSE","SIGN","RECOVER","ECDH","assert","cond","msg","Error","isUint8Array","name","value","length","Uint8Array","undefined","Array","isArray","numbers","join","includes","isCompressed","toTypeString","getAssertedOutput","output","len","Object","prototype","toString","call","slice","module","exports","secp256k1","contextRandomize","seed","privateKeyVerify","seckey","privateKeyNegate","privateKeyTweakAdd","tweak","privateKeyTweakMul","publicKeyVerify","pubkey","publicKeyCreate","compressed","publicKeyConvert","publicKeyNegate","publicKeyCombine","pubkeys","publicKeyTweakAdd","publicKeyTweakMul","signatureNormalize","sig","signatureExport","obj","outputlen","signatureImport","ecdsaSign","msg32","options","data","noncefn","signature","recid","ecdsaVerify","ecdsaRecover","ecdh","hashfn","xbuf","ybuf"],"mappings":"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","sourcesContent":["const errors = {\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\n  TWEAK_ADD:\n    'The tweak was out of range or the resulted private key is invalid',\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\n  SECKEY_INVALID: 'Private Key is invalid',\n  PUBKEY_PARSE: 'Public Key could not be parsed',\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\n  SIG_PARSE: 'Signature could not be parsed',\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\n  RECOVER: 'Public key could not be recover',\n  ECDH: 'Scalar was invalid (zero or overflow)'\n}\n\nfunction assert (cond, msg) {\n  if (!cond) throw new Error(msg)\n}\n\nfunction isUint8Array (name, value, length) {\n  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)\n\n  if (length !== undefined) {\n    if (Array.isArray(length)) {\n      const numbers = length.join(', ')\n      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`\n      assert(length.includes(value.length), msg)\n    } else {\n      const msg = `Expected ${name} to be an Uint8Array with length ${length}`\n      assert(value.length === length, msg)\n    }\n  }\n}\n\nfunction isCompressed (value) {\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')\n}\n\nfunction getAssertedOutput (output = (len) => new Uint8Array(len), length) {\n  if (typeof output === 'function') output = output(length)\n  isUint8Array('output', output, length)\n  return output\n}\n\nfunction toTypeString (value) {\n  return Object.prototype.toString.call(value).slice(8, -1)\n}\n\nmodule.exports = (secp256k1) => {\n  return {\n    contextRandomize (seed) {\n      assert(\n        seed === null || seed instanceof Uint8Array,\n        'Expected seed to be an Uint8Array or null'\n      )\n      if (seed !== null) isUint8Array('seed', seed, 32)\n\n      switch (secp256k1.contextRandomize(seed)) {\n        case 1:\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)\n      }\n    },\n\n    privateKeyVerify (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      return secp256k1.privateKeyVerify(seckey) === 0\n    },\n\n    privateKeyNegate (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      switch (secp256k1.privateKeyNegate(seckey)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    privateKeyTweakAdd (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    privateKeyTweakMul (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    publicKeyVerify (pubkey) {\n      isUint8Array('public key', pubkey, [33, 65])\n\n      return secp256k1.publicKeyVerify(pubkey) === 0\n    },\n\n    publicKeyCreate (seckey, compressed = true, output) {\n      isUint8Array('private key', seckey, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SECKEY_INVALID)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyConvert (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyNegate (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyCombine (pubkeys, compressed = true, output) {\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')\n      for (const pubkey of pubkeys) {\n        isUint8Array('public key', pubkey, [33, 65])\n      }\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_COMBINE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    signatureNormalize (sig) {\n      isUint8Array('signature', sig, 64)\n\n      switch (secp256k1.signatureNormalize(sig)) {\n        case 0:\n          return sig\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n      }\n    },\n\n    signatureExport (sig, output) {\n      isUint8Array('signature', sig, 64)\n      output = getAssertedOutput(output, 72)\n\n      const obj = { output, outputlen: 72 }\n      switch (secp256k1.signatureExport(obj, sig)) {\n        case 0:\n          return output.slice(0, obj.outputlen)\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    signatureImport (sig, output) {\n      isUint8Array('signature', sig)\n      output = getAssertedOutput(output, 64)\n\n      switch (secp256k1.signatureImport(output, sig)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaSign (msg32, seckey, options = {}, output) {\n      isUint8Array('message', msg32, 32)\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')\n      output = getAssertedOutput(output, 64)\n\n      const obj = { signature: output, recid: null }\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\n        case 0:\n          return obj\n        case 1:\n          throw new Error(errors.SIGN)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaVerify (sig, msg32, pubkey) {\n      isUint8Array('signature', sig, 64)\n      isUint8Array('message', msg32, 32)\n      isUint8Array('public key', pubkey, [33, 65])\n\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\n        case 0:\n          return true\n        case 3:\n          return false\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_PARSE)\n      }\n    },\n\n    ecdsaRecover (sig, recid, msg32, compressed = true, output) {\n      isUint8Array('signature', sig, 64)\n      assert(\n        toTypeString(recid) === 'Number' &&\n          recid >= 0 &&\n          recid <= 3,\n        'Expected recovery id to be a Number within interval [0, 3]'\n      )\n      isUint8Array('message', msg32, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.RECOVER)\n        case 3:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdh (pubkey, seckey, options = {}, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.hashfn !== undefined) {\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)\n        isUint8Array('output', output)\n      } else {\n        output = getAssertedOutput(output, 32)\n      }\n\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.ECDH)\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
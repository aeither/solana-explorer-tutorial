{"ast":null,"code":"import { linear } from './index.js';\n\nvar a = function a(a1, a2) {\n  return 1.0 - 3.0 * a2 + 3.0 * a1;\n};\n\nvar b = function b(a1, a2) {\n  return 3.0 * a2 - 6.0 * a1;\n};\n\nvar c = function c(a1) {\n  return 3.0 * a1;\n};\n\nvar calcBezier = function calcBezier(t, a1, a2) {\n  return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n};\n\nvar getSlope = function getSlope(t, a1, a2) {\n  return 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\n};\n\nvar subdivisionPrecision = 0.0000001;\nvar subdivisionMaxIterations = 10;\n\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  var currentX;\n  var currentT;\n  var i = 0;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);\n\n  return currentT;\n}\n\nvar newtonIterations = 8;\nvar newtonMinSlope = 0.001;\n\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (var i = 0; i < newtonIterations; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n  if (mX1 === mY1 && mX2 === mY2) return linear;\n  var sampleValues = new Float32Array(kSplineTableSize);\n\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample;\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= newtonMinSlope) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function (t) {\n    return t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n  };\n}\n\nexport { cubicBezier };","map":{"version":3,"sources":["/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/popmotion/dist/es/easing/cubic-bezier.js"],"names":["linear","a","a1","a2","b","c","calcBezier","t","getSlope","subdivisionPrecision","subdivisionMaxIterations","binarySubdivide","aX","aA","aB","mX1","mX2","currentX","currentT","i","Math","abs","newtonIterations","newtonMinSlope","newtonRaphsonIterate","aGuessT","currentSlope","kSplineTableSize","kSampleStepSize","cubicBezier","mY1","mY2","sampleValues","Float32Array","getTForX","intervalStart","currentSample","lastSample","dist","guessForT","initialSlope"],"mappings":"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","sourcesContent":["import { linear } from './index.js';\n\nvar a = function (a1, a2) { return 1.0 - 3.0 * a2 + 3.0 * a1; };\nvar b = function (a1, a2) { return 3.0 * a2 - 6.0 * a1; };\nvar c = function (a1) { return 3.0 * a1; };\nvar calcBezier = function (t, a1, a2) {\n    return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n};\nvar getSlope = function (t, a1, a2) {\n    return 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\n};\nvar subdivisionPrecision = 0.0000001;\nvar subdivisionMaxIterations = 10;\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n    var currentX;\n    var currentT;\n    var i = 0;\n    do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0.0) {\n            aB = currentT;\n        }\n        else {\n            aA = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nvar newtonIterations = 8;\nvar newtonMinSlope = 0.001;\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n    for (var i = 0; i < newtonIterations; ++i) {\n        var currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0.0) {\n            return aGuessT;\n        }\n        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    if (mX1 === mY1 && mX2 === mY2)\n        return linear;\n    var sampleValues = new Float32Array(kSplineTableSize);\n    for (var i = 0; i < kSplineTableSize; ++i) {\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n    function getTForX(aX) {\n        var intervalStart = 0.0;\n        var currentSample = 1;\n        var lastSample = kSplineTableSize - 1;\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        var dist = (aX - sampleValues[currentSample]) /\n            (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        var guessForT = intervalStart + dist * kSampleStepSize;\n        var initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= newtonMinSlope) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n        else if (initialSlope === 0.0) {\n            return guessForT;\n        }\n        else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n        }\n    }\n    return function (t) {\n        return t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n    };\n}\n\nexport { cubicBezier };\n"]},"metadata":{},"sourceType":"module"}
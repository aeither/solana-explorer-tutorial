{"ast":null,"code":"import _slicedToArray from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport { useBoolean, useCallbackRef, useControllableState, useDimensions, useIds, useLatestRef, usePanGesture, useUpdateEffect } from \"@chakra-ui/hooks\";\nimport { mergeRefs } from \"@chakra-ui/react-utils\";\nimport { ariaAttr, callAllHandlers, clampValue, dataAttr, focus, getBox, normalizeEventKey, percentToValue, roundValueToStep, valueToPercent } from \"@chakra-ui/utils\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { getPartsStyle } from \"./slider-utils\";\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\n\nexport function useSlider(props) {\n  var _getAriaValueText;\n\n  var _props$min = props.min,\n      min = _props$min === void 0 ? 0 : _props$min,\n      _props$max = props.max,\n      max = _props$max === void 0 ? 100 : _props$max,\n      onChange = props.onChange,\n      valueProp = props.value,\n      defaultValue = props.defaultValue,\n      isReversed = props.isReversed,\n      _props$orientation = props.orientation,\n      orientation = _props$orientation === void 0 ? \"horizontal\" : _props$orientation,\n      idProp = props.id,\n      isDisabled = props.isDisabled,\n      isReadOnly = props.isReadOnly,\n      onChangeStartProp = props.onChangeStart,\n      onChangeEndProp = props.onChangeEnd,\n      _props$step = props.step,\n      step = _props$step === void 0 ? 1 : _props$step,\n      getAriaValueTextProp = props.getAriaValueText,\n      ariaValueText = props[\"aria-valuetext\"],\n      ariaLabel = props[\"aria-label\"],\n      ariaLabelledBy = props[\"aria-labelledby\"],\n      name = props.name,\n      _props$focusThumbOnCh = props.focusThumbOnChange,\n      focusThumbOnChange = _props$focusThumbOnCh === void 0 ? true : _props$focusThumbOnCh,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"min\", \"max\", \"onChange\", \"value\", \"defaultValue\", \"isReversed\", \"orientation\", \"id\", \"isDisabled\", \"isReadOnly\", \"onChangeStart\", \"onChangeEnd\", \"step\", \"getAriaValueText\", \"aria-valuetext\", \"aria-label\", \"aria-labelledby\", \"name\", \"focusThumbOnChange\"]);\n\n  var onChangeStart = useCallbackRef(onChangeStartProp);\n  var onChangeEnd = useCallbackRef(onChangeEndProp);\n  var getAriaValueText = useCallbackRef(getAriaValueTextProp);\n  /**\n   * Enable the slider handle controlled and uncontrolled scenarios\n   */\n\n  var _useControllableState = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue != null ? defaultValue : getDefaultValue(min, max),\n    onChange: onChange\n  }),\n      _useControllableState2 = _slicedToArray(_useControllableState, 2),\n      computedValue = _useControllableState2[0],\n      setValue = _useControllableState2[1];\n\n  var _useBoolean = useBoolean(),\n      _useBoolean2 = _slicedToArray(_useBoolean, 2),\n      isDragging = _useBoolean2[0],\n      setDragging = _useBoolean2[1];\n\n  var _useBoolean3 = useBoolean(),\n      _useBoolean4 = _slicedToArray(_useBoolean3, 2),\n      isFocused = _useBoolean4[0],\n      setFocused = _useBoolean4[1];\n\n  var eventSourceRef = useRef(null);\n  var isInteractive = !(isDisabled || isReadOnly);\n  /**\n   * Constrain the value because it can't be less than min\n   * or greater than max\n   */\n\n  var value = clampValue(computedValue, min, max);\n  var valueRef = useLatestRef(value);\n  var prevRef = useRef(valueRef.current);\n  var reversedValue = max - value + min;\n  var trackValue = isReversed ? reversedValue : value;\n  var trackPercent = valueToPercent(trackValue, min, max);\n  var isVertical = orientation === \"vertical\";\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n\n  var trackRef = useRef(null);\n  var thumbRef = useRef(null);\n  var rootRef = useRef(null);\n  /**\n   * Generate unique ids for component parts\n   */\n\n  var _useIds = useIds(idProp, \"slider-thumb\", \"slider-track\"),\n      _useIds2 = _slicedToArray(_useIds, 2),\n      thumbId = _useIds2[0],\n      trackId = _useIds2[1];\n  /**\n   * Get relative value of slider from the event by tracking\n   * how far you clicked within the track to determine the value\n   *\n   * @todo - Refactor this later on to use info from pan session\n   */\n\n\n  var getValueFromPointer = useCallback(function (event) {\n    var _event$touches$, _event$touches;\n\n    if (!trackRef.current) return;\n    eventSourceRef.current = \"pointer\";\n    var trackRect = getBox(trackRef.current).borderBox;\n\n    var _ref = (_event$touches$ = (_event$touches = event.touches) == null ? void 0 : _event$touches[0]) != null ? _event$touches$ : event,\n        clientX = _ref.clientX,\n        clientY = _ref.clientY;\n\n    var diff = isVertical ? trackRect.bottom - clientY : clientX - trackRect.left;\n    var length = isVertical ? trackRect.height : trackRect.width;\n    var percent = diff / length;\n\n    if (isReversed) {\n      percent = 1 - percent;\n    }\n\n    var nextValue = percentToValue(percent, min, max);\n\n    if (step) {\n      nextValue = parseFloat(roundValueToStep(nextValue, min, step));\n    }\n\n    nextValue = clampValue(nextValue, min, max);\n    return nextValue;\n  }, [isVertical, isReversed, max, min, step]);\n  var tenSteps = (max - min) / 10;\n  var oneStep = step || (max - min) / 100;\n  var constrain = useCallback(function (value) {\n    if (!isInteractive) return;\n    value = parseFloat(roundValueToStep(value, min, oneStep));\n    value = clampValue(value, min, max);\n    setValue(value);\n  }, [oneStep, max, min, setValue, isInteractive]);\n  var actions = useMemo(function () {\n    return {\n      stepUp: function stepUp(step) {\n        if (step === void 0) {\n          step = oneStep;\n        }\n\n        var next = isReversed ? value - step : value + step;\n        constrain(next);\n      },\n      stepDown: function stepDown(step) {\n        if (step === void 0) {\n          step = oneStep;\n        }\n\n        var next = isReversed ? value + step : value - step;\n        constrain(next);\n      },\n      reset: function reset() {\n        return constrain(defaultValue || 0);\n      },\n      stepTo: function stepTo(value) {\n        return constrain(value);\n      }\n    };\n  }, [constrain, isReversed, value, oneStep, defaultValue]);\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n\n  var onKeyDown = useCallback(function (event) {\n    var eventKey = normalizeEventKey(event);\n    var keyMap = {\n      ArrowRight: function ArrowRight() {\n        return actions.stepUp();\n      },\n      ArrowUp: function ArrowUp() {\n        return actions.stepUp();\n      },\n      ArrowLeft: function ArrowLeft() {\n        return actions.stepDown();\n      },\n      ArrowDown: function ArrowDown() {\n        return actions.stepDown();\n      },\n      PageUp: function PageUp() {\n        return actions.stepUp(tenSteps);\n      },\n      PageDown: function PageDown() {\n        return actions.stepDown(tenSteps);\n      },\n      Home: function Home() {\n        return constrain(min);\n      },\n      End: function End() {\n        return constrain(max);\n      }\n    };\n    var action = keyMap[eventKey];\n\n    if (action) {\n      event.preventDefault();\n      event.stopPropagation();\n      action(event);\n      eventSourceRef.current = \"keyboard\";\n    }\n  }, [actions, constrain, max, min, tenSteps]);\n  /**\n   * ARIA (Optional): To define a human readable representation of the value,\n   * we allow users pass aria-valuetext.\n   */\n\n  var valueText = (_getAriaValueText = getAriaValueText == null ? void 0 : getAriaValueText(value)) != null ? _getAriaValueText : ariaValueText;\n  /**\n   * Measure the dimensions of the thumb so\n   * we can center it within the track properly\n   */\n\n  var thumbBoxModel = useDimensions(thumbRef);\n  /**\n   * Compute styles for all component parts.\n   */\n\n  var _useMemo = useMemo(function () {\n    var _thumbBoxModel$border;\n\n    var thumbRect = (_thumbBoxModel$border = thumbBoxModel == null ? void 0 : thumbBoxModel.borderBox) != null ? _thumbBoxModel$border : {\n      width: 0,\n      height: 0\n    };\n    return getPartsStyle({\n      isReversed: isReversed,\n      orientation: orientation,\n      thumbRect: thumbRect,\n      trackPercent: trackPercent\n    });\n  }, [isReversed, orientation, thumbBoxModel == null ? void 0 : thumbBoxModel.borderBox, trackPercent]),\n      thumbStyle = _useMemo.thumbStyle,\n      rootStyle = _useMemo.rootStyle,\n      trackStyle = _useMemo.trackStyle,\n      innerTrackStyle = _useMemo.innerTrackStyle;\n\n  var focusThumb = useCallback(function () {\n    if (thumbRef.current && focusThumbOnChange) {\n      setTimeout(function () {\n        return focus(thumbRef.current);\n      });\n    }\n  }, [focusThumbOnChange]);\n  useUpdateEffect(function () {\n    focusThumb();\n\n    if (eventSourceRef.current === \"keyboard\") {\n      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);\n    }\n  }, [value, onChangeEnd]);\n\n  var setValueFromPointer = function setValueFromPointer(event) {\n    var nextValue = getValueFromPointer(event);\n\n    if (nextValue != null && nextValue !== valueRef.current) {\n      setValue(nextValue);\n    }\n  };\n\n  usePanGesture(rootRef, {\n    onPanSessionStart: function onPanSessionStart(event) {\n      if (!isInteractive) return;\n      setDragging.on();\n      focusThumb();\n      setValueFromPointer(event);\n      onChangeStart == null ? void 0 : onChangeStart(valueRef.current);\n    },\n    onPanSessionEnd: function onPanSessionEnd() {\n      if (!isInteractive) return;\n      setDragging.off();\n      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);\n      prevRef.current = valueRef.current;\n    },\n    onPan: function onPan(event) {\n      if (!isInteractive) return;\n      setValueFromPointer(event);\n    }\n  });\n  var getRootProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, htmlProps, {\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: _extends({}, props.style, rootStyle)\n    });\n  }, [htmlProps, isDisabled, isFocused, rootStyle]);\n  var getTrackProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref: mergeRefs(ref, trackRef),\n      id: trackId,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: _extends({}, props.style, trackStyle)\n    });\n  }, [isDisabled, trackId, trackStyle]);\n  var getInnerTrackProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref: ref,\n      style: _extends({}, props.style, innerTrackStyle)\n    });\n  }, [innerTrackStyle]);\n  var getThumbProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref: mergeRefs(ref, thumbRef),\n      role: \"slider\",\n      tabIndex: isInteractive ? 0 : undefined,\n      id: thumbId,\n      \"data-active\": dataAttr(isDragging),\n      \"aria-valuetext\": valueText,\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy,\n      style: _extends({}, props.style, thumbStyle),\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props.onFocus, setFocused.on),\n      onBlur: callAllHandlers(props.onBlur, setFocused.off)\n    });\n  }, [ariaLabel, ariaLabelledBy, isDisabled, isDragging, isReadOnly, isInteractive, max, min, onKeyDown, orientation, setFocused.off, setFocused.on, thumbId, thumbStyle, value, valueText]);\n  var getMarkerProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    var isInRange = !(props.value < min || props.value > max);\n    var isHighlighted = value >= props.value;\n    var markerPercent = valueToPercent(props.value, min, max);\n\n    var markerStyle = _extends({\n      position: \"absolute\",\n      pointerEvents: \"none\"\n    }, orient({\n      orientation: orientation,\n      vertical: {\n        bottom: isReversed ? 100 - markerPercent + \"%\" : markerPercent + \"%\"\n      },\n      horizontal: {\n        left: isReversed ? 100 - markerPercent + \"%\" : markerPercent + \"%\"\n      }\n    }));\n\n    return _extends({}, props, {\n      ref: ref,\n      role: \"presentation\",\n      \"aria-hidden\": true,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(!isInRange),\n      \"data-highlighted\": dataAttr(isHighlighted),\n      style: _extends({}, props.style, markerStyle)\n    });\n  }, [isDisabled, isReversed, max, min, orientation, value]);\n  var getInputProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref: ref,\n      type: \"hidden\",\n      value: value,\n      name: name\n    });\n  }, [name, value]);\n  return {\n    state: {\n      value: value,\n      isFocused: isFocused,\n      isDragging: isDragging\n    },\n    actions: actions,\n    getRootProps: getRootProps,\n    getTrackProps: getTrackProps,\n    getInnerTrackProps: getInnerTrackProps,\n    getThumbProps: getThumbProps,\n    getMarkerProps: getMarkerProps,\n    getInputProps: getInputProps\n  };\n}\n\nfunction orient(options) {\n  var orientation = options.orientation,\n      vertical = options.vertical,\n      horizontal = options.horizontal;\n  return orientation === \"vertical\" ? vertical : horizontal;\n}\n/**\n * The browser <input type=\"range\" /> calculates\n * the default value of a slider by using mid-point\n * between the min and the max.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range\n */\n\n\nfunction getDefaultValue(min, max) {\n  return max < min ? min : min + (max - min) / 2;\n}","map":{"version":3,"sources":["../../src/use-slider.ts"],"names":["min","max","value","orientation","id","onChangeStart","onChangeEnd","step","getAriaValueText","focusThumbOnChange","useCallbackRef","useControllableState","defaultValue","getDefaultValue","onChange","useBoolean","eventSourceRef","useRef","isInteractive","isDisabled","clampValue","valueRef","useLatestRef","prevRef","reversedValue","trackValue","isReversed","trackPercent","valueToPercent","isVertical","trackRef","thumbRef","rootRef","useIds","getValueFromPointer","useCallback","event","trackRect","getBox","clientY","diff","clientX","length","percent","nextValue","percentToValue","parseFloat","roundValueToStep","tenSteps","oneStep","constrain","setValue","actions","useMemo","stepUp","next","stepDown","reset","stepTo","onKeyDown","eventKey","normalizeEventKey","keyMap","ArrowRight","ArrowUp","ArrowLeft","ArrowDown","PageUp","PageDown","Home","End","action","valueText","thumbBoxModel","useDimensions","innerTrackStyle","thumbRect","width","height","getPartsStyle","focusThumb","setTimeout","focus","useUpdateEffect","setValueFromPointer","usePanGesture","onPanSessionStart","setDragging","onPanSessionEnd","onPan","getRootProps","props","ref","mergeRefs","tabIndex","ariaAttr","dataAttr","style","getTrackProps","getInnerTrackProps","getThumbProps","role","ariaLabel","callAllHandlers","onFocus","setFocused","onBlur","getMarkerProps","isInRange","isHighlighted","markerPercent","markerStyle","position","pointerEvents","orient","vertical","bottom","horizontal","left","getInputProps","type","name","state","isFocused","isDragging"],"mappings":"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","sourcesContent":["import {\n  useBoolean,\n  useCallbackRef,\n  useControllableState,\n  useDimensions,\n  useIds,\n  useLatestRef,\n  usePanGesture,\n  useUpdateEffect,\n} from \"@chakra-ui/hooks\"\nimport { EventKeyMap, mergeRefs, PropGetter } from \"@chakra-ui/react-utils\"\nimport {\n  AnyPointerEvent,\n  ariaAttr,\n  callAllHandlers,\n  clampValue,\n  dataAttr,\n  focus,\n  getBox,\n  normalizeEventKey,\n  percentToValue,\n  roundValueToStep,\n  valueToPercent,\n} from \"@chakra-ui/utils\"\nimport { CSSProperties, useCallback, useMemo, useRef } from \"react\"\nimport { getPartsStyle } from \"./slider-utils\"\n\nexport interface UseSliderProps {\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   * @default 0\n   */\n  min?: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   * @default 100\n   */\n  max?: number\n  /**\n   * The step in which increments/decrements have to be made\n   * @default 1\n   */\n  step?: number\n  /**\n   * The value of the slider in controlled mode\n   */\n  value?: number\n  /**\n   * The initial value of the slider in uncontrolled mode\n   */\n  defaultValue?: number\n  /**\n   * orientation of the slider\n   * @default \"horizontal\"\n   */\n  orientation?: \"horizontal\" | \"vertical\"\n  /**\n   * If `true`, the value will be incremented or decremented in reverse.\n   */\n  isReversed?: boolean\n  /**\n   * Function called when the user starts selecting a new value (by dragging or clicking)\n   */\n  onChangeStart?(value: number): void\n  /**\n   * Function called when the user is done selecting a new value (by dragging or clicking)\n   */\n  onChangeEnd?(value: number): void\n  /**\n   * Function called whenever the slider value changes  (by dragging or clicking)\n   */\n  onChange?(value: number): void\n  /**\n   * The base `id` to use for the slider and its components\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms\n   */\n  name?: string\n  /**\n   * If `true`, the slider will be disabled\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the slider will be in `read-only` state\n   */\n  isReadOnly?: boolean\n  /**\n   * Function that returns the `aria-valuetext` for screen readers.\n   * It is mostly used to generate a more human-readable\n   * representation of the value for assistive technologies\n   */\n  getAriaValueText?(value: number): string\n  /**\n   * If `false`, the slider handle will not capture focus when value changes.\n   * @default true\n   */\n  focusThumbOnChange?: boolean\n  /**\n   * The static string to use used for `aria-valuetext`\n   */\n  \"aria-valuetext\"?: string\n  /**\n   * The static string to use used for `aria-label`\n   * if no visible label is used.\n   */\n  \"aria-label\"?: string\n  /**\n   * The static string `aria-labelledby` that points to the\n   * ID of the element that serves as label for the slider\n   */\n  \"aria-labelledby\"?: string\n}\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\nexport function useSlider(props: UseSliderProps) {\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed,\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    ...htmlProps\n  } = props\n\n  const onChangeStart = useCallbackRef(onChangeStartProp)\n  const onChangeEnd = useCallbackRef(onChangeEndProp)\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp)\n\n  /**\n   * Enable the slider handle controlled and uncontrolled scenarios\n   */\n  const [computedValue, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? getDefaultValue(min, max),\n    onChange,\n  })\n\n  const [isDragging, setDragging] = useBoolean()\n\n  const [isFocused, setFocused] = useBoolean()\n  const eventSourceRef = useRef<\"pointer\" | \"keyboard\" | null>(null)\n\n  const isInteractive = !(isDisabled || isReadOnly)\n\n  /**\n   * Constrain the value because it can't be less than min\n   * or greater than max\n   */\n  const value = clampValue(computedValue, min, max)\n  const valueRef = useLatestRef(value)\n\n  const prevRef = useRef(valueRef.current)\n\n  const reversedValue = max - value + min\n  const trackValue = isReversed ? reversedValue : value\n  const trackPercent = valueToPercent(trackValue, min, max)\n\n  const isVertical = orientation === \"vertical\"\n\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n  const trackRef = useRef<any>(null)\n  const thumbRef = useRef<any>(null)\n  const rootRef = useRef<any>(null)\n\n  /**\n   * Generate unique ids for component parts\n   */\n  const [thumbId, trackId] = useIds(idProp, `slider-thumb`, `slider-track`)\n\n  /**\n   * Get relative value of slider from the event by tracking\n   * how far you clicked within the track to determine the value\n   *\n   * @todo - Refactor this later on to use info from pan session\n   */\n\n  const getValueFromPointer = useCallback(\n    (event) => {\n      if (!trackRef.current) return\n      eventSourceRef.current = \"pointer\"\n      const trackRect = getBox(trackRef.current).borderBox\n      const { clientX, clientY } = event.touches?.[0] ?? event\n\n      const diff = isVertical\n        ? trackRect.bottom - clientY\n        : clientX - trackRect.left\n\n      const length = isVertical ? trackRect.height : trackRect.width\n      let percent = diff / length\n\n      if (isReversed) {\n        percent = 1 - percent\n      }\n\n      let nextValue = percentToValue(percent, min, max)\n\n      if (step) {\n        nextValue = parseFloat(roundValueToStep(nextValue, min, step))\n      }\n\n      nextValue = clampValue(nextValue, min, max)\n\n      return nextValue\n    },\n    [isVertical, isReversed, max, min, step],\n  )\n\n  const tenSteps = (max - min) / 10\n  const oneStep = step || (max - min) / 100\n\n  const constrain = useCallback(\n    (value: number) => {\n      if (!isInteractive) return\n      value = parseFloat(roundValueToStep(value, min, oneStep))\n      value = clampValue(value, min, max)\n      setValue(value)\n    },\n    [oneStep, max, min, setValue, isInteractive],\n  )\n\n  const actions = useMemo(\n    () => ({\n      stepUp: (step = oneStep) => {\n        const next = isReversed ? value - step : value + step\n        constrain(next)\n      },\n      stepDown: (step = oneStep) => {\n        const next = isReversed ? value + step : value - step\n        constrain(next)\n      },\n      reset: () => constrain(defaultValue || 0),\n      stepTo: (value: number) => constrain(value),\n    }),\n    [constrain, isReversed, value, oneStep, defaultValue],\n  )\n\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = normalizeEventKey(event)\n      const keyMap: EventKeyMap = {\n        ArrowRight: () => actions.stepUp(),\n        ArrowUp: () => actions.stepUp(),\n        ArrowLeft: () => actions.stepDown(),\n        ArrowDown: () => actions.stepDown(),\n        PageUp: () => actions.stepUp(tenSteps),\n        PageDown: () => actions.stepDown(tenSteps),\n        Home: () => constrain(min),\n        End: () => constrain(max),\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        event.stopPropagation()\n        action(event)\n        eventSourceRef.current = \"keyboard\"\n      }\n    },\n    [actions, constrain, max, min, tenSteps],\n  )\n\n  /**\n   * ARIA (Optional): To define a human readable representation of the value,\n   * we allow users pass aria-valuetext.\n   */\n  const valueText = getAriaValueText?.(value) ?? ariaValueText\n\n  /**\n   * Measure the dimensions of the thumb so\n   * we can center it within the track properly\n   */\n  const thumbBoxModel = useDimensions(thumbRef)\n\n  /**\n   * Compute styles for all component parts.\n   */\n  const { thumbStyle, rootStyle, trackStyle, innerTrackStyle } = useMemo(() => {\n    const thumbRect = thumbBoxModel?.borderBox ?? { width: 0, height: 0 }\n    return getPartsStyle({\n      isReversed,\n      orientation,\n      thumbRect,\n      trackPercent,\n    })\n  }, [isReversed, orientation, thumbBoxModel?.borderBox, trackPercent])\n\n  const focusThumb = useCallback(() => {\n    if (thumbRef.current && focusThumbOnChange) {\n      setTimeout(() => focus(thumbRef.current))\n    }\n  }, [focusThumbOnChange])\n\n  useUpdateEffect(() => {\n    focusThumb()\n    if (eventSourceRef.current === \"keyboard\") {\n      onChangeEnd?.(valueRef.current)\n    }\n  }, [value, onChangeEnd])\n\n  const setValueFromPointer = (event: AnyPointerEvent) => {\n    const nextValue = getValueFromPointer(event)\n    if (nextValue != null && nextValue !== valueRef.current) {\n      setValue(nextValue)\n    }\n  }\n\n  usePanGesture(rootRef, {\n    onPanSessionStart(event) {\n      if (!isInteractive) return\n      setDragging.on()\n      focusThumb()\n      setValueFromPointer(event)\n      onChangeStart?.(valueRef.current)\n    },\n    onPanSessionEnd() {\n      if (!isInteractive) return\n      setDragging.off()\n      onChangeEnd?.(valueRef.current)\n      prevRef.current = valueRef.current\n    },\n    onPan(event) {\n      if (!isInteractive) return\n      setValueFromPointer(event)\n    },\n  })\n\n  const getRootProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ...htmlProps,\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: {\n        ...props.style,\n        ...rootStyle,\n      },\n    }),\n    [htmlProps, isDisabled, isFocused, rootStyle],\n  )\n\n  const getTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref: mergeRefs(ref, trackRef),\n      id: trackId,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: {\n        ...props.style,\n        ...trackStyle,\n      },\n    }),\n    [isDisabled, trackId, trackStyle],\n  )\n\n  const getInnerTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref,\n      style: {\n        ...props.style,\n        ...innerTrackStyle,\n      },\n    }),\n    [innerTrackStyle],\n  )\n\n  const getThumbProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref: mergeRefs(ref, thumbRef),\n      role: \"slider\",\n      tabIndex: isInteractive ? 0 : undefined,\n      id: thumbId,\n      \"data-active\": dataAttr(isDragging),\n      \"aria-valuetext\": valueText,\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy,\n      style: {\n        ...props.style,\n        ...thumbStyle,\n      },\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props.onFocus, setFocused.on),\n      onBlur: callAllHandlers(props.onBlur, setFocused.off),\n    }),\n    [\n      ariaLabel,\n      ariaLabelledBy,\n      isDisabled,\n      isDragging,\n      isReadOnly,\n      isInteractive,\n      max,\n      min,\n      onKeyDown,\n      orientation,\n      setFocused.off,\n      setFocused.on,\n      thumbId,\n      thumbStyle,\n      value,\n      valueText,\n    ],\n  )\n\n  const getMarkerProps: PropGetter<any, { value?: any }> = useCallback(\n    (props = {}, ref = null) => {\n      const isInRange = !(props.value < min || props.value > max)\n      const isHighlighted = value >= props.value\n      const markerPercent = valueToPercent(props.value, min, max)\n\n      const markerStyle: React.CSSProperties = {\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        ...orient({\n          orientation,\n          vertical: {\n            bottom: isReversed\n              ? `${100 - markerPercent}%`\n              : `${markerPercent}%`,\n          },\n          horizontal: {\n            left: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`,\n          },\n        }),\n      }\n\n      return {\n        ...props,\n        ref,\n        role: \"presentation\",\n        \"aria-hidden\": true,\n        \"data-disabled\": dataAttr(isDisabled),\n        \"data-invalid\": dataAttr(!isInRange),\n        \"data-highlighted\": dataAttr(isHighlighted),\n        style: {\n          ...props.style,\n          ...markerStyle,\n        },\n      }\n    },\n    [isDisabled, isReversed, max, min, orientation, value],\n  )\n\n  const getInputProps: PropGetter<HTMLInputElement> = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref,\n      type: \"hidden\",\n      value,\n      name,\n    }),\n    [name, value],\n  )\n\n  return {\n    state: {\n      value,\n      isFocused,\n      isDragging,\n    },\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n  }\n}\n\nexport type UseSliderReturn = ReturnType<typeof useSlider>\n\nfunction orient(options: {\n  orientation: UseSliderProps[\"orientation\"]\n  vertical: CSSProperties\n  horizontal: CSSProperties\n}) {\n  const { orientation, vertical, horizontal } = options\n  return orientation === \"vertical\" ? vertical : horizontal\n}\n\n/**\n * The browser <input type=\"range\" /> calculates\n * the default value of a slider by using mid-point\n * between the min and the max.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range\n */\nfunction getDefaultValue(min: number, max: number) {\n  return max < min ? min : min + (max - min) / 2\n}\n"]},"metadata":{},"sourceType":"module"}
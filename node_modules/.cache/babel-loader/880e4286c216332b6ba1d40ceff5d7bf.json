{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _slicedToArray = require(\"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar bs58_1 = __importDefault(require(\"bs58\")); // TODO: Make sure this polyfill not included when not required\n\n\nvar encoding = __importStar(require(\"text-encoding-utf-8\"));\n\nvar TextDecoder = typeof global.TextDecoder !== 'function' ? encoding.TextDecoder : global.TextDecoder;\nvar textDecoder = new TextDecoder('utf-8', {\n  fatal: true\n});\n\nfunction baseEncode(value) {\n  if (typeof value === 'string') {\n    value = Buffer.from(value, 'utf8');\n  }\n\n  return bs58_1.default.encode(Buffer.from(value));\n}\n\nexports.baseEncode = baseEncode;\n\nfunction baseDecode(value) {\n  return Buffer.from(bs58_1.default.decode(value));\n}\n\nexports.baseDecode = baseDecode;\nvar INITIAL_LENGTH = 1024;\n\nvar BorshError = /*#__PURE__*/function (_Error) {\n  _inherits(BorshError, _Error);\n\n  var _super = _createSuper(BorshError);\n\n  function BorshError(message) {\n    var _this;\n\n    _classCallCheck(this, BorshError);\n\n    _this = _super.call(this, message);\n    _this.fieldPath = [];\n    _this.originalMessage = message;\n    return _this;\n  }\n\n  _createClass(BorshError, [{\n    key: \"addToFieldPath\",\n    value: function addToFieldPath(fieldName) {\n      this.fieldPath.splice(0, 0, fieldName); // NOTE: Modifying message directly as jest doesn't use .toString()\n\n      this.message = this.originalMessage + ': ' + this.fieldPath.join('.');\n    }\n  }]);\n\n  return BorshError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.BorshError = BorshError; /// Binary encoder.\n\nvar BinaryWriter = /*#__PURE__*/function () {\n  function BinaryWriter() {\n    _classCallCheck(this, BinaryWriter);\n\n    this.buf = Buffer.alloc(INITIAL_LENGTH);\n    this.length = 0;\n  }\n\n  _createClass(BinaryWriter, [{\n    key: \"maybeResize\",\n    value: function maybeResize() {\n      if (this.buf.length < 16 + this.length) {\n        this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);\n      }\n    }\n  }, {\n    key: \"writeU8\",\n    value: function writeU8(value) {\n      this.maybeResize();\n      this.buf.writeUInt8(value, this.length);\n      this.length += 1;\n    }\n  }, {\n    key: \"writeU16\",\n    value: function writeU16(value) {\n      this.maybeResize();\n      this.buf.writeUInt16LE(value, this.length);\n      this.length += 2;\n    }\n  }, {\n    key: \"writeU32\",\n    value: function writeU32(value) {\n      this.maybeResize();\n      this.buf.writeUInt32LE(value, this.length);\n      this.length += 4;\n    }\n  }, {\n    key: \"writeU64\",\n    value: function writeU64(value) {\n      this.maybeResize();\n      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray('le', 8)));\n    }\n  }, {\n    key: \"writeU128\",\n    value: function writeU128(value) {\n      this.maybeResize();\n      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray('le', 16)));\n    }\n  }, {\n    key: \"writeU256\",\n    value: function writeU256(value) {\n      this.maybeResize();\n      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray('le', 32)));\n    }\n  }, {\n    key: \"writeU512\",\n    value: function writeU512(value) {\n      this.maybeResize();\n      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray('le', 64)));\n    }\n  }, {\n    key: \"writeBuffer\",\n    value: function writeBuffer(buffer) {\n      // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser\n      this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), buffer, Buffer.alloc(INITIAL_LENGTH)]);\n      this.length += buffer.length;\n    }\n  }, {\n    key: \"writeString\",\n    value: function writeString(str) {\n      this.maybeResize();\n      var b = Buffer.from(str, 'utf8');\n      this.writeU32(b.length);\n      this.writeBuffer(b);\n    }\n  }, {\n    key: \"writeFixedArray\",\n    value: function writeFixedArray(array) {\n      this.writeBuffer(Buffer.from(array));\n    }\n  }, {\n    key: \"writeArray\",\n    value: function writeArray(array, fn) {\n      this.maybeResize();\n      this.writeU32(array.length);\n\n      var _iterator = _createForOfIteratorHelper(array),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var elem = _step.value;\n          this.maybeResize();\n          fn(elem);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return this.buf.subarray(0, this.length);\n    }\n  }]);\n\n  return BinaryWriter;\n}();\n\nexports.BinaryWriter = BinaryWriter;\n\nfunction handlingRangeError(target, propertyKey, propertyDescriptor) {\n  var originalMethod = propertyDescriptor.value;\n\n  propertyDescriptor.value = function () {\n    try {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return originalMethod.apply(this, args);\n    } catch (e) {\n      if (e instanceof RangeError) {\n        var code = e.code;\n\n        if (['ERR_BUFFER_OUT_OF_BOUNDS', 'ERR_OUT_OF_RANGE'].indexOf(code) >= 0) {\n          throw new BorshError('Reached the end of buffer when deserializing');\n        }\n      }\n\n      throw e;\n    }\n  };\n}\n\nvar BinaryReader = /*#__PURE__*/function () {\n  function BinaryReader(buf) {\n    _classCallCheck(this, BinaryReader);\n\n    this.buf = buf;\n    this.offset = 0;\n  }\n\n  _createClass(BinaryReader, [{\n    key: \"readU8\",\n    value: function readU8() {\n      var value = this.buf.readUInt8(this.offset);\n      this.offset += 1;\n      return value;\n    }\n  }, {\n    key: \"readU16\",\n    value: function readU16() {\n      var value = this.buf.readUInt16LE(this.offset);\n      this.offset += 2;\n      return value;\n    }\n  }, {\n    key: \"readU32\",\n    value: function readU32() {\n      var value = this.buf.readUInt32LE(this.offset);\n      this.offset += 4;\n      return value;\n    }\n  }, {\n    key: \"readU64\",\n    value: function readU64() {\n      var buf = this.readBuffer(8);\n      return new bn_js_1.default(buf, 'le');\n    }\n  }, {\n    key: \"readU128\",\n    value: function readU128() {\n      var buf = this.readBuffer(16);\n      return new bn_js_1.default(buf, 'le');\n    }\n  }, {\n    key: \"readU256\",\n    value: function readU256() {\n      var buf = this.readBuffer(32);\n      return new bn_js_1.default(buf, 'le');\n    }\n  }, {\n    key: \"readU512\",\n    value: function readU512() {\n      var buf = this.readBuffer(64);\n      return new bn_js_1.default(buf, 'le');\n    }\n  }, {\n    key: \"readBuffer\",\n    value: function readBuffer(len) {\n      if (this.offset + len > this.buf.length) {\n        throw new BorshError(\"Expected buffer length \".concat(len, \" isn't within bounds\"));\n      }\n\n      var result = this.buf.slice(this.offset, this.offset + len);\n      this.offset += len;\n      return result;\n    }\n  }, {\n    key: \"readString\",\n    value: function readString() {\n      var len = this.readU32();\n      var buf = this.readBuffer(len);\n\n      try {\n        // NOTE: Using TextDecoder to fail on invalid UTF-8\n        return textDecoder.decode(buf);\n      } catch (e) {\n        throw new BorshError(\"Error decoding UTF-8 string: \".concat(e));\n      }\n    }\n  }, {\n    key: \"readFixedArray\",\n    value: function readFixedArray(len) {\n      return new Uint8Array(this.readBuffer(len));\n    }\n  }, {\n    key: \"readArray\",\n    value: function readArray(fn) {\n      var len = this.readU32();\n      var result = Array();\n\n      for (var i = 0; i < len; ++i) {\n        result.push(fn());\n      }\n\n      return result;\n    }\n  }]);\n\n  return BinaryReader;\n}();\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU8\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU16\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU32\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU64\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU128\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU256\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU512\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readString\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readFixedArray\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readArray\", null);\n\nexports.BinaryReader = BinaryReader;\n\nfunction capitalizeFirstLetter(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\nfunction serializeField(schema, fieldName, value, fieldType, writer) {\n  try {\n    // TODO: Handle missing values properly (make sure they never result in just skipped write)\n    if (typeof fieldType === 'string') {\n      writer[\"write\".concat(capitalizeFirstLetter(fieldType))](value);\n    } else if (fieldType instanceof Array) {\n      if (typeof fieldType[0] === 'number') {\n        if (value.length !== fieldType[0]) {\n          throw new BorshError(\"Expecting byte array of length \".concat(fieldType[0], \", but got \").concat(value.length, \" bytes\"));\n        }\n\n        writer.writeFixedArray(value);\n      } else {\n        writer.writeArray(value, function (item) {\n          serializeField(schema, fieldName, item, fieldType[0], writer);\n        });\n      }\n    } else if (fieldType.kind !== undefined) {\n      switch (fieldType.kind) {\n        case 'option':\n          {\n            if (value === null || value === undefined) {\n              writer.writeU8(0);\n            } else {\n              writer.writeU8(1);\n              serializeField(schema, fieldName, value, fieldType.type, writer);\n            }\n\n            break;\n          }\n\n        default:\n          throw new BorshError(\"FieldType \".concat(fieldType, \" unrecognized\"));\n      }\n    } else {\n      serializeStruct(schema, value, writer);\n    }\n  } catch (error) {\n    if (error instanceof BorshError) {\n      error.addToFieldPath(fieldName);\n    }\n\n    throw error;\n  }\n}\n\nfunction serializeStruct(schema, obj, writer) {\n  var structSchema = schema.get(obj.constructor);\n\n  if (!structSchema) {\n    throw new BorshError(\"Class \".concat(obj.constructor.name, \" is missing in schema\"));\n  }\n\n  if (structSchema.kind === 'struct') {\n    structSchema.fields.map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          fieldName = _ref2[0],\n          fieldType = _ref2[1];\n\n      serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n    });\n  } else if (structSchema.kind === 'enum') {\n    var name = obj[structSchema.field];\n\n    for (var idx = 0; idx < structSchema.values.length; ++idx) {\n      var _structSchema$values$ = _slicedToArray(structSchema.values[idx], 2),\n          fieldName = _structSchema$values$[0],\n          fieldType = _structSchema$values$[1];\n\n      if (fieldName === name) {\n        writer.writeU8(idx);\n        serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n        break;\n      }\n    }\n  } else {\n    throw new BorshError(\"Unexpected schema kind: \".concat(structSchema.kind, \" for \").concat(obj.constructor.name));\n  }\n} /// Serialize given object using schema of the form:\n/// { class_name -> [ [field_name, field_type], .. ], .. }\n\n\nfunction serialize(schema, obj) {\n  var writer = new BinaryWriter();\n  serializeStruct(schema, obj, writer);\n  return writer.toArray();\n}\n\nexports.serialize = serialize;\n\nfunction deserializeField(schema, fieldName, fieldType, reader) {\n  try {\n    if (typeof fieldType === 'string') {\n      return reader[\"read\".concat(capitalizeFirstLetter(fieldType))]();\n    }\n\n    if (fieldType instanceof Array) {\n      if (typeof fieldType[0] === 'number') {\n        return reader.readFixedArray(fieldType[0]);\n      }\n\n      return reader.readArray(function () {\n        return deserializeField(schema, fieldName, fieldType[0], reader);\n      });\n    }\n\n    if (fieldType.kind === 'option') {\n      var option = reader.readU8();\n\n      if (option) {\n        return deserializeField(schema, fieldName, fieldType.type, reader);\n      }\n\n      return undefined;\n    }\n\n    return deserializeStruct(schema, fieldType, reader);\n  } catch (error) {\n    if (error instanceof BorshError) {\n      error.addToFieldPath(fieldName);\n    }\n\n    throw error;\n  }\n}\n\nfunction deserializeStruct(schema, classType, reader) {\n  var structSchema = schema.get(classType);\n\n  if (!structSchema) {\n    throw new BorshError(\"Class \".concat(classType.name, \" is missing in schema\"));\n  }\n\n  if (structSchema.kind === 'struct') {\n    var result = {};\n\n    var _iterator2 = _createForOfIteratorHelper(schema.get(classType).fields),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            fieldName = _step2$value[0],\n            fieldType = _step2$value[1];\n\n        result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return new classType(result);\n  }\n\n  if (structSchema.kind === 'enum') {\n    var idx = reader.readU8();\n\n    if (idx >= structSchema.values.length) {\n      throw new BorshError(\"Enum index: \".concat(idx, \" is out of range\"));\n    }\n\n    var _structSchema$values$2 = _slicedToArray(structSchema.values[idx], 2),\n        _fieldName = _structSchema$values$2[0],\n        _fieldType = _structSchema$values$2[1];\n\n    var fieldValue = deserializeField(schema, _fieldName, _fieldType, reader);\n    return new classType(_defineProperty({}, _fieldName, fieldValue));\n  }\n\n  throw new BorshError(\"Unexpected schema kind: \".concat(structSchema.kind, \" for \").concat(classType.constructor.name));\n} /// Deserializes object from bytes using schema.\n\n\nfunction deserialize(schema, classType, buffer) {\n  var reader = new BinaryReader(buffer);\n  var result = deserializeStruct(schema, classType, reader);\n\n  if (reader.offset < buffer.length) {\n    throw new BorshError(\"Unexpected \".concat(buffer.length - reader.offset, \" bytes after deserialized data\"));\n  }\n\n  return result;\n}\n\nexports.deserialize = deserialize; /// Deserializes object from bytes using schema, without checking the length read\n\nfunction deserializeUnchecked(schema, classType, buffer) {\n  var reader = new BinaryReader(buffer);\n  return deserializeStruct(schema, classType, reader);\n}\n\nexports.deserializeUnchecked = deserializeUnchecked;","map":{"version":3,"sources":["/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/borsh/lib/index.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","d","Reflect","decorate","i","__importStar","mod","__esModule","result","hasOwnProperty","call","__importDefault","exports","deserializeUnchecked","deserialize","serialize","BinaryReader","BinaryWriter","BorshError","baseDecode","baseEncode","bn_js_1","require","bs58_1","encoding","TextDecoder","global","textDecoder","fatal","Buffer","from","default","encode","decode","INITIAL_LENGTH","message","fieldPath","originalMessage","fieldName","splice","join","Error","buf","alloc","concat","maybeResize","writeUInt8","writeUInt16LE","writeUInt32LE","writeBuffer","toArray","buffer","subarray","str","b","writeU32","array","fn","elem","handlingRangeError","propertyKey","propertyDescriptor","originalMethod","args","apply","e","RangeError","code","indexOf","offset","readUInt8","readUInt16LE","readUInt32LE","readBuffer","len","slice","readU32","Uint8Array","Array","push","prototype","capitalizeFirstLetter","string","charAt","toUpperCase","serializeField","schema","fieldType","writer","writeFixedArray","writeArray","item","kind","writeU8","type","serializeStruct","error","addToFieldPath","obj","structSchema","constructor","name","fields","map","field","idx","values","deserializeField","reader","readFixedArray","readArray","option","readU8","deserializeStruct","classType","fieldValue"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst bs58_1 = __importDefault(require(\"bs58\"));\n// TODO: Make sure this polyfill not included when not required\nconst encoding = __importStar(require(\"text-encoding-utf-8\"));\nconst TextDecoder = (typeof global.TextDecoder !== 'function') ? encoding.TextDecoder : global.TextDecoder;\nconst textDecoder = new TextDecoder('utf-8', { fatal: true });\nfunction baseEncode(value) {\n    if (typeof (value) === 'string') {\n        value = Buffer.from(value, 'utf8');\n    }\n    return bs58_1.default.encode(Buffer.from(value));\n}\nexports.baseEncode = baseEncode;\nfunction baseDecode(value) {\n    return Buffer.from(bs58_1.default.decode(value));\n}\nexports.baseDecode = baseDecode;\nconst INITIAL_LENGTH = 1024;\nclass BorshError extends Error {\n    constructor(message) {\n        super(message);\n        this.fieldPath = [];\n        this.originalMessage = message;\n    }\n    addToFieldPath(fieldName) {\n        this.fieldPath.splice(0, 0, fieldName);\n        // NOTE: Modifying message directly as jest doesn't use .toString()\n        this.message = this.originalMessage + ': ' + this.fieldPath.join('.');\n    }\n}\nexports.BorshError = BorshError;\n/// Binary encoder.\nclass BinaryWriter {\n    constructor() {\n        this.buf = Buffer.alloc(INITIAL_LENGTH);\n        this.length = 0;\n    }\n    maybeResize() {\n        if (this.buf.length < 16 + this.length) {\n            this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);\n        }\n    }\n    writeU8(value) {\n        this.maybeResize();\n        this.buf.writeUInt8(value, this.length);\n        this.length += 1;\n    }\n    writeU16(value) {\n        this.maybeResize();\n        this.buf.writeUInt16LE(value, this.length);\n        this.length += 2;\n    }\n    writeU32(value) {\n        this.maybeResize();\n        this.buf.writeUInt32LE(value, this.length);\n        this.length += 4;\n    }\n    writeU64(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray('le', 8)));\n    }\n    writeU128(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray('le', 16)));\n    }\n    writeU256(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray('le', 32)));\n    }\n    writeU512(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray('le', 64)));\n    }\n    writeBuffer(buffer) {\n        // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser\n        this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), buffer, Buffer.alloc(INITIAL_LENGTH)]);\n        this.length += buffer.length;\n    }\n    writeString(str) {\n        this.maybeResize();\n        const b = Buffer.from(str, 'utf8');\n        this.writeU32(b.length);\n        this.writeBuffer(b);\n    }\n    writeFixedArray(array) {\n        this.writeBuffer(Buffer.from(array));\n    }\n    writeArray(array, fn) {\n        this.maybeResize();\n        this.writeU32(array.length);\n        for (const elem of array) {\n            this.maybeResize();\n            fn(elem);\n        }\n    }\n    toArray() {\n        return this.buf.subarray(0, this.length);\n    }\n}\nexports.BinaryWriter = BinaryWriter;\nfunction handlingRangeError(target, propertyKey, propertyDescriptor) {\n    const originalMethod = propertyDescriptor.value;\n    propertyDescriptor.value = function (...args) {\n        try {\n            return originalMethod.apply(this, args);\n        }\n        catch (e) {\n            if (e instanceof RangeError) {\n                const code = e.code;\n                if (['ERR_BUFFER_OUT_OF_BOUNDS', 'ERR_OUT_OF_RANGE'].indexOf(code) >= 0) {\n                    throw new BorshError('Reached the end of buffer when deserializing');\n                }\n            }\n            throw e;\n        }\n    };\n}\nclass BinaryReader {\n    constructor(buf) {\n        this.buf = buf;\n        this.offset = 0;\n    }\n    readU8() {\n        const value = this.buf.readUInt8(this.offset);\n        this.offset += 1;\n        return value;\n    }\n    readU16() {\n        const value = this.buf.readUInt16LE(this.offset);\n        this.offset += 2;\n        return value;\n    }\n    readU32() {\n        const value = this.buf.readUInt32LE(this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readU64() {\n        const buf = this.readBuffer(8);\n        return new bn_js_1.default(buf, 'le');\n    }\n    readU128() {\n        const buf = this.readBuffer(16);\n        return new bn_js_1.default(buf, 'le');\n    }\n    readU256() {\n        const buf = this.readBuffer(32);\n        return new bn_js_1.default(buf, 'le');\n    }\n    readU512() {\n        const buf = this.readBuffer(64);\n        return new bn_js_1.default(buf, 'le');\n    }\n    readBuffer(len) {\n        if ((this.offset + len) > this.buf.length) {\n            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);\n        }\n        const result = this.buf.slice(this.offset, this.offset + len);\n        this.offset += len;\n        return result;\n    }\n    readString() {\n        const len = this.readU32();\n        const buf = this.readBuffer(len);\n        try {\n            // NOTE: Using TextDecoder to fail on invalid UTF-8\n            return textDecoder.decode(buf);\n        }\n        catch (e) {\n            throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n        }\n    }\n    readFixedArray(len) {\n        return new Uint8Array(this.readBuffer(len));\n    }\n    readArray(fn) {\n        const len = this.readU32();\n        const result = Array();\n        for (let i = 0; i < len; ++i) {\n            result.push(fn());\n        }\n        return result;\n    }\n}\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU8\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU16\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU32\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU64\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU128\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU256\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU512\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readString\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readFixedArray\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readArray\", null);\nexports.BinaryReader = BinaryReader;\nfunction capitalizeFirstLetter(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nfunction serializeField(schema, fieldName, value, fieldType, writer) {\n    try {\n        // TODO: Handle missing values properly (make sure they never result in just skipped write)\n        if (typeof fieldType === 'string') {\n            writer[`write${capitalizeFirstLetter(fieldType)}`](value);\n        }\n        else if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === 'number') {\n                if (value.length !== fieldType[0]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);\n                }\n                writer.writeFixedArray(value);\n            }\n            else {\n                writer.writeArray(value, (item) => { serializeField(schema, fieldName, item, fieldType[0], writer); });\n            }\n        }\n        else if (fieldType.kind !== undefined) {\n            switch (fieldType.kind) {\n                case 'option': {\n                    if (value === null || value === undefined) {\n                        writer.writeU8(0);\n                    }\n                    else {\n                        writer.writeU8(1);\n                        serializeField(schema, fieldName, value, fieldType.type, writer);\n                    }\n                    break;\n                }\n                default: throw new BorshError(`FieldType ${fieldType} unrecognized`);\n            }\n        }\n        else {\n            serializeStruct(schema, value, writer);\n        }\n    }\n    catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction serializeStruct(schema, obj, writer) {\n    const structSchema = schema.get(obj.constructor);\n    if (!structSchema) {\n        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);\n    }\n    if (structSchema.kind === 'struct') {\n        structSchema.fields.map(([fieldName, fieldType]) => {\n            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n        });\n    }\n    else if (structSchema.kind === 'enum') {\n        const name = obj[structSchema.field];\n        for (let idx = 0; idx < structSchema.values.length; ++idx) {\n            const [fieldName, fieldType] = structSchema.values[idx];\n            if (fieldName === name) {\n                writer.writeU8(idx);\n                serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n                break;\n            }\n        }\n    }\n    else {\n        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);\n    }\n}\n/// Serialize given object using schema of the form:\n/// { class_name -> [ [field_name, field_type], .. ], .. }\nfunction serialize(schema, obj) {\n    const writer = new BinaryWriter();\n    serializeStruct(schema, obj, writer);\n    return writer.toArray();\n}\nexports.serialize = serialize;\nfunction deserializeField(schema, fieldName, fieldType, reader) {\n    try {\n        if (typeof fieldType === 'string') {\n            return reader[`read${capitalizeFirstLetter(fieldType)}`]();\n        }\n        if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === 'number') {\n                return reader.readFixedArray(fieldType[0]);\n            }\n            return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));\n        }\n        if (fieldType.kind === 'option') {\n            const option = reader.readU8();\n            if (option) {\n                return deserializeField(schema, fieldName, fieldType.type, reader);\n            }\n            return undefined;\n        }\n        return deserializeStruct(schema, fieldType, reader);\n    }\n    catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction deserializeStruct(schema, classType, reader) {\n    const structSchema = schema.get(classType);\n    if (!structSchema) {\n        throw new BorshError(`Class ${classType.name} is missing in schema`);\n    }\n    if (structSchema.kind === 'struct') {\n        const result = {};\n        for (const [fieldName, fieldType] of schema.get(classType).fields) {\n            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\n        }\n        return new classType(result);\n    }\n    if (structSchema.kind === 'enum') {\n        const idx = reader.readU8();\n        if (idx >= structSchema.values.length) {\n            throw new BorshError(`Enum index: ${idx} is out of range`);\n        }\n        const [fieldName, fieldType] = structSchema.values[idx];\n        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);\n        return new classType({ [fieldName]: fieldValue });\n    }\n    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);\n}\n/// Deserializes object from bytes using schema.\nfunction deserialize(schema, classType, buffer) {\n    const reader = new BinaryReader(buffer);\n    const result = deserializeStruct(schema, classType, reader);\n    if (reader.offset < buffer.length) {\n        throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);\n    }\n    return result;\n}\nexports.deserialize = deserialize;\n/// Deserializes object from bytes using schema, without checking the length read\nfunction deserializeUnchecked(schema, classType, buffer) {\n    const reader = new BinaryReader(buffer);\n    return deserializeStruct(schema, classType, reader);\n}\nexports.deserializeUnchecked = deserializeUnchecked;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"import { __extends, __assign } from 'tslib';\nimport * as React from 'react';\nimport { Presence } from './types.js';\nimport { layoutStack } from './utils/stack.js';\nimport { SharedLayoutContext } from '../../context/SharedLayoutContext.js';\nimport { MotionContext } from '../../context/MotionContext/index.js';\nimport { resetRotate } from './utils/rotate.js';\nimport { createBatcher } from './utils/batcher.js';\nimport { snapshotViewportBox } from '../../render/dom/projection/utils.js';\n/**\n * @public\n */\n\nvar AnimateSharedLayout = function (_super) {\n  __extends(AnimateSharedLayout, _super);\n\n  function AnimateSharedLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A list of all the children in the shared layout\n     */\n\n\n    _this.children = new Set();\n    /**\n     * As animate components with a defined `layoutId` are added/removed to the tree,\n     * we store them in order. When one is added, it will animate out from the\n     * previous one, and when it's removed, it'll animate to the previous one.\n     */\n\n    _this.stacks = new Map();\n    /**\n     * Track whether the component has mounted. If it hasn't, the presence of added children\n     * are set to Present, whereas if it has they're considered Entering\n     */\n\n    _this.hasMounted = false;\n    /**\n     * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n     * and schedule one.\n     */\n\n    _this.updateScheduled = false;\n    /**\n     * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n     */\n\n    _this.renderScheduled = false;\n    /**\n     * The methods provided to all children in the shared layout tree.\n     */\n\n    _this.syncContext = __assign(__assign({}, createBatcher()), {\n      syncUpdate: function syncUpdate(force) {\n        return _this.scheduleUpdate(force);\n      },\n      forceUpdate: function forceUpdate() {\n        // By copying syncContext to itself, when this component re-renders it'll also re-render\n        // all children subscribed to the SharedLayout context.\n        _this.syncContext = __assign({}, _this.syncContext);\n\n        _this.scheduleUpdate(true);\n      },\n      register: function register(child) {\n        return _this.addChild(child);\n      },\n      remove: function remove(child) {\n        return _this.removeChild(child);\n      }\n    });\n    return _this;\n  }\n\n  AnimateSharedLayout.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n  };\n\n  AnimateSharedLayout.prototype.componentDidUpdate = function () {\n    this.startLayoutAnimation();\n  };\n\n  AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n    this.renderScheduled = true;\n    return true;\n  };\n\n  AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n    var _this = this;\n    /**\n     * Reset update and render scheduled status\n     */\n\n\n    this.renderScheduled = this.updateScheduled = false;\n    var type = this.props.type;\n    /**\n     * Update presence metadata based on the latest AnimatePresence status.\n     * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n     */\n\n    this.children.forEach(function (child) {\n      if (!child.isPresent) {\n        child.presence = Presence.Exiting;\n      } else if (child.presence !== Presence.Entering) {\n        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;\n      }\n    });\n    this.updateStacks();\n    /**\n     * Create a handler which we can use to flush the children animations\n     */\n\n    var handler = {\n      layoutReady: function layoutReady(child) {\n        if (child.getLayoutId() !== undefined) {\n          var stack = _this.getStack(child);\n\n          stack.animate(child, type === \"crossfade\");\n        } else {\n          child.notifyLayoutReady();\n        }\n      },\n      parent: this.context.visualElement\n    };\n    /**\n     * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n     * This requires some co-ordination across components to stop layout thrashing\n     * and ensure measurements are taken at the correct time.\n     *\n     * Here we use that same mechanism of schedule/flush.\n     */\n\n    this.children.forEach(function (child) {\n      return _this.syncContext.add(child);\n    });\n    this.syncContext.flush(handler);\n    /**\n     * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.clearSnapshot();\n    });\n  };\n\n  AnimateSharedLayout.prototype.updateStacks = function () {\n    this.stacks.forEach(function (stack) {\n      return stack.updateLeadAndFollow();\n    });\n  };\n\n  AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!(force || !this.updateScheduled)) return;\n    /**\n     * Flag we've scheduled an update\n     */\n\n    this.updateScheduled = true;\n    /**\n     * Write: Reset transforms so bounding boxes can be accurately measured.\n     */\n\n    this.children.forEach(function (child) {\n      resetRotate(child);\n      if (child.shouldResetTransform()) child.resetTransform();\n    });\n    /**\n     * Read: Snapshot children\n     */\n\n    this.children.forEach(snapshotViewportBox);\n    /**\n     * Every child keeps a local snapshot, but we also want to record\n     * snapshots of the visible children as, if they're are being removed\n     * in this render, we can still access them.\n     *\n     * TODO: What would be better here is doing a single loop where we\n     * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.updateSnapshot();\n    });\n    /**\n     * Force a rerender by setting state if we aren't already going to render.\n     */\n\n    if (force || !this.renderScheduled) {\n      this.renderScheduled = true;\n      this.forceUpdate();\n    }\n  };\n\n  AnimateSharedLayout.prototype.addChild = function (child) {\n    this.children.add(child);\n    this.addToStack(child);\n    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n  };\n\n  AnimateSharedLayout.prototype.removeChild = function (child) {\n    this.scheduleUpdate();\n    this.children.delete(child);\n    this.removeFromStack(child);\n  };\n\n  AnimateSharedLayout.prototype.addToStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.add(child);\n  };\n\n  AnimateSharedLayout.prototype.removeFromStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.remove(child);\n  };\n  /**\n   * Return a stack of animate children based on the provided layoutId.\n   * Will create a stack if none currently exists with that layoutId.\n   */\n\n\n  AnimateSharedLayout.prototype.getStack = function (child) {\n    var id = child.getLayoutId();\n    if (id === undefined) return; // Create stack if it doesn't already exist\n\n    !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n    return this.stacks.get(id);\n  };\n\n  AnimateSharedLayout.prototype.render = function () {\n    return React.createElement(SharedLayoutContext.Provider, {\n      value: this.syncContext\n    }, this.props.children);\n  };\n\n  AnimateSharedLayout.contextType = MotionContext;\n  return AnimateSharedLayout;\n}(React.Component);\n\nexport { AnimateSharedLayout };","map":{"version":3,"sources":["/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/framer-motion/dist/es/components/AnimateSharedLayout/index.js"],"names":["__extends","__assign","React","Presence","layoutStack","SharedLayoutContext","MotionContext","resetRotate","createBatcher","snapshotViewportBox","AnimateSharedLayout","_super","_this","apply","arguments","children","Set","stacks","Map","hasMounted","updateScheduled","renderScheduled","syncContext","syncUpdate","force","scheduleUpdate","forceUpdate","register","child","addChild","remove","removeChild","prototype","componentDidMount","componentDidUpdate","startLayoutAnimation","shouldComponentUpdate","type","props","forEach","isPresent","presence","Exiting","Entering","Present","updateStacks","handler","layoutReady","getLayoutId","undefined","stack","getStack","animate","notifyLayoutReady","parent","context","visualElement","add","flush","clearSnapshot","updateLeadAndFollow","shouldResetTransform","resetTransform","updateSnapshot","addToStack","delete","removeFromStack","id","has","set","get","render","createElement","Provider","value","contextType","Component"],"mappings":"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","sourcesContent":["import { __extends, __assign } from 'tslib';\nimport * as React from 'react';\nimport { Presence } from './types.js';\nimport { layoutStack } from './utils/stack.js';\nimport { SharedLayoutContext } from '../../context/SharedLayoutContext.js';\nimport { MotionContext } from '../../context/MotionContext/index.js';\nimport { resetRotate } from './utils/rotate.js';\nimport { createBatcher } from './utils/batcher.js';\nimport { snapshotViewportBox } from '../../render/dom/projection/utils.js';\n\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */ (function (_super) {\n    __extends(AnimateSharedLayout, _super);\n    function AnimateSharedLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A list of all the children in the shared layout\n         */\n        _this.children = new Set();\n        /**\n         * As animate components with a defined `layoutId` are added/removed to the tree,\n         * we store them in order. When one is added, it will animate out from the\n         * previous one, and when it's removed, it'll animate to the previous one.\n         */\n        _this.stacks = new Map();\n        /**\n         * Track whether the component has mounted. If it hasn't, the presence of added children\n         * are set to Present, whereas if it has they're considered Entering\n         */\n        _this.hasMounted = false;\n        /**\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n         * and schedule one.\n         */\n        _this.updateScheduled = false;\n        /**\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n         */\n        _this.renderScheduled = false;\n        /**\n         * The methods provided to all children in the shared layout tree.\n         */\n        _this.syncContext = __assign(__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\n                // all children subscribed to the SharedLayout context.\n                _this.syncContext = __assign({}, _this.syncContext);\n                _this.scheduleUpdate(true);\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\n        return _this;\n    }\n    AnimateSharedLayout.prototype.componentDidMount = function () {\n        this.hasMounted = true;\n    };\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\n        this.startLayoutAnimation();\n    };\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n        this.renderScheduled = true;\n        return true;\n    };\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n        var _this = this;\n        /**\n         * Reset update and render scheduled status\n         */\n        this.renderScheduled = this.updateScheduled = false;\n        var type = this.props.type;\n        /**\n         * Update presence metadata based on the latest AnimatePresence status.\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n         */\n        this.children.forEach(function (child) {\n            if (!child.isPresent) {\n                child.presence = Presence.Exiting;\n            }\n            else if (child.presence !== Presence.Entering) {\n                child.presence =\n                    child.presence === Presence.Exiting\n                        ? Presence.Entering\n                        : Presence.Present;\n            }\n        });\n        this.updateStacks();\n        /**\n         * Create a handler which we can use to flush the children animations\n         */\n        var handler = {\n            layoutReady: function (child) {\n                if (child.getLayoutId() !== undefined) {\n                    var stack = _this.getStack(child);\n                    stack.animate(child, type === \"crossfade\");\n                }\n                else {\n                    child.notifyLayoutReady();\n                }\n            },\n            parent: this.context.visualElement,\n        };\n        /**\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n         * This requires some co-ordination across components to stop layout thrashing\n         * and ensure measurements are taken at the correct time.\n         *\n         * Here we use that same mechanism of schedule/flush.\n         */\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\n        this.syncContext.flush(handler);\n        /**\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n         */\n        this.stacks.forEach(function (stack) { return stack.clearSnapshot(); });\n    };\n    AnimateSharedLayout.prototype.updateStacks = function () {\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\n    };\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n        if (force === void 0) { force = false; }\n        if (!(force || !this.updateScheduled))\n            return;\n        /**\n         * Flag we've scheduled an update\n         */\n        this.updateScheduled = true;\n        /**\n         * Write: Reset transforms so bounding boxes can be accurately measured.\n         */\n        this.children.forEach(function (child) {\n            resetRotate(child);\n            if (child.shouldResetTransform())\n                child.resetTransform();\n        });\n        /**\n         * Read: Snapshot children\n         */\n        this.children.forEach(snapshotViewportBox);\n        /**\n         * Every child keeps a local snapshot, but we also want to record\n         * snapshots of the visible children as, if they're are being removed\n         * in this render, we can still access them.\n         *\n         * TODO: What would be better here is doing a single loop where we\n         * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n         */\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\n        /**\n         * Force a rerender by setting state if we aren't already going to render.\n         */\n        if (force || !this.renderScheduled) {\n            this.renderScheduled = true;\n            this.forceUpdate();\n        }\n    };\n    AnimateSharedLayout.prototype.addChild = function (child) {\n        this.children.add(child);\n        this.addToStack(child);\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n    };\n    AnimateSharedLayout.prototype.removeChild = function (child) {\n        this.scheduleUpdate();\n        this.children.delete(child);\n        this.removeFromStack(child);\n    };\n    AnimateSharedLayout.prototype.addToStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\n    };\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\n    };\n    /**\n     * Return a stack of animate children based on the provided layoutId.\n     * Will create a stack if none currently exists with that layoutId.\n     */\n    AnimateSharedLayout.prototype.getStack = function (child) {\n        var id = child.getLayoutId();\n        if (id === undefined)\n            return;\n        // Create stack if it doesn't already exist\n        !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n        return this.stacks.get(id);\n    };\n    AnimateSharedLayout.prototype.render = function () {\n        return (React.createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\n    };\n    AnimateSharedLayout.contextType = MotionContext;\n    return AnimateSharedLayout;\n}(React.Component));\n\nexport { AnimateSharedLayout };\n"]},"metadata":{},"sourceType":"module"}
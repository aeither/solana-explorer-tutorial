{"version":3,"sources":["../../src/breakpoint.ts"],"names":["analyzeCSSValue","value","num","parseFloat","toString","unit","replace","String","unitless","px","sortByBreakpointValue","a","b","parseInt","sortBps","breakpoints","Object","entries","sort","normalize","sorted","assign","values","keys","Set","subtract","factor","endsWith","m","queryString","min","max","query","push","length","join","analyzeBreakpoints","base","normalized","queries","map","index","entry","breakpoint","minW","maxW","undefined","maxWQuery","minWQuery","minMaxQuery","_keys","_keysArr","Array","from","isResponsive","test","every","key","has","asObject","asArray","details","media","slice","toArrayValue","Error","result","bp","pop","toObjectValue","isArray","reduce","acc"],"mappings":"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","sourcesContent":["import { getLastItem } from \"./array\"\nimport { isNumber, isObject } from \"./assertion\"\nimport { fromEntries } from \"./object\"\nimport { Dict } from \"./types\"\n\nfunction analyzeCSSValue(value: number | string) {\n  const num = parseFloat(value.toString())\n  const unit = value.toString().replace(String(num), \"\")\n  return { unitless: !unit, value: num, unit }\n}\n\nexport function px(value: number | string | null): string | null {\n  if (value == null) return value\n  const { unitless } = analyzeCSSValue(value)\n  return unitless || isNumber(value) ? `${value}px` : value\n}\n\nconst sortByBreakpointValue = (a: any[], b: any[]) =>\n  parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1\n\nconst sortBps = (breakpoints: Dict): Dict =>\n  fromEntries(Object.entries(breakpoints).sort(sortByBreakpointValue))\n\nfunction normalize(breakpoints: Dict) {\n  const sorted = sortBps(breakpoints)\n  return Object.assign(Object.values(sorted), sorted) as string[]\n}\n\nfunction keys(breakpoints: Dict) {\n  const value = Object.keys(sortBps(breakpoints))\n  return new Set(value)\n}\n\nfunction subtract(value: string) {\n  if (!value) return value\n  value = px(value) ?? value\n  const factor = value.endsWith(\"px\")\n    ? -1\n    : // the equivalent of 1px in em using a 16px base\n      -0.0635\n  return isNumber(value)\n    ? `${value + factor}`\n    : value.replace(/(\\d+\\.?\\d*)/u, (m) => `${parseFloat(m) + factor}`)\n}\n\nfunction queryString(min: string | null, max?: string) {\n  const query = []\n\n  if (min) query.push(`@media screen and (min-width: ${px(min)})`)\n  if (query.length > 0 && max) query.push(\"and\")\n  if (max) query.push(`@media screen and (max-width: ${px(max)})`)\n\n  return query.join(\" \")\n}\n\nexport function analyzeBreakpoints(breakpoints: Dict) {\n  if (!breakpoints) return null\n\n  breakpoints.base = breakpoints.base ?? \"0px\"\n\n  const normalized = normalize(breakpoints)\n\n  const queries = Object.entries(breakpoints)\n    .sort(sortByBreakpointValue)\n    .map(([breakpoint, minW], index, entry) => {\n      let [, maxW] = entry[index + 1] ?? []\n      maxW = parseFloat(maxW) > 0 ? subtract(maxW) : undefined\n      return {\n        breakpoint,\n        minW,\n        maxW,\n        maxWQuery: queryString(null, maxW),\n        minWQuery: queryString(minW),\n        minMaxQuery: queryString(minW, maxW),\n      }\n    })\n\n  const _keys = keys(breakpoints)\n  const _keysArr = Array.from(_keys.values())\n\n  return {\n    keys: _keys,\n    normalized,\n    isResponsive(test: Dict) {\n      const keys = Object.keys(test)\n      return keys.length > 0 && keys.every((key) => _keys.has(key))\n    },\n    asObject: sortBps(breakpoints),\n    asArray: normalize(breakpoints),\n    details: queries,\n    media: [null, ...normalized.map((minW) => queryString(minW)).slice(1)],\n    toArrayValue(test: Dict) {\n      if (!isObject(test)) {\n        throw new Error(\"toArrayValue: value must be an object\")\n      }\n      const result = _keysArr.map((bp) => test[bp] ?? null)\n      while (getLastItem(result) === null) {\n        result.pop()\n      }\n      return result\n    },\n    toObjectValue(test: any[]) {\n      if (!Array.isArray(test)) {\n        throw new Error(\"toObjectValue: value must be an array\")\n      }\n      return test.reduce((acc, value, index) => {\n        const key = _keysArr[index]\n        if (key != null && value != null) acc[key] = value\n        return acc\n      }, {} as Dict)\n    },\n  }\n}\n\nexport type AnalyzeBreakpointsReturn = ReturnType<typeof analyzeBreakpoints>\n"],"file":"breakpoint.js"}
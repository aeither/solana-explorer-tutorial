{"version":3,"sources":["../../src/pan-event.ts"],"names":["PanSession","event","handlers","threshold","noop","lastEvent","lastEventInfo","info","getPanInfo","history","isPanStarted","startEvent","isDistancePastThreshold","offset","x","y","timestamp","push","point","onStart","onMove","buttons","onPointerUp","sync","update","updatePoint","panInfo","onEnd","onSessionEnd","end","stopPropagation","preventDefault","onSessionStart","removeListeners","window","onPointerMove","updateHandlers","cancelSync","subtractPoint","a","b","startPanPoint","lastPanPoint","length","delta","velocity","getVelocity","lastDevicePoint","toMilliseconds","seconds","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity"],"mappings":"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","sourcesContent":["/**\n * This is a modified version of `PanSession` from `framer-motion`.\n *\n * Credit goes to `framer-motion` of this useful utilities.\n * License can be found here: https://github.com/framer/motion\n */\n\nimport sync, { cancelSync, getFrameData } from \"framesync\"\nimport {\n  isMouseEvent,\n  extractEventInfo,\n  addPointerEvent,\n  AnyPointerEvent,\n  Point,\n  PointerEventInfo,\n  isMultiTouchEvent,\n} from \"./pointer-event\"\nimport { pipe, distance, noop } from \"./function\"\n\n/**\n * The event information passed to pan event handlers like `onPan`, `onPanStart`.\n *\n * It contains information about the current state of the tap gesture such as its\n * `point`, `delta`, and `offset`\n */\nexport interface PanEventInfo {\n  /**\n   * Contains `x` and `y` values for the current pan position relative\n   * to the device or page.\n   */\n  point: Point\n  /**\n   * Contains `x` and `y` values for the distance moved since\n   * the last pan event.\n   */\n  delta: Point\n  /**\n   * Contains `x` and `y` values for the distance moved from\n   * the first pan event.\n   */\n  offset: Point\n  /**\n   * Contains `x` and `y` values for the current velocity of the pointer.\n   */\n  velocity: Point\n}\n\nexport type PanEventHandler = (\n  event: AnyPointerEvent,\n  info: PanEventInfo,\n) => void\n\ninterface TimestampedPoint extends Point {\n  timestamp: number\n}\n\nexport interface PanSessionHandlers {\n  /**\n   * Callback fired when the pan session is created.\n   * This is typically called once `pointerdown` event is fired.\n   */\n  onSessionStart: PanEventHandler\n  /**\n   * Callback fired when the pan session is detached.\n   * This is typically called once `pointerup` event is fired.\n   */\n  onSessionEnd: PanEventHandler\n  /**\n   * Callback fired when the pan session has started.\n   * The pan session when the pan offset is greater than\n   * the threshold (allowable move distance to detect pan)\n   */\n  onStart: PanEventHandler\n  /**\n   * Callback fired while panning\n   */\n  onMove: PanEventHandler\n  /**\n   * Callback fired when the current pan session has end.\n   * This is typically called once `pointerup` event is fired.\n   */\n  onEnd: PanEventHandler\n}\n\ntype PanSessionHistory = TimestampedPoint[]\n\n/**\n * @internal\n *\n * A Pan Session is recognized when the pointer is down\n * and moved in the allowed direction.\n */\nexport class PanSession {\n  /**\n   * We use this to keep track of the `x` and `y` pan session history\n   * as the pan event happens. It helps to calculate the `offset` and `delta`\n   */\n  private history: PanSessionHistory = []\n\n  // The pointer event that started the pan session\n  private startEvent: AnyPointerEvent | null = null\n\n  // The current pointer event for the pan session\n  private lastEvent: AnyPointerEvent | null = null\n\n  // The current pointer event info for the pan session\n  private lastEventInfo: PointerEventInfo | null = null\n\n  private handlers: Partial<PanSessionHandlers> = {}\n\n  private removeListeners: Function = noop\n\n  /**\n   * Minimal pan distance required before recognizing the pan.\n   * @default \"3px\"\n   */\n  private threshold = 3\n\n  constructor(\n    event: AnyPointerEvent,\n    handlers: Partial<PanSessionHandlers>,\n    threshold?: number,\n  ) {\n    // If we have more than one touch, don't start detecting this gesture\n    if (isMultiTouchEvent(event)) return\n\n    this.handlers = handlers\n\n    if (threshold) {\n      this.threshold = threshold\n    }\n\n    // stop default browser behavior\n    event.stopPropagation()\n    event.preventDefault()\n\n    // get and save the `pointerdown` event info in history\n    // we'll use it to compute the `offset`\n    const info = extractEventInfo(event)\n    const { timestamp } = getFrameData()\n    this.history = [{ ...info.point, timestamp }]\n\n    // notify pan session start\n    const { onSessionStart } = handlers\n    onSessionStart?.(event, getPanInfo(info, this.history))\n\n    // attach event listeners and return a single function to remove them all\n    this.removeListeners = pipe(\n      addPointerEvent(window, \"pointermove\", this.onPointerMove),\n      addPointerEvent(window, \"pointerup\", this.onPointerUp),\n      addPointerEvent(window, \"pointercancel\", this.onPointerUp),\n    )\n  }\n\n  private updatePoint = () => {\n    if (!(this.lastEvent && this.lastEventInfo)) return\n\n    const info = getPanInfo(this.lastEventInfo, this.history)\n\n    const isPanStarted = this.startEvent !== null\n\n    const isDistancePastThreshold =\n      distance(info.offset, { x: 0, y: 0 }) >= this.threshold\n\n    if (!isPanStarted && !isDistancePastThreshold) return\n\n    const { timestamp } = getFrameData()\n    this.history.push({ ...info.point, timestamp })\n\n    const { onStart, onMove } = this.handlers\n\n    if (!isPanStarted) {\n      onStart?.(this.lastEvent, info)\n      this.startEvent = this.lastEvent\n    }\n\n    onMove?.(this.lastEvent, info)\n  }\n\n  private onPointerMove = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    this.lastEvent = event\n    this.lastEventInfo = info\n\n    // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n    if (isMouseEvent(event) && event.buttons === 0) {\n      this.onPointerUp(event, info)\n      return\n    }\n\n    // Throttle mouse move event to once per frame\n    sync.update(this.updatePoint, true)\n  }\n\n  private onPointerUp = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    // notify pan session ended\n    const panInfo = getPanInfo(info, this.history)\n    const { onEnd, onSessionEnd } = this.handlers\n\n    onSessionEnd?.(event, panInfo)\n    this.end()\n\n    // if panning never started, no need to call `onEnd`\n    // panning requires a pointermove of at least 3px\n    if (!onEnd || !this.startEvent) return\n\n    onEnd?.(event, panInfo)\n  }\n\n  updateHandlers(handlers: Partial<PanSessionHandlers>) {\n    this.handlers = handlers\n  }\n\n  end() {\n    this.removeListeners?.()\n    cancelSync.update(this.updatePoint)\n  }\n}\n\nfunction subtractPoint(a: Point, b: Point) {\n  return { x: a.x - b.x, y: a.y - b.y }\n}\n\nfunction startPanPoint(history: PanSessionHistory) {\n  return history[0]\n}\n\nfunction lastPanPoint(history: PanSessionHistory) {\n  return history[history.length - 1]\n}\n\nfunction getPanInfo(info: PointerEventInfo, history: PanSessionHistory) {\n  return {\n    point: info.point,\n    delta: subtractPoint(info.point, lastPanPoint(history)),\n    offset: subtractPoint(info.point, startPanPoint(history)),\n    velocity: getVelocity(history, 0.1),\n  }\n}\n\nfunction lastDevicePoint(history: TimestampedPoint[]): TimestampedPoint {\n  return history[history.length - 1]\n}\n\nconst toMilliseconds = (seconds: number) => seconds * 1000\n\nfunction getVelocity(history: TimestampedPoint[], timeDelta: number): Point {\n  if (history.length < 2) {\n    return { x: 0, y: 0 }\n  }\n\n  let i = history.length - 1\n  let timestampedPoint: TimestampedPoint | null = null\n  const lastPoint = lastDevicePoint(history)\n  while (i >= 0) {\n    timestampedPoint = history[i]\n    if (\n      lastPoint.timestamp - timestampedPoint.timestamp >\n      toMilliseconds(timeDelta)\n    ) {\n      break\n    }\n    i--\n  }\n\n  if (!timestampedPoint) {\n    return { x: 0, y: 0 }\n  }\n\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000\n  if (time === 0) {\n    return { x: 0, y: 0 }\n  }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time,\n  }\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0\n  }\n\n  return currentVelocity\n}\n"],"file":"pan-event.js"}
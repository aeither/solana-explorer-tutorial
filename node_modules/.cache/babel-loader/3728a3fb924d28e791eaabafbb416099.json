{"ast":null,"code":"export var LAMPORTS_PER_SOL = 1000000000;\nexport function lamportsToSol(lamports) {\n  if (typeof lamports === \"number\") {\n    return Math.abs(lamports) / LAMPORTS_PER_SOL;\n  }\n\n  var signMultiplier = 1;\n\n  if (lamports.isNeg()) {\n    signMultiplier = -1;\n  }\n\n  var absLamports = lamports.abs();\n  var lamportsString = absLamports.toString(10).padStart(10, \"0\");\n  var splitIndex = lamportsString.length - 9;\n  var solString = lamportsString.slice(0, splitIndex) + \".\" + lamportsString.slice(splitIndex);\n  return signMultiplier * parseFloat(solString);\n}\nexport function lamportsToSolString(lamports) {\n  var maximumFractionDigits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 9;\n  var sol = lamportsToSol(lamports);\n  return new Intl.NumberFormat(\"en-US\", {\n    maximumFractionDigits: maximumFractionDigits\n  }).format(sol);\n}\nexport function abbreviatedNumber(value) {\n  var fixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (value < 1e3) return value;\n  if (value >= 1e3 && value < 1e6) return +(value / 1e3).toFixed(fixed) + \"K\";\n  if (value >= 1e6 && value < 1e9) return +(value / 1e6).toFixed(fixed) + \"M\";\n  if (value >= 1e9 && value < 1e12) return +(value / 1e9).toFixed(fixed) + \"B\";\n  if (value >= 1e12) return +(value / 1e12).toFixed(fixed) + \"T\";\n}\nexport function normalizeTokenAmount(raw, decimals) {\n  var rawTokens;\n  if (typeof raw === \"string\") rawTokens = parseInt(raw, 10);else rawTokens = raw;\n  return rawTokens / Math.pow(10, decimals);\n}","map":{"version":3,"sources":["/Users/lin/Documents/Projects/solana-explorer-tutorial/src/utils/index.ts"],"names":["LAMPORTS_PER_SOL","lamportsToSol","lamports","Math","abs","signMultiplier","isNeg","absLamports","lamportsString","toString","padStart","splitIndex","length","solString","slice","parseFloat","lamportsToSolString","maximumFractionDigits","sol","Intl","NumberFormat","format","abbreviatedNumber","value","fixed","toFixed","normalizeTokenAmount","raw","decimals","rawTokens","parseInt","pow"],"mappings":"AAEA,OAAO,IAAMA,gBAAgB,GAAG,UAAzB;AAEP,OAAO,SAASC,aAAT,CAAuBC,QAAvB,EAAsD;AAC3D,MAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkC;AAChC,WAAOC,IAAI,CAACC,GAAL,CAASF,QAAT,IAAqBF,gBAA5B;AACD;;AAED,MAAIK,cAAc,GAAG,CAArB;;AACA,MAAIH,QAAQ,CAACI,KAAT,EAAJ,EAAsB;AACpBD,IAAAA,cAAc,GAAG,CAAC,CAAlB;AACD;;AAED,MAAME,WAAW,GAAGL,QAAQ,CAACE,GAAT,EAApB;AACA,MAAMI,cAAc,GAAGD,WAAW,CAACE,QAAZ,CAAqB,EAArB,EAAyBC,QAAzB,CAAkC,EAAlC,EAAsC,GAAtC,CAAvB;AACA,MAAMC,UAAU,GAAGH,cAAc,CAACI,MAAf,GAAwB,CAA3C;AACA,MAAMC,SAAS,GACbL,cAAc,CAACM,KAAf,CAAqB,CAArB,EAAwBH,UAAxB,IACA,GADA,GAEAH,cAAc,CAACM,KAAf,CAAqBH,UAArB,CAHF;AAIA,SAAON,cAAc,GAAGU,UAAU,CAACF,SAAD,CAAlC;AACD;AAED,OAAO,SAASG,mBAAT,CACLd,QADK,EAGG;AAAA,MADRe,qBACQ,uEADwB,CACxB;AACR,MAAMC,GAAG,GAAGjB,aAAa,CAACC,QAAD,CAAzB;AACA,SAAO,IAAIiB,IAAI,CAACC,YAAT,CAAsB,OAAtB,EAA+B;AAAEH,IAAAA,qBAAqB,EAArBA;AAAF,GAA/B,EAA0DI,MAA1D,CAAiEH,GAAjE,CAAP;AACD;AAED,OAAO,SAASI,iBAAT,CAA2BC,KAA3B,EAAqD;AAAA,MAAXC,KAAW,uEAAH,CAAG;AAC1D,MAAID,KAAK,GAAG,GAAZ,EAAiB,OAAOA,KAAP;AACjB,MAAIA,KAAK,IAAI,GAAT,IAAgBA,KAAK,GAAG,GAA5B,EAAiC,OAAO,CAAC,CAACA,KAAK,GAAG,GAAT,EAAcE,OAAd,CAAsBD,KAAtB,CAAD,GAAgC,GAAvC;AACjC,MAAID,KAAK,IAAI,GAAT,IAAgBA,KAAK,GAAG,GAA5B,EAAiC,OAAO,CAAC,CAACA,KAAK,GAAG,GAAT,EAAcE,OAAd,CAAsBD,KAAtB,CAAD,GAAgC,GAAvC;AACjC,MAAID,KAAK,IAAI,GAAT,IAAgBA,KAAK,GAAG,IAA5B,EAAkC,OAAO,CAAC,CAACA,KAAK,GAAG,GAAT,EAAcE,OAAd,CAAsBD,KAAtB,CAAD,GAAgC,GAAvC;AAClC,MAAID,KAAK,IAAI,IAAb,EAAmB,OAAO,CAAC,CAACA,KAAK,GAAG,IAAT,EAAeE,OAAf,CAAuBD,KAAvB,CAAD,GAAiC,GAAxC;AACpB;AAED,OAAO,SAASE,oBAAT,CACLC,GADK,EAELC,QAFK,EAGG;AACR,MAAIC,SAAJ;AACA,MAAI,OAAOF,GAAP,KAAe,QAAnB,EAA6BE,SAAS,GAAGC,QAAQ,CAACH,GAAD,EAAM,EAAN,CAApB,CAA7B,KACKE,SAAS,GAAGF,GAAZ;AACL,SAAOE,SAAS,GAAG1B,IAAI,CAAC4B,GAAL,CAAS,EAAT,EAAaH,QAAb,CAAnB;AACD","sourcesContent":["import BN from \"bn.js\";\n\nexport const LAMPORTS_PER_SOL = 1000000000;\n\nexport function lamportsToSol(lamports: number | BN): number {\n  if (typeof lamports === \"number\") {\n    return Math.abs(lamports) / LAMPORTS_PER_SOL;\n  }\n\n  let signMultiplier = 1;\n  if (lamports.isNeg()) {\n    signMultiplier = -1;\n  }\n\n  const absLamports = lamports.abs();\n  const lamportsString = absLamports.toString(10).padStart(10, \"0\");\n  const splitIndex = lamportsString.length - 9;\n  const solString =\n    lamportsString.slice(0, splitIndex) +\n    \".\" +\n    lamportsString.slice(splitIndex);\n  return signMultiplier * parseFloat(solString);\n}\n\nexport function lamportsToSolString(\n  lamports: number | BN,\n  maximumFractionDigits: number = 9\n): string {\n  const sol = lamportsToSol(lamports);\n  return new Intl.NumberFormat(\"en-US\", { maximumFractionDigits }).format(sol);\n}\n\nexport function abbreviatedNumber(value: number, fixed = 1) {\n  if (value < 1e3) return value;\n  if (value >= 1e3 && value < 1e6) return +(value / 1e3).toFixed(fixed) + \"K\";\n  if (value >= 1e6 && value < 1e9) return +(value / 1e6).toFixed(fixed) + \"M\";\n  if (value >= 1e9 && value < 1e12) return +(value / 1e9).toFixed(fixed) + \"B\";\n  if (value >= 1e12) return +(value / 1e12).toFixed(fixed) + \"T\";\n}\n\nexport function normalizeTokenAmount(\n  raw: string | number,\n  decimals: number\n): number {\n  let rawTokens: number;\n  if (typeof raw === \"string\") rawTokens = parseInt(raw, 10);\n  else rawTokens = raw;\n  return rawTokens / Math.pow(10, decimals);\n}\n"]},"metadata":{},"sourceType":"module"}
import { getLastItem } from "./array";
import { isArray, isObject } from "./assertion";
import { objectKeys } from "./object";
export var breakpoints = Object.freeze(["base", "sm", "md", "lg", "xl", "2xl"]);
export function mapResponsive(prop, mapper) {
  if (isArray(prop)) {
    return prop.map(item => {
      if (item === null) {
        return null;
      }

      return mapper(item);
    });
  }

  if (isObject(prop)) {
    return objectKeys(prop).reduce((result, key) => {
      result[key] = mapper(prop[key]);
      return result;
    }, {});
  }

  if (prop != null) {
    return mapper(prop);
  }

  return null;
}
export function objectToArrayNotation(obj, bps) {
  if (bps === void 0) {
    bps = breakpoints;
  }

  var result = bps.map(br => {
    var _obj$br;

    return (_obj$br = obj[br]) != null ? _obj$br : null;
  });

  while (getLastItem(result) === null) {
    result.pop();
  }

  return result;
}
export function arrayToObjectNotation(values, bps) {
  if (bps === void 0) {
    bps = breakpoints;
  }

  var result = {};
  values.forEach((value, index) => {
    var key = bps[index];
    if (value == null) return;
    result[key] = value;
  });
  return result;
}
export function isResponsiveObjectLike(obj, bps) {
  if (bps === void 0) {
    bps = breakpoints;
  }

  var keys = Object.keys(obj);
  return keys.length > 0 && keys.every(key => bps.includes(key));
}
/**
 * since breakpoints are defined as custom properties on an array, you may
 * `Object.keys(theme.breakpoints)` to retrieve both regular numeric indices
 * and custom breakpoints as string.
 *
 * This function returns true given a custom array property.
 */

export var isCustomBreakpoint = maybeBreakpoint => Number.isNaN(Number(maybeBreakpoint));
//# sourceMappingURL=responsive.js.map
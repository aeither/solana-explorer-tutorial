{"ast":null,"code":"import _toArray from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _createClass from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _createForOfIteratorHelper from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _objectSpread from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectWithoutProperties from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _classCallCheck from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nvar _excluded = [\"message\"];\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(toFailures),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(run);\n\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nvar StructError = /*#__PURE__*/function (_TypeError) {\n  _inherits(StructError, _TypeError);\n\n  var _super = _createSuper(StructError);\n\n  function StructError(failure, failures) {\n    var _this;\n\n    _classCallCheck(this, StructError);\n\n    var cached;\n\n    var message = failure.message,\n        rest = _objectWithoutProperties(failure, _excluded);\n\n    var path = failure.path;\n    var msg = path.length === 0 ? message : \"At path: \" + path.join('.') + \" -- \" + message;\n    _this = _super.call(this, msg);\n    Object.assign(_assertThisInitialized(_this), rest);\n    _this.name = _this.constructor.name;\n\n    _this.failures = function () {\n      var _cached;\n\n      return (_cached = cached) != null ? _cached : cached = [failure].concat(_toConsumableArray(failures()));\n    };\n\n    return _this;\n  }\n\n  return StructError;\n}( /*#__PURE__*/_wrapNativeSuper(TypeError));\n/**\n * Check if a value is an iterator.\n */\n\n\nfunction isIterable(x) {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\n\n\nfunction isObject(x) {\n  return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\n\n\nfunction isPlainObject(x) {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(x);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\n\n\nfunction print(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\n\nfunction shiftIterator(input) {\n  var _input$next = input.next(),\n      done = _input$next.done,\n      value = _input$next.value;\n\n  return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\n\n\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === 'string') {\n    result = {\n      message: result\n    };\n  }\n\n  var path = context.path,\n      branch = context.branch;\n  var type = struct.type;\n  var _result = result,\n      refinement = _result.refinement,\n      _result$message = _result.message,\n      message = _result$message === void 0 ? \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : '') + \", but received: `\" + print(value) + \"`\" : _result$message;\n  return _objectSpread(_objectSpread({\n    value: value,\n    type: type,\n    refinement: refinement,\n    key: path[path.length - 1],\n    path: path,\n    branch: branch\n  }, result), {}, {\n    message: message\n  });\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\n\n\nfunction toFailures(result, context, struct, value) {\n  var _iterator, _step, r, failure;\n\n  return _regeneratorRuntime.wrap(function toFailures$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!isIterable(result)) {\n            result = [result];\n          }\n\n          _iterator = _createForOfIteratorHelper(result);\n          _context.prev = 2;\n\n          _iterator.s();\n\n        case 4:\n          if ((_step = _iterator.n()).done) {\n            _context.next = 12;\n            break;\n          }\n\n          r = _step.value;\n          failure = toFailure(r, context, struct, value);\n\n          if (!failure) {\n            _context.next = 10;\n            break;\n          }\n\n          _context.next = 10;\n          return failure;\n\n        case 10:\n          _context.next = 4;\n          break;\n\n        case 12:\n          _context.next = 17;\n          break;\n\n        case 14:\n          _context.prev = 14;\n          _context.t0 = _context[\"catch\"](2);\n\n          _iterator.e(_context.t0);\n\n        case 17:\n          _context.prev = 17;\n\n          _iterator.f();\n\n          return _context.finish(17);\n\n        case 20:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[2, 14, 17, 20]]);\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\n\nfunction run(value, struct) {\n  var options,\n      _options$path,\n      path,\n      _options$branch,\n      branch,\n      _options$coerce,\n      coerce,\n      _options$mask,\n      mask,\n      ctx,\n      key,\n      valid,\n      _iterator2,\n      _step2,\n      _failure,\n      _iterator3,\n      _step3,\n      _step3$value,\n      k,\n      v,\n      s,\n      ts,\n      _iterator5,\n      _step5,\n      t,\n      _iterator4,\n      _step4,\n      failure,\n      _args2 = arguments;\n\n  return _regeneratorRuntime.wrap(function run$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n          _options$path = options.path, path = _options$path === void 0 ? [] : _options$path, _options$branch = options.branch, branch = _options$branch === void 0 ? [value] : _options$branch, _options$coerce = options.coerce, coerce = _options$coerce === void 0 ? false : _options$coerce, _options$mask = options.mask, mask = _options$mask === void 0 ? false : _options$mask;\n          ctx = {\n            path: path,\n            branch: branch\n          };\n\n          if (coerce) {\n            value = struct.coercer(value, ctx);\n\n            if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n              for (key in value) {\n                if (struct.schema[key] === undefined) {\n                  delete value[key];\n                }\n              }\n            }\n          }\n\n          valid = true;\n          _iterator2 = _createForOfIteratorHelper(struct.validator(value, ctx));\n          _context2.prev = 6;\n\n          _iterator2.s();\n\n        case 8:\n          if ((_step2 = _iterator2.n()).done) {\n            _context2.next = 15;\n            break;\n          }\n\n          _failure = _step2.value;\n          valid = false;\n          _context2.next = 13;\n          return [_failure, undefined];\n\n        case 13:\n          _context2.next = 8;\n          break;\n\n        case 15:\n          _context2.next = 20;\n          break;\n\n        case 17:\n          _context2.prev = 17;\n          _context2.t0 = _context2[\"catch\"](6);\n\n          _iterator2.e(_context2.t0);\n\n        case 20:\n          _context2.prev = 20;\n\n          _iterator2.f();\n\n          return _context2.finish(20);\n\n        case 23:\n          _iterator3 = _createForOfIteratorHelper(struct.entries(value, ctx));\n          _context2.prev = 24;\n\n          _iterator3.s();\n\n        case 26:\n          if ((_step3 = _iterator3.n()).done) {\n            _context2.next = 53;\n            break;\n          }\n\n          _step3$value = _slicedToArray(_step3.value, 3), k = _step3$value[0], v = _step3$value[1], s = _step3$value[2];\n          ts = run(v, s, {\n            path: k === undefined ? path : [].concat(_toConsumableArray(path), [k]),\n            branch: k === undefined ? branch : [].concat(_toConsumableArray(branch), [v]),\n            coerce: coerce,\n            mask: mask\n          });\n          _iterator5 = _createForOfIteratorHelper(ts);\n          _context2.prev = 30;\n\n          _iterator5.s();\n\n        case 32:\n          if ((_step5 = _iterator5.n()).done) {\n            _context2.next = 43;\n            break;\n          }\n\n          t = _step5.value;\n\n          if (!t[0]) {\n            _context2.next = 40;\n            break;\n          }\n\n          valid = false;\n          _context2.next = 38;\n          return [t[0], undefined];\n\n        case 38:\n          _context2.next = 41;\n          break;\n\n        case 40:\n          if (coerce) {\n            v = t[1];\n\n            if (k === undefined) {\n              value = v;\n            } else if (value instanceof Map) {\n              value.set(k, v);\n            } else if (value instanceof Set) {\n              value.add(v);\n            } else if (isObject(value)) {\n              value[k] = v;\n            }\n          }\n\n        case 41:\n          _context2.next = 32;\n          break;\n\n        case 43:\n          _context2.next = 48;\n          break;\n\n        case 45:\n          _context2.prev = 45;\n          _context2.t1 = _context2[\"catch\"](30);\n\n          _iterator5.e(_context2.t1);\n\n        case 48:\n          _context2.prev = 48;\n\n          _iterator5.f();\n\n          return _context2.finish(48);\n\n        case 51:\n          _context2.next = 26;\n          break;\n\n        case 53:\n          _context2.next = 58;\n          break;\n\n        case 55:\n          _context2.prev = 55;\n          _context2.t2 = _context2[\"catch\"](24);\n\n          _iterator3.e(_context2.t2);\n\n        case 58:\n          _context2.prev = 58;\n\n          _iterator3.f();\n\n          return _context2.finish(58);\n\n        case 61:\n          if (!valid) {\n            _context2.next = 80;\n            break;\n          }\n\n          _iterator4 = _createForOfIteratorHelper(struct.refiner(value, ctx));\n          _context2.prev = 63;\n\n          _iterator4.s();\n\n        case 65:\n          if ((_step4 = _iterator4.n()).done) {\n            _context2.next = 72;\n            break;\n          }\n\n          failure = _step4.value;\n          valid = false;\n          _context2.next = 70;\n          return [failure, undefined];\n\n        case 70:\n          _context2.next = 65;\n          break;\n\n        case 72:\n          _context2.next = 77;\n          break;\n\n        case 74:\n          _context2.prev = 74;\n          _context2.t3 = _context2[\"catch\"](63);\n\n          _iterator4.e(_context2.t3);\n\n        case 77:\n          _context2.prev = 77;\n\n          _iterator4.f();\n\n          return _context2.finish(77);\n\n        case 80:\n          if (!valid) {\n            _context2.next = 83;\n            break;\n          }\n\n          _context2.next = 83;\n          return [undefined, value];\n\n        case 83:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[6, 17, 20, 23], [24, 55, 58, 61], [30, 45, 48, 51], [63, 74, 77, 80]]);\n}\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\n\nvar Struct = /*#__PURE__*/function () {\n  function Struct(props) {\n    var _this2 = this;\n\n    _classCallCheck(this, Struct);\n\n    var type = props.type,\n        schema = props.schema,\n        validator = props.validator,\n        refiner = props.refiner,\n        _props$coercer = props.coercer,\n        coercer = _props$coercer === void 0 ? function (value) {\n      return value;\n    } : _props$coercer,\n        _props$entries = props.entries,\n        entries = _props$entries === void 0 ? /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      return _regeneratorRuntime.wrap(function _callee$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee);\n    }) : _props$entries;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n\n    if (validator) {\n      this.validator = function (value, context) {\n        var result = validator(value, context);\n        return toFailures(result, context, _this2, value);\n      };\n    } else {\n      this.validator = function () {\n        return [];\n      };\n    }\n\n    if (refiner) {\n      this.refiner = function (value, context) {\n        var result = refiner(value, context);\n        return toFailures(result, context, _this2, value);\n      };\n    } else {\n      this.refiner = function () {\n        return [];\n      };\n    }\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n\n  _createClass(Struct, [{\n    key: \"assert\",\n    value: function assert(value) {\n      return _assert(value, this);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(value) {\n      return _create(value, this);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(value) {\n      return _is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n\n  }, {\n    key: \"mask\",\n    value: function mask(value) {\n      return _mask(value, this);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate(value) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return _validate(value, this, options);\n    }\n  }]);\n\n  return Struct;\n}();\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\n\n\nfunction _assert(value, struct) {\n  var result = _validate(value, struct);\n\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\n\nfunction _create(value, struct) {\n  var result = _validate(value, struct, {\n    coerce: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\n\nfunction _mask(value, struct) {\n  var result = _validate(value, struct, {\n    coerce: true,\n    mask: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Check if a value passes a struct.\n */\n\n\nfunction _is(value, struct) {\n  var result = _validate(value, struct);\n\n  return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\n\nfunction _validate(value, struct) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var tuples = run(value, struct, options);\n  var tuple = shiftIterator(tuples);\n\n  if (tuple[0]) {\n    var error = new StructError(tuple[0], /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var _iterator6, _step6, t;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _iterator6 = _createForOfIteratorHelper(tuples);\n              _context4.prev = 1;\n\n              _iterator6.s();\n\n            case 3:\n              if ((_step6 = _iterator6.n()).done) {\n                _context4.next = 10;\n                break;\n              }\n\n              t = _step6.value;\n\n              if (!t[0]) {\n                _context4.next = 8;\n                break;\n              }\n\n              _context4.next = 8;\n              return t[0];\n\n            case 8:\n              _context4.next = 3;\n              break;\n\n            case 10:\n              _context4.next = 15;\n              break;\n\n            case 12:\n              _context4.prev = 12;\n              _context4.t0 = _context4[\"catch\"](1);\n\n              _iterator6.e(_context4.t0);\n\n            case 15:\n              _context4.prev = 15;\n\n              _iterator6.f();\n\n              return _context4.finish(15);\n\n            case 18:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee2, null, [[1, 12, 15, 18]]);\n    }));\n    return [error, undefined];\n  } else {\n    var v = tuple[1];\n    return [undefined, v];\n  }\n}\n\nfunction assign() {\n  for (var _len = arguments.length, Structs = new Array(_len), _key = 0; _key < _len; _key++) {\n    Structs[_key] = arguments[_key];\n  }\n\n  var schemas = Structs.map(function (s) {\n    return s.schema;\n  });\n  var schema = Object.assign.apply(Object, [{}].concat(_toConsumableArray(schemas)));\n  return object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\n\n\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator: validator\n  });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\n\n\nfunction deprecated(struct, log) {\n  return new Struct(_objectSpread(_objectSpread({}, struct), {}, {\n    refiner: function refiner(value, ctx) {\n      return value === undefined || struct.refiner(value, ctx);\n    },\n    validator: function validator(value, ctx) {\n      if (value === undefined) {\n        return true;\n      } else {\n        log(value, ctx);\n        return struct.validator(value, ctx);\n      }\n    }\n  }));\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\n\nfunction dynamic(fn) {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime.mark(function entries(value, ctx) {\n      var struct;\n      return _regeneratorRuntime.wrap(function entries$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              struct = fn(value, ctx);\n              return _context5.delegateYield(struct.entries(value, ctx), \"t0\", 2);\n\n            case 2:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, entries);\n    }),\n    validator: function validator(value, ctx) {\n      var struct = fn(value, ctx);\n      return struct.validator(value, ctx);\n    },\n    coercer: function coercer(value, ctx) {\n      var struct = fn(value, ctx);\n      return struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\n\nfunction lazy(fn) {\n  var struct;\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime.mark(function entries(value, ctx) {\n      var _struct;\n\n      return _regeneratorRuntime.wrap(function entries$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              (_struct = struct) != null ? _struct : struct = fn();\n              return _context6.delegateYield(struct.entries(value, ctx), \"t0\", 2);\n\n            case 2:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, entries);\n    }),\n    validator: function validator(value, ctx) {\n      var _struct2;\n\n      (_struct2 = struct) != null ? _struct2 : struct = fn();\n      return struct.validator(value, ctx);\n    },\n    coercer: function coercer(value, ctx) {\n      var _struct3;\n\n      (_struct3 = struct) != null ? _struct3 : struct = fn();\n      return struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\n\nfunction omit(struct, keys) {\n  var schema = struct.schema;\n\n  var subschema = _objectSpread({}, schema);\n\n  var _iterator7 = _createForOfIteratorHelper(keys),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var key = _step7.value;\n      delete subschema[key];\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  return object(subschema);\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\n\nfunction partial(struct) {\n  var schema = struct instanceof Struct ? _objectSpread({}, struct.schema) : _objectSpread({}, struct);\n\n  for (var key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n\n  return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\n\nfunction pick(struct, keys) {\n  var schema = struct.schema;\n  var subschema = {};\n\n  var _iterator8 = _createForOfIteratorHelper(keys),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var key = _step8.value;\n      subschema[key] = schema[key];\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\n\nfunction struct(name, validator) {\n  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n  return define(name, validator);\n}\n/**\n * Ensure that any value passes validation.\n */\n\n\nfunction any() {\n  return define('any', function () {\n    return true;\n  });\n}\n\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    entries: /*#__PURE__*/_regeneratorRuntime.mark(function entries(value) {\n      var _iterator9, _step9, _step9$value, i, v;\n\n      return _regeneratorRuntime.wrap(function entries$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              if (!(Element && Array.isArray(value))) {\n                _context7.next = 18;\n                break;\n              }\n\n              _iterator9 = _createForOfIteratorHelper(value.entries());\n              _context7.prev = 2;\n\n              _iterator9.s();\n\n            case 4:\n              if ((_step9 = _iterator9.n()).done) {\n                _context7.next = 10;\n                break;\n              }\n\n              _step9$value = _slicedToArray(_step9.value, 2), i = _step9$value[0], v = _step9$value[1];\n              _context7.next = 8;\n              return [i, v, Element];\n\n            case 8:\n              _context7.next = 4;\n              break;\n\n            case 10:\n              _context7.next = 15;\n              break;\n\n            case 12:\n              _context7.prev = 12;\n              _context7.t0 = _context7[\"catch\"](2);\n\n              _iterator9.e(_context7.t0);\n\n            case 15:\n              _context7.prev = 15;\n\n              _iterator9.f();\n\n              return _context7.finish(15);\n\n            case 18:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, entries, null, [[2, 12, 15, 18]]);\n    }),\n    coercer: function coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n    validator: function validator(value) {\n      return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\n\n\nfunction boolean() {\n  return define('boolean', function (value) {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\n\nfunction date() {\n  return define('date', function (value) {\n    return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n  });\n}\n\nfunction enums(values) {\n  var schema = {};\n  var description = values.map(function (v) {\n    return print(v);\n  }).join();\n\n  var _iterator10 = _createForOfIteratorHelper(values),\n      _step10;\n\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var key = _step10.value;\n      schema[key] = key;\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema: schema,\n    validator: function validator(value) {\n      return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a function.\n */\n\n\nfunction func() {\n  return define('func', function (value) {\n    return typeof value === 'function' || \"Expected a function, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\n\nfunction instance(Class) {\n  return define('instance', function (value) {\n    return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an integer.\n */\n\n\nfunction integer() {\n  return define('integer', function (value) {\n    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n  });\n}\n\nfunction intersection(Structs) {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime.mark(function entries(value, ctx) {\n      var _iterator11, _step11, S;\n\n      return _regeneratorRuntime.wrap(function entries$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              _iterator11 = _createForOfIteratorHelper(Structs);\n              _context8.prev = 1;\n\n              _iterator11.s();\n\n            case 3:\n              if ((_step11 = _iterator11.n()).done) {\n                _context8.next = 8;\n                break;\n              }\n\n              S = _step11.value;\n              return _context8.delegateYield(S.entries(value, ctx), \"t0\", 6);\n\n            case 6:\n              _context8.next = 3;\n              break;\n\n            case 8:\n              _context8.next = 13;\n              break;\n\n            case 10:\n              _context8.prev = 10;\n              _context8.t1 = _context8[\"catch\"](1);\n\n              _iterator11.e(_context8.t1);\n\n            case 13:\n              _context8.prev = 13;\n\n              _iterator11.f();\n\n              return _context8.finish(13);\n\n            case 16:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, entries, null, [[1, 10, 13, 16]]);\n    }),\n    validator: /*#__PURE__*/_regeneratorRuntime.mark(function validator(value, ctx) {\n      var _iterator12, _step12, S;\n\n      return _regeneratorRuntime.wrap(function validator$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              _iterator12 = _createForOfIteratorHelper(Structs);\n              _context9.prev = 1;\n\n              _iterator12.s();\n\n            case 3:\n              if ((_step12 = _iterator12.n()).done) {\n                _context9.next = 8;\n                break;\n              }\n\n              S = _step12.value;\n              return _context9.delegateYield(S.validator(value, ctx), \"t0\", 6);\n\n            case 6:\n              _context9.next = 3;\n              break;\n\n            case 8:\n              _context9.next = 13;\n              break;\n\n            case 10:\n              _context9.prev = 10;\n              _context9.t1 = _context9[\"catch\"](1);\n\n              _iterator12.e(_context9.t1);\n\n            case 13:\n              _context9.prev = 13;\n\n              _iterator12.f();\n\n              return _context9.finish(13);\n\n            case 16:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, validator, null, [[1, 10, 13, 16]]);\n    }),\n    refiner: /*#__PURE__*/_regeneratorRuntime.mark(function refiner(value, ctx) {\n      var _iterator13, _step13, S;\n\n      return _regeneratorRuntime.wrap(function refiner$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              _iterator13 = _createForOfIteratorHelper(Structs);\n              _context10.prev = 1;\n\n              _iterator13.s();\n\n            case 3:\n              if ((_step13 = _iterator13.n()).done) {\n                _context10.next = 8;\n                break;\n              }\n\n              S = _step13.value;\n              return _context10.delegateYield(S.refiner(value, ctx), \"t0\", 6);\n\n            case 6:\n              _context10.next = 3;\n              break;\n\n            case 8:\n              _context10.next = 13;\n              break;\n\n            case 10:\n              _context10.prev = 10;\n              _context10.t1 = _context10[\"catch\"](1);\n\n              _iterator13.e(_context10.t1);\n\n            case 13:\n              _context10.prev = 13;\n\n              _iterator13.f();\n\n              return _context10.finish(13);\n\n            case 16:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, refiner, null, [[1, 10, 13, 16]]);\n    })\n  });\n}\n\nfunction literal(constant) {\n  var description = print(constant);\n  var t = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n    validator: function validator(value) {\n      return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n    }\n  });\n}\n\nfunction map(Key, Value) {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime.mark(function entries(value) {\n      var _iterator14, _step14, _step14$value, k, v;\n\n      return _regeneratorRuntime.wrap(function entries$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              if (!(Key && Value && value instanceof Map)) {\n                _context11.next = 20;\n                break;\n              }\n\n              _iterator14 = _createForOfIteratorHelper(value.entries());\n              _context11.prev = 2;\n\n              _iterator14.s();\n\n            case 4:\n              if ((_step14 = _iterator14.n()).done) {\n                _context11.next = 12;\n                break;\n              }\n\n              _step14$value = _slicedToArray(_step14.value, 2), k = _step14$value[0], v = _step14$value[1];\n              _context11.next = 8;\n              return [k, k, Key];\n\n            case 8:\n              _context11.next = 10;\n              return [k, v, Value];\n\n            case 10:\n              _context11.next = 4;\n              break;\n\n            case 12:\n              _context11.next = 17;\n              break;\n\n            case 14:\n              _context11.prev = 14;\n              _context11.t0 = _context11[\"catch\"](2);\n\n              _iterator14.e(_context11.t0);\n\n            case 17:\n              _context11.prev = 17;\n\n              _iterator14.f();\n\n              return _context11.finish(17);\n\n            case 20:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, entries, null, [[2, 14, 17, 20]]);\n    }),\n    coercer: function coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n    validator: function validator(value) {\n      return value instanceof Map || \"Expected a `Map` object, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that no value ever passes validation.\n */\n\n\nfunction never() {\n  return define('never', function () {\n    return false;\n  });\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\n\n\nfunction nullable(struct) {\n  return new Struct(_objectSpread(_objectSpread({}, struct), {}, {\n    validator: function validator(value, ctx) {\n      return value === null || struct.validator(value, ctx);\n    },\n    refiner: function refiner(value, ctx) {\n      return value === null || struct.refiner(value, ctx);\n    }\n  }));\n}\n/**\n * Ensure that a value is a number.\n */\n\n\nfunction number() {\n  return define('number', function (value) {\n    return typeof value === 'number' && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n  });\n}\n\nfunction object(schema) {\n  var knowns = schema ? Object.keys(schema) : [];\n  var Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n    entries: /*#__PURE__*/_regeneratorRuntime.mark(function entries(value) {\n      var unknowns, _iterator15, _step15, key, _iterator16, _step16, _key2;\n\n      return _regeneratorRuntime.wrap(function entries$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              if (!(schema && isObject(value))) {\n                _context12.next = 37;\n                break;\n              }\n\n              unknowns = new Set(Object.keys(value));\n              _iterator15 = _createForOfIteratorHelper(knowns);\n              _context12.prev = 3;\n\n              _iterator15.s();\n\n            case 5:\n              if ((_step15 = _iterator15.n()).done) {\n                _context12.next = 12;\n                break;\n              }\n\n              key = _step15.value;\n              unknowns.delete(key);\n              _context12.next = 10;\n              return [key, value[key], schema[key]];\n\n            case 10:\n              _context12.next = 5;\n              break;\n\n            case 12:\n              _context12.next = 17;\n              break;\n\n            case 14:\n              _context12.prev = 14;\n              _context12.t0 = _context12[\"catch\"](3);\n\n              _iterator15.e(_context12.t0);\n\n            case 17:\n              _context12.prev = 17;\n\n              _iterator15.f();\n\n              return _context12.finish(17);\n\n            case 20:\n              _iterator16 = _createForOfIteratorHelper(unknowns);\n              _context12.prev = 21;\n\n              _iterator16.s();\n\n            case 23:\n              if ((_step16 = _iterator16.n()).done) {\n                _context12.next = 29;\n                break;\n              }\n\n              _key2 = _step16.value;\n              _context12.next = 27;\n              return [_key2, value[_key2], Never];\n\n            case 27:\n              _context12.next = 23;\n              break;\n\n            case 29:\n              _context12.next = 34;\n              break;\n\n            case 31:\n              _context12.prev = 31;\n              _context12.t1 = _context12[\"catch\"](21);\n\n              _iterator16.e(_context12.t1);\n\n            case 34:\n              _context12.prev = 34;\n\n              _iterator16.f();\n\n              return _context12.finish(34);\n\n            case 37:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, entries, null, [[3, 14, 17, 20], [21, 31, 34, 37]]);\n    }),\n    validator: function validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    },\n    coercer: function coercer(value) {\n      return isObject(value) ? _objectSpread({}, value) : value;\n    }\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\n\n\nfunction optional(struct) {\n  return new Struct(_objectSpread(_objectSpread({}, struct), {}, {\n    validator: function validator(value, ctx) {\n      return value === undefined || struct.validator(value, ctx);\n    },\n    refiner: function refiner(value, ctx) {\n      return value === undefined || struct.refiner(value, ctx);\n    }\n  }));\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\n\nfunction record(Key, Value) {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime.mark(function entries(value) {\n      var k, v;\n      return _regeneratorRuntime.wrap(function entries$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              if (!isObject(value)) {\n                _context13.next = 11;\n                break;\n              }\n\n              _context13.t0 = _regeneratorRuntime.keys(value);\n\n            case 2:\n              if ((_context13.t1 = _context13.t0()).done) {\n                _context13.next = 11;\n                break;\n              }\n\n              k = _context13.t1.value;\n              v = value[k];\n              _context13.next = 7;\n              return [k, k, Key];\n\n            case 7:\n              _context13.next = 9;\n              return [k, v, Value];\n\n            case 9:\n              _context13.next = 2;\n              break;\n\n            case 11:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n      }, entries);\n    }),\n    validator: function validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\n\nfunction regexp() {\n  return define('regexp', function (value) {\n    return value instanceof RegExp;\n  });\n}\n\nfunction set(Element) {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime.mark(function entries(value) {\n      var _iterator17, _step17, v;\n\n      return _regeneratorRuntime.wrap(function entries$(_context14) {\n        while (1) {\n          switch (_context14.prev = _context14.next) {\n            case 0:\n              if (!(Element && value instanceof Set)) {\n                _context14.next = 18;\n                break;\n              }\n\n              _iterator17 = _createForOfIteratorHelper(value);\n              _context14.prev = 2;\n\n              _iterator17.s();\n\n            case 4:\n              if ((_step17 = _iterator17.n()).done) {\n                _context14.next = 10;\n                break;\n              }\n\n              v = _step17.value;\n              _context14.next = 8;\n              return [v, v, Element];\n\n            case 8:\n              _context14.next = 4;\n              break;\n\n            case 10:\n              _context14.next = 15;\n              break;\n\n            case 12:\n              _context14.prev = 12;\n              _context14.t0 = _context14[\"catch\"](2);\n\n              _iterator17.e(_context14.t0);\n\n            case 15:\n              _context14.prev = 15;\n\n              _iterator17.f();\n\n              return _context14.finish(15);\n\n            case 18:\n            case \"end\":\n              return _context14.stop();\n          }\n        }\n      }, entries, null, [[2, 12, 15, 18]]);\n    }),\n    coercer: function coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n    validator: function validator(value) {\n      return value instanceof Set || \"Expected a `Set` object, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a string.\n */\n\n\nfunction string() {\n  return define('string', function (value) {\n    return typeof value === 'string' || \"Expected a string, but received: \" + print(value);\n  });\n}\n\nfunction tuple(Elements) {\n  var Never = never();\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime.mark(function entries(value) {\n      var length, i;\n      return _regeneratorRuntime.wrap(function entries$(_context15) {\n        while (1) {\n          switch (_context15.prev = _context15.next) {\n            case 0:\n              if (!Array.isArray(value)) {\n                _context15.next = 9;\n                break;\n              }\n\n              length = Math.max(Elements.length, value.length);\n              i = 0;\n\n            case 3:\n              if (!(i < length)) {\n                _context15.next = 9;\n                break;\n              }\n\n              _context15.next = 6;\n              return [i, value[i], Elements[i] || Never];\n\n            case 6:\n              i++;\n              _context15.next = 3;\n              break;\n\n            case 9:\n            case \"end\":\n              return _context15.stop();\n          }\n        }\n      }, entries);\n    }),\n    validator: function validator(value) {\n      return Array.isArray(value) || \"Expected an array, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\n\nfunction type(schema) {\n  var keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema: schema,\n    entries: /*#__PURE__*/_regeneratorRuntime.mark(function entries(value) {\n      var _iterator18, _step18, k;\n\n      return _regeneratorRuntime.wrap(function entries$(_context16) {\n        while (1) {\n          switch (_context16.prev = _context16.next) {\n            case 0:\n              if (!isObject(value)) {\n                _context16.next = 18;\n                break;\n              }\n\n              _iterator18 = _createForOfIteratorHelper(keys);\n              _context16.prev = 2;\n\n              _iterator18.s();\n\n            case 4:\n              if ((_step18 = _iterator18.n()).done) {\n                _context16.next = 10;\n                break;\n              }\n\n              k = _step18.value;\n              _context16.next = 8;\n              return [k, value[k], schema[k]];\n\n            case 8:\n              _context16.next = 4;\n              break;\n\n            case 10:\n              _context16.next = 15;\n              break;\n\n            case 12:\n              _context16.prev = 12;\n              _context16.t0 = _context16[\"catch\"](2);\n\n              _iterator18.e(_context16.t0);\n\n            case 15:\n              _context16.prev = 15;\n\n              _iterator18.f();\n\n              return _context16.finish(15);\n\n            case 18:\n            case \"end\":\n              return _context16.stop();\n          }\n        }\n      }, entries, null, [[2, 12, 15, 18]]);\n    }),\n    validator: function validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n  });\n}\n\nfunction union(Structs) {\n  var description = Structs.map(function (s) {\n    return s.type;\n  }).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n    validator: function validator(value, ctx) {\n      var failures = [];\n\n      var _iterator19 = _createForOfIteratorHelper(Structs),\n          _step19;\n\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var S = _step19.value;\n\n          var _run = run(value, S, ctx),\n              _run2 = _toArray(_run),\n              tuples = _run2.slice(0);\n\n          var _tuples = _slicedToArray(tuples, 1),\n              first = _tuples[0];\n\n          if (!first[0]) {\n            return [];\n          } else {\n            var _iterator20 = _createForOfIteratorHelper(tuples),\n                _step20;\n\n            try {\n              for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                var _step20$value = _slicedToArray(_step20.value, 1),\n                    failure = _step20$value[0];\n\n                if (failure) {\n                  failures.push(failure);\n                }\n              }\n            } catch (err) {\n              _iterator20.e(err);\n            } finally {\n              _iterator20.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n\n      return [\"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value)].concat(failures);\n    }\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\n\nfunction unknown() {\n  return define('unknown', function () {\n    return true;\n  });\n}\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\n\nfunction coerce(struct, condition, _coercer) {\n  return new Struct(_objectSpread(_objectSpread({}, struct), {}, {\n    coercer: function coercer(value, ctx) {\n      return _is(value, condition) ? struct.coercer(_coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  }));\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\n\nfunction defaulted(struct, fallback) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return coerce(struct, unknown(), function (x) {\n    var f = typeof fallback === 'function' ? fallback() : fallback;\n\n    if (x === undefined) {\n      return f;\n    }\n\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      var ret = _objectSpread({}, x);\n\n      var changed = false;\n\n      for (var key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        return ret;\n      }\n    }\n\n    return x;\n  });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\n\nfunction trimmed(struct) {\n  return coerce(struct, string(), function (x) {\n    return x.trim();\n  });\n}\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\n\nfunction empty(struct) {\n  var expected = \"Expected an empty \" + struct.type;\n  return refine(struct, 'empty', function (value) {\n    if (value instanceof Map || value instanceof Set) {\n      var _size = value.size;\n      return _size === 0 || expected + \" but received one with a size of `\" + _size + \"`\";\n    } else {\n      var length = value.length;\n      return length === 0 || expected + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\n\n\nfunction max(struct, threshold) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var exclusive = options.exclusive;\n  return refine(struct, 'max', function (value) {\n    return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\n\n\nfunction min(struct, threshold) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var exclusive = options.exclusive;\n  return refine(struct, 'min', function (value) {\n    return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\n\n\nfunction pattern(struct, regexp) {\n  return refine(struct, 'pattern', function (value) {\n    return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + \"/` but received \\\"\" + value + \"\\\"\";\n  });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\n\nfunction size(struct, min) {\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : min;\n  var expected = \"Expected a \" + struct.type;\n  var of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n  return refine(struct, 'size', function (value) {\n    if (typeof value === 'number' || value instanceof Date) {\n      return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n    } else if (value instanceof Map || value instanceof Set) {\n      var _size2 = value.size;\n      return min <= _size2 && _size2 <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + _size2 + \"`\";\n    } else {\n      var length = value.length;\n      return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\n\nfunction refine(struct, name, refiner) {\n  return new Struct(_objectSpread(_objectSpread({}, struct), {}, {\n    refiner: function (_refiner) {\n      var _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(refiner);\n\n      function refiner(_x, _x2) {\n        var _args17 = arguments;\n        return _regeneratorRuntime.wrap(function refiner$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                return _context17.delegateYield(_refiner.apply(this, _args17), \"t0\", 1);\n\n              case 1:\n                return _context17.abrupt(\"return\", _context17.t0);\n\n              case 2:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _marked3, this);\n      }\n\n      refiner.toString = function () {\n        return _refiner.toString();\n      };\n\n      return refiner;\n    }( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(value, ctx) {\n      var result, failures, _iterator21, _step21, failure;\n\n      return _regeneratorRuntime.wrap(function _callee3$(_context18) {\n        while (1) {\n          switch (_context18.prev = _context18.next) {\n            case 0:\n              return _context18.delegateYield(struct.refiner(value, ctx), \"t0\", 1);\n\n            case 1:\n              result = refiner(value, ctx);\n              failures = toFailures(result, ctx, struct, value);\n              _iterator21 = _createForOfIteratorHelper(failures);\n              _context18.prev = 4;\n\n              _iterator21.s();\n\n            case 6:\n              if ((_step21 = _iterator21.n()).done) {\n                _context18.next = 12;\n                break;\n              }\n\n              failure = _step21.value;\n              _context18.next = 10;\n              return _objectSpread(_objectSpread({}, failure), {}, {\n                refinement: name\n              });\n\n            case 10:\n              _context18.next = 6;\n              break;\n\n            case 12:\n              _context18.next = 17;\n              break;\n\n            case 14:\n              _context18.prev = 14;\n              _context18.t1 = _context18[\"catch\"](4);\n\n              _iterator21.e(_context18.t1);\n\n            case 17:\n              _context18.prev = 17;\n\n              _iterator21.f();\n\n              return _context18.finish(17);\n\n            case 20:\n            case \"end\":\n              return _context18.stop();\n          }\n        }\n      }, _callee3, null, [[4, 14, 17, 20]]);\n    }))\n  }));\n}\n\nexport { Struct, StructError, any, array, _assert as assert, assign, boolean, coerce, _create as create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, _is as is, lazy, literal, map, _mask as mask, max, min, never, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, _validate as validate };","map":{"version":3,"sources":["../src/error.ts","../src/utils.ts","../src/struct.ts","../src/structs/utilities.ts","../src/structs/types.ts","../src/structs/coercions.ts","../src/structs/refinements.ts"],"names":["StructError","TypeError","constructor","failure","failures","rest","path","msg","Object","cached","isObject","x","Symbol","isPlainObject","prototype","print","value","JSON","shiftIterator","input","done","toFailure","result","context","struct","message","branch","type","refinement","key","toFailures","isIterable","run","options","coerce","mask","ctx","Array","valid","ts","k","t","v","Struct","props","coercer","entries","validator","refiner","assert","create","is","validate","tuples","tuple","error","assign","Structs","schemas","s","schema","object","define","name","deprecated","log","dynamic","fn","lazy","omit","keys","subschema","partial","optional","pick","console","any","array","Element","boolean","date","isNaN","enums","values","description","func","instance","Class","integer","Number","intersection","S","literal","constant","map","Key","Value","never","nullable","number","knowns","Never","unknowns","record","regexp","set","string","Elements","length","Math","i","union","first","unknown","condition","defaulted","fallback","f","ret","changed","trimmed","empty","expected","refine","size","max","threshold","exclusive","min","pattern","of"],"mappings":";;;;;;;;;;;;;;;oDC6FiB8B,U;qDAwBAE,G;;ADrHjB;;;;AAcA;;;;;;;;IASahC,W;;;;;AAUXE,uBAAYC,OAAZD,EAA8BE,QAA9BF,EAA8BE;AAAAA;;AAAAA;;AAC5B,QAAA,MAAA;;AACA,QAAM,OAAN,GAAA,OAAA,CAAM,OAAN;AAAA,QAAoBC,IAApB,4BAAA,OAAA;;AACA,QAAQC,IAAR,GAAA,OAAA,CAAQA,IAAR;AACA,QAAMC,GAAG,GACPD,IAAI,CAAJA,MAAAA,KAAAA,CAAAA,GAAAA,OAAAA,GAAAA,cAA0CA,IAAI,CAAJA,IAAAA,CAA1CA,GAA0CA,CAA1CA,GAAAA,MAAAA,GADF,OAAA;AAEA,8BAAA,GAAA;AACAE,IAAAA,MAAM,CAANA,MAAAA,gCAAAA,IAAAA;AACA,UAAA,IAAA,GAAY,MAAA,WAAA,CAAZ,IAAA;;AACA,UAAA,QAAA,GAAgB,YAAA;;;AACd,aAAA,CAAA,OAAA,GAAA,MAAA,KAAA,IAAA,GAAA,OAAA,GAAQC,MAAR,IAAmB,OAAnB,4BAAgCL,QAAhC,EAAA,EAAA;AADF,KAAA;;AAT4BA;AAY7B;;;iCAtB8BH,S;ACpBjC;;;;;AAIA,SAAA,UAAA,CAAA,CAAA,EAAA;AACE,SAAOS,QAAQ,CAARA,CAAQ,CAARA,IAAe,OAAOC,CAAC,CAACC,MAAM,CAAf,QAAQ,CAAR,KAAtB,UAAA;AACD;AAED;;;;;SAIgBF,Q,CAASC,C,EAAAA;AACvB,SAAO,OAAA,CAAA,KAAA,QAAA,IAAyBA,CAAC,IAAjC,IAAA;AACD;AAED;;;;;SAIgBE,a,CAAcF,C,EAAAA;AAC5B,MAAIH,MAAM,CAANA,SAAAA,CAAAA,QAAAA,CAAAA,IAAAA,CAAAA,CAAAA,MAAJ,iBAAA,EAA6D;AAC3D,WAAA,KAAA;AACD;;AAED,MAAMM,SAAS,GAAGN,MAAM,CAANA,cAAAA,CAAlB,CAAkBA,CAAlB;AACA,SAAOM,SAAS,KAATA,IAAAA,IAAsBA,SAAS,KAAKN,MAAM,CAAjD,SAAA;AACD;AAED;;;;;SAIgBO,K,CAAMC,K,EAAAA;AACpB,SAAO,OAAA,KAAA,KAAA,QAAA,GAA4BC,IAAI,CAAJA,SAAAA,CAA5B,KAA4BA,CAA5B,GAAA,KAAP,KAAA;AACD;AAED;;;;;;SAKgBC,a,CAAiBC,K,EAAAA;AAC/B,oBAAwBA,KAAK,CAA7B,IAAwBA,EAAxB;AAAA,MAAM,IAAN,eAAM,IAAN;AAAA,MAAcH,KAAd,eAAcA,KAAd;;AACA,SAAOI,IAAI,GAAA,SAAA,GAAX,KAAA;AACD;AAED;;;;;SAIgBC,S,CACdC,M,EACAC,O,EACAC,M,EACAR,K,EAAAA;AAEA,MAAIM,MAAM,KAAV,IAAA,EAAqB;AACnB;AADF,GAAA,MAEO,IAAIA,MAAM,KAAV,KAAA,EAAsB;AAC3BA,IAAAA,MAAM,GAANA,EAAAA;AADK,GAAA,MAEA,IAAI,OAAA,MAAA,KAAJ,QAAA,EAAgC;AACrCA,IAAAA,MAAM,GAAG;AAAEG,MAAAA,OAAO,EAAEH;AAAX,KAATA;AACD;;AAED,MAAM,IAAN,GAAA,OAAA,CAAM,IAAN;AAAA,MAAcI,MAAd,GAAA,OAAA,CAAcA,MAAd;AACA,MAAQC,IAAR,GAAA,MAAA,CAAQA,IAAR;AACA,gBAAA,MAAA;AAAA,MAAM,UAAN,WAAM,UAAN;AAAA,gCAEEF,OAFF;AAAA,MAEEA,OAFF,gCAES,+BAAA,IAAA,GAAA,GAAA,IACLG,UAAU,GAAA,uBAAA,UAAA,GAAA,GAAA,GADL,EAAA,IAAA,mBAAA,GAEcb,KAAK,CAFnB,KAEmB,CAFnB,GAAA,GAFT;AAOA;AACEC,IAAAA,KADK,EACLA,KADF;AAEEW,IAAAA,IAFK,EAELA,IAFF;AAGEC,IAAAA,UAHK,EAGLA,UAHF;AAIEC,IAAAA,GAAG,EAAEvB,IAAI,CAACA,IAAI,CAAJA,MAAAA,GAJL,CAII,CAJX;AAKEA,IAAAA,IALK,EAKLA,IALF;AAMEoB,IAAAA,MANK,EAMLA;AANF,KAAO,MAAP;AAQED,IAAAA,OAAAA,EAAAA;AARF;AAUD;AAED;;;;;SAIiBK,U,CACfR,M,EACAC,O,EACAC,M,EACAR,K;;;;;;;AAEA,cAAI,CAACe,UAAU,CAAf,MAAe,CAAf,EAAyB;AACvBT,YAAAA,MAAM,GAAG,CAATA,MAAS,CAATA;AACD;;iDAED,M;;;;;;;;;;;AAAA,UAAA,C;AACQnB,UAAAA,O,GAAUkB,SAAS,CAAA,CAAA,EAAA,OAAA,EAAA,MAAA,EAAzB,KAAyB,C;;eAEzB,O;;;;;;AACE,iBAAA,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKN;;;;;;SAKiBW,G,CACfhB,K,EACAQ,M;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACAS,UAAAA,O,8DAKI,E;0BAEJ,O,CAAQ3B,I,EAAAA,I,8BAAF,E,oCAAN,O,CAAmBoB,M,EAAAA,M,gCAAS,CAAtB,KAAsB,C,sCAA5B,O,CAAqCQ,M,EAAAA,M,gCAA/B,K,oCAAN,O,CAAqDC,I,EAAAA,I,8BAAO,K;AACtDC,UAAAA,G,GAAe;AAAE9B,YAAAA,IAAF,EAAEA,IAAF;AAAQoB,YAAAA,MAAAA,EAAAA;AAAR,W;;AAErB,cAAA,MAAA,EAAY;AACVV,YAAAA,KAAK,GAAGQ,MAAM,CAANA,OAAAA,CAAAA,KAAAA,EAARR,GAAQQ,CAARR;;AAEA,gBACEmB,IAAI,IACJX,MAAM,CAANA,IAAAA,KADAW,MAAAA,IAEAzB,QAAQ,CAACc,MAAM,CAFfW,MAEQ,CAFRA,IAGAzB,QAAQ,CAHRyB,KAGQ,CAHRA,IAIA,CAACE,KAAK,CAALA,OAAAA,CALH,KAKGA,CALH,EAME;AACA,mBAAA,GAAA,IAAA,KAAA,EAAyB;AACvB,oBAAIb,MAAM,CAANA,MAAAA,CAAAA,GAAAA,MAAJ,SAAA,EAAsC;AACpC,yBAAOR,KAAK,CAAZ,GAAY,CAAZ;AACD;AACF;AACF;AACF;;AAEGsB,UAAAA,K,GAAJ,I;kDAEsBd,MAAM,CAANA,SAAAA,CAAAA,KAAAA,EAAtB,GAAsBA,C;;;;;;;;;;;AAAtB,UAAA,Q;AACEc,UAAAA,KAAK,GAALA,KAAAA;;AACA,iBAAM,CAAA,QAAA,EAAN,SAAM,CAAN;;;;;;;;;;;;;;;;;;;;;;;;kDAGoBd,MAAM,CAANA,OAAAA,CAAAA,KAAAA,EAAtB,GAAsBA,C;;;;;;;;;;;0DAAb,C,oBAAA,C,oBAAT,C;AACQe,UAAAA,E,GAAKP,GAAG,CAAA,CAAA,EAAA,CAAA,EAAiB;AAC7B1B,YAAAA,IAAI,EAAEkC,CAAC,KAADA,SAAAA,GAAAA,IAAAA,gCAAyB,IAAzBA,IADuB,CACvBA,EADuB;AAE7Bd,YAAAA,MAAM,EAAEc,CAAC,KAADA,SAAAA,GAAAA,MAAAA,gCAA2B,MAA3BA,IAFqB,CAErBA,EAFqB;AAG7BN,YAAAA,MAH6B,EAG7BA,MAH6B;AAI7BC,YAAAA,IAAAA,EAAAA;AAJ6B,WAAjB,C;kDAOd,E;;;;;;;;;;;AAAA,UAAA,C;;eACMM,CAAC,CAAL,CAAK,C;;;;;AACHH,UAAAA,KAAK,GAALA,KAAAA;;AACA,iBAAM,CAACG,CAAC,CAAF,CAAE,CAAF,EAAN,SAAM,CAAN;;;;;;;AACK,cAAA,MAAA,EAAY;AACjBC,YAAAA,CAAC,GAAGD,CAAC,CAALC,CAAK,CAALA;;AAEA,gBAAIF,CAAC,KAAL,SAAA,EAAqB;AACnBxB,cAAAA,KAAK,GAALA,CAAAA;AADF,aAAA,MAEO,IAAIA,KAAK,YAAT,GAAA,EAA0B;AAC/BA,cAAAA,KAAK,CAALA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AADK,aAAA,MAEA,IAAIA,KAAK,YAAT,GAAA,EAA0B;AAC/BA,cAAAA,KAAK,CAALA,GAAAA,CAAAA,CAAAA;AADK,aAAA,MAEA,IAAIN,QAAQ,CAAZ,KAAY,CAAZ,EAAqB;AAC1BM,cAAAA,KAAK,CAALA,CAAK,CAALA,GAAAA,CAAAA;AACD;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;eAIL,K;;;;;kDACwBQ,MAAM,CAANA,OAAAA,CAAAA,KAAAA,EAAtB,GAAsBA,C;;;;;;;;;;;AAAtB,UAAA,O;AACEc,UAAAA,KAAK,GAALA,KAAAA;;AACA,iBAAM,CAAA,OAAA,EAAN,SAAM,CAAN;;;;;;;;;;;;;;;;;;;;;;;;eAIJ,K;;;;;;AACE,iBAAM,CAAA,SAAA,EAAN,KAAM,CAAN;;;;;;;;;AC5LJ;;;;;;;IAMaK,M;AAYXzC,kBAAY0C,KAAZ1C,EAAY0C;AAAAA;;AAAAA;;AAQV,QAAM,IAAN,GAAA,KAAA,CAAM,IAAN;AAAA,QAAM,MAAN,GAAA,KAAA,CAAM,MAAN;AAAA,QAAM,SAAN,GAAA,KAAA,CAAM,SAAN;AAAA,QAAM,OAAN,GAAA,KAAA,CAAM,OAAN;AAAA,yBAAA,KAAA,CAKEC,OALF;AAAA,QAKEA,OALF,+BAKa7B,UAAAA,KAAD;AAAA,aALN,KAKM;AAAA,KALZ;AAAA,yBAAA,KAAA,CAME8B,OANF;AAAA,QAMEA,OANF,qEAMY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KANZ;AASA,SAAA,IAAA,GAAA,IAAA;AACA,SAAA,MAAA,GAAA,MAAA;AACA,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,OAAA,GAAA,OAAA;;AAEA,QAAA,SAAA,EAAe;AACb,WAAA,SAAA,GAAiB,UAAA,KAAA,EAAA,OAAA,EAAA;AACf,YAAMxB,MAAM,GAAGyB,SAAS,CAAA,KAAA,EAAxB,OAAwB,CAAxB;AACA,eAAOjB,UAAU,CAAA,MAAA,EAAA,OAAA,EAAA,MAAA,EAAjB,KAAiB,CAAjB;AAFF,OAAA;AADF,KAAA,MAKO;AACL,WAAA,SAAA,GAAiB;AAAA,eAAjB,EAAiB;AAAA,OAAjB;AACD;;AAED,QAAA,OAAA,EAAa;AACX,WAAA,OAAA,GAAe,UAAA,KAAA,EAAA,OAAA,EAAA;AACb,YAAMR,MAAM,GAAG0B,OAAO,CAAA,KAAA,EAAtB,OAAsB,CAAtB;AACA,eAAOlB,UAAU,CAAA,MAAA,EAAA,OAAA,EAAA,MAAA,EAAjB,KAAiB,CAAjB;AAFF,OAAA;AADF,KAAA,MAKO;AACL,WAAA,OAAA,GAAe;AAAA,eAAf,EAAe;AAAA,OAAf;AACD;AACF;AAED;;;;;;;WAIAmB,gBAAM,KAANA,EAAM;AACJ,aAAOA,OAAM,CAAA,KAAA,EAAb,IAAa,CAAb;AACD;AAED;;;;;;WAIAC,gBAAM,KAANA,EAAM;AACJ,aAAOA,OAAM,CAAA,KAAA,EAAb,IAAa,CAAb;AACD;AAED;;;;;;WAIAC,YAAE,KAAFA,EAAE;AACA,aAAOA,GAAE,CAAA,KAAA,EAAT,IAAS,CAAT;AACD;AAED;;;;;;;WAKAhB,cAAI,KAAJA,EAAI;AACF,aAAOA,KAAI,CAAA,KAAA,EAAX,IAAW,CAAX;AACD;AAED;;;;;;;;;;;WASAiB,kBAAQ,KAARA,EAAQ;AAAA,UAENnB,OAFM,uEAAA,EAAA;AAMN,aAAOmB,SAAQ,CAAA,KAAA,EAAA,IAAA,EAAf,OAAe,CAAf;AACD;;;;;AAGH;;;;;SAIgBH,O,CACdjC,K,EACAQ,M,EAAAA;AAEA,MAAMF,MAAM,GAAG8B,SAAQ,CAAA,KAAA,EAAvB,MAAuB,CAAvB;;AAEA,MAAI9B,MAAM,CAAV,CAAU,CAAV,EAAe;AACb,UAAMA,MAAM,CAAZ,CAAY,CAAZ;AACD;AACF;AAED;;;;;SAIgB4B,O,CAAalC,K,EAAgBQ,M,EAAAA;AAC3C,MAAMF,MAAM,GAAG8B,SAAQ,CAAA,KAAA,EAAA,MAAA,EAAgB;AAAElB,IAAAA,MAAM,EAAE;AAAV,GAAhB,CAAvB;;AAEA,MAAIZ,MAAM,CAAV,CAAU,CAAV,EAAe;AACb,UAAMA,MAAM,CAAZ,CAAY,CAAZ;AADF,GAAA,MAEO;AACL,WAAOA,MAAM,CAAb,CAAa,CAAb;AACD;AACF;AAED;;;;;SAIgBa,K,CAAWnB,K,EAAgBQ,M,EAAAA;AACzC,MAAMF,MAAM,GAAG8B,SAAQ,CAAA,KAAA,EAAA,MAAA,EAAgB;AAAElB,IAAAA,MAAM,EAAR,IAAA;AAAgBC,IAAAA,IAAI,EAAE;AAAtB,GAAhB,CAAvB;;AAEA,MAAIb,MAAM,CAAV,CAAU,CAAV,EAAe;AACb,UAAMA,MAAM,CAAZ,CAAY,CAAZ;AADF,GAAA,MAEO;AACL,WAAOA,MAAM,CAAb,CAAa,CAAb;AACD;AACF;AAED;;;;;SAIgB6B,G,CAASnC,K,EAAgBQ,M,EAAAA;AACvC,MAAMF,MAAM,GAAG8B,SAAQ,CAAA,KAAA,EAAvB,MAAuB,CAAvB;;AACA,SAAO,CAAC9B,MAAM,CAAd,CAAc,CAAd;AACD;AAED;;;;;;SAKgB8B,S,CACdpC,K,EACAQ,M,EAII;AAAA,MAHJS,OAGI,uEAAA,EAAA;AAEJ,MAAMoB,MAAM,GAAGrB,GAAG,CAAA,KAAA,EAAA,MAAA,EAAlB,OAAkB,CAAlB;AACA,MAAMsB,KAAK,GAAGpC,aAAa,CAA3B,MAA2B,CAA3B;;AAEA,MAAIoC,KAAK,CAAT,CAAS,CAAT,EAAc;AACZ,QAAMC,KAAK,GAAG,IAAA,WAAA,CAAgBD,KAAK,CAArB,CAAqB,CAArB,wCAA0B;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,sDACtC,MADsC;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACtC,cAAA,CADsC;;AAAA,mBAEhCb,CAAC,CAAL,CAAK,CAF+B;AAAA;AAAA;AAAA;;AAAA;AAGlC,qBAAMA,CAAC,CAAP,CAAO,CAAP;;AAHkC;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAA1B,EAAd;AAQA,WAAO,CAAA,KAAA,EAAP,SAAO,CAAP;AATF,GAAA,MAUO;AACL,QAAMC,CAAC,GAAGY,KAAK,CAAf,CAAe,CAAf;AACA,WAAO,CAAA,SAAA,EAAP,CAAO,CAAP;AACD;AACF;;SC9IeE,M,GAAUC;AAAAA,oCAAAA,OAAAA;AAAAA,IAAAA,OAAAA;AAAAA;;AACxB,MAAMC,OAAO,GAAGD,OAAO,CAAPA,GAAAA,CAAaE,UAAAA,CAAD;AAAA,WAAOA,CAAC,CAApC,MAA4B;AAAA,GAAZF,CAAhB;AACA,MAAMG,MAAM,GAAGpD,MAAM,CAANA,MAAAA,OAAAA,MAAM,GAANA,EAAM,4BAArB,OAAqB,GAArB;AACA,SAAOqD,MAAM,CAAb,MAAa,CAAb;AACD;AAED;;;;;SAIgBC,M,CAAUC,I,EAAchB,S,EAAAA;AACtC,SAAO,IAAA,MAAA,CAAW;AAAEpB,IAAAA,IAAI,EAAN,IAAA;AAAciC,IAAAA,MAAM,EAApB,IAAA;AAA4Bb,IAAAA,SAAAA,EAAAA;AAA5B,GAAX,CAAP;AACD;AAED;;;;;;SAKgBiB,U,CACdxC,M,EACAyC,G,EAAAA;AAEA,SAAO,IAAA,MAAA,iCAAW,MAAX;AAELjB,IAAAA,OAAO,EAAE,iBAAA,KAAA,EAAA,GAAA;AAAA,aAAgBhC,KAAK,KAALA,SAAAA,IAAuBQ,MAAM,CAANA,OAAAA,CAAAA,KAAAA,EAFhC,GAEgCA,CAAvC;AAAA,KAFJ;AAGLuB,IAAAA,SAHK,qBAGI,KAHJ,EAGI,GAHJ,EAGI;AACP,UAAI/B,KAAK,KAAT,SAAA,EAAyB;AACvB,eAAA,IAAA;AADF,OAAA,MAEO;AACLiD,QAAAA,GAAG,CAAA,KAAA,EAAHA,GAAG,CAAHA;AACA,eAAOzC,MAAM,CAANA,SAAAA,CAAAA,KAAAA,EAAP,GAAOA,CAAP;AACD;AACF;AAVI,KAAP;AAYD;AAED;;;;;;;;;SAQgB0C,O,CACdC,E,EAAAA;AAEA,SAAO,IAAA,MAAA,CAAW;AAChBxC,IAAAA,IAAI,EADY,SAAA;AAEhBiC,IAAAA,MAAM,EAFU,IAAA;AAGhB,IAAA,OAHgB,yDAGhB,KAHgB,EAGhB,GAHgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAIRpC,cAAAA,MAJQ,GAIC2C,EAAE,CAAA,KAAA,EAAjB,GAAiB,CAJH;AAKd,6CAAO3C,MAAM,CAANA,OAAAA,CAAAA,KAAAA,EAAP,GAAOA,CAAP;;AALc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOhBuB,IAAAA,SAPgB,qBAOP,KAPO,EAOP,GAPO,EAOP;AACP,UAAMvB,MAAM,GAAG2C,EAAE,CAAA,KAAA,EAAjB,GAAiB,CAAjB;AACA,aAAO3C,MAAM,CAANA,SAAAA,CAAAA,KAAAA,EAAP,GAAOA,CAAP;AATc,KAAA;AAWhBqB,IAAAA,OAXgB,mBAWT,KAXS,EAWT,GAXS,EAWT;AACL,UAAMrB,MAAM,GAAG2C,EAAE,CAAA,KAAA,EAAjB,GAAiB,CAAjB;AACA,aAAO3C,MAAM,CAANA,OAAAA,CAAAA,KAAAA,EAAP,GAAOA,CAAP;AACD;AAde,GAAX,CAAP;AAgBD;AAED;;;;;;;;;;SASgB4C,I,CAAQD,E,EAAAA;AACtB,MAAA,MAAA;AACA,SAAO,IAAA,MAAA,CAAW;AAChBxC,IAAAA,IAAI,EADY,MAAA;AAEhBiC,IAAAA,MAAM,EAFU,IAAA;AAGhB,IAAA,OAHgB,yDAGhB,KAHgB,EAGhB,GAHgB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAId,eAAA,OAAA,GAAA,MAAA,KAAA,IAAA,GAAA,OAAA,GAAA,MAAM,GAAKO,EAAX,EAAA;AACA,6CAAO3C,MAAM,CAANA,OAAAA,CAAAA,KAAAA,EAAP,GAAOA,CAAP;;AALc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOhBuB,IAAAA,SAPgB,qBAOP,KAPO,EAOP,GAPO,EAOP;;;AACP,OAAA,QAAA,GAAA,MAAA,KAAA,IAAA,GAAA,QAAA,GAAA,MAAM,GAAKoB,EAAX,EAAA;AACA,aAAO3C,MAAM,CAANA,SAAAA,CAAAA,KAAAA,EAAP,GAAOA,CAAP;AATc,KAAA;AAWhBqB,IAAAA,OAXgB,mBAWT,KAXS,EAWT,GAXS,EAWT;;;AACL,OAAA,QAAA,GAAA,MAAA,KAAA,IAAA,GAAA,QAAA,GAAA,MAAM,GAAKsB,EAAX,EAAA;AACA,aAAO3C,MAAM,CAANA,OAAAA,CAAAA,KAAAA,EAAP,GAAOA,CAAP;AACD;AAde,GAAX,CAAP;AAgBD;AAED;;;;;;;;SAOgB6C,I,CACd7C,M,EACA8C,I,EAAAA;AAEA,MAAQV,MAAR,GAAA,MAAA,CAAQA,MAAR;;AACA,MAAMW,SAAS,qBAAaX,MAAb,CAAf;;AAHAU,8CAKA,IALAA;AAAAA;;AAAAA;AAKA,2DAAwB;AAAA,UAAxB,GAAwB;AACtB,aAAOC,SAAS,CAAhB,GAAgB,CAAhB;AACD;AAPDD;AAAAA;AAAAA;AAAAA;AAAAA;;AASA,SAAOT,MAAM,CAAb,SAAa,CAAb;AACD;AAED;;;;;;;;SAOgBW,O,CACdhD,M,EAAAA;AAEA,MAAMoC,MAAM,GACV,MAAM,YAAN,MAAA,qBAAgCpC,MAAM,CAACoC,MAAvC,sBAAuDpC,MAAvD,CADF;;AAGA,OAAK,IAAL,GAAA,IAAA,MAAA,EAA0B;AACxBoC,IAAAA,MAAM,CAANA,GAAM,CAANA,GAAca,QAAQ,CAACb,MAAM,CAA7BA,GAA6B,CAAP,CAAtBA;AACD;;AAED,SAAOC,MAAM,CAAb,MAAa,CAAb;AACD;AAED;;;;;;;;SAOgBa,I,CACdlD,M,EACA8C,I,EAAAA;AAEA,MAAQV,MAAR,GAAA,MAAA,CAAQA,MAAR;AACA,MAAMW,SAAS,GAAf,EAAA;;AAHAD,8CAKA,IALAA;AAAAA;;AAAAA;AAKA,2DAAwB;AAAA,UAAxB,GAAwB;AACtBC,MAAAA,SAAS,CAATA,GAAS,CAATA,GAAiBX,MAAM,CAAvBW,GAAuB,CAAvBA;AACD;AAPDD;AAAAA;AAAAA;AAAAA;AAAAA;;AASA,SAAOT,MAAM,CAAb,SAAa,CAAb;AACD;AAED;;;;;;;SAMgBrC,M,CAAUuC,I,EAAchB,S,EAAAA;AACtC4B,EAAAA,OAAO,CAAPA,IAAAA,CAAAA,sEAAAA;AAIA,SAAOb,MAAM,CAAA,IAAA,EAAb,SAAa,CAAb;AACD;ACpND;;;;;SAIgBc,G,GAAAA;AACd,SAAOd,MAAM,CAAA,KAAA,EAAQ;AAAA,WAArB,IAAqB;AAAA,GAAR,CAAb;AACD;;SAYee,K,CAA6BC,O,EAAAA;AAC3C,SAAO,IAAA,MAAA,CAAW;AAChBnD,IAAAA,IAAI,EADY,OAAA;AAEhBiC,IAAAA,MAAM,EAFU,OAAA;AAGhB,IAAA,OAHgB,yDAGhB,KAHgB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,oBAIVkB,OAAO,IAAIzC,KAAK,CAALA,OAAAA,CAAf,KAAeA,CAJD;AAAA;AAAA;AAAA;;AAAA,sDAKSrB,KAAK,CAA1B,OAAqBA,EALT;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,8DAKD,CALC,oBAKZ,CALY;AAAA;AAMV,qBAAM,CAAA,CAAA,EAAA,CAAA,EAAN,OAAM,CAAN;;AANU;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUhB6B,IAAAA,OAVgB,mBAUT,KAVS,EAUT;AACL,aAAOR,KAAK,CAALA,OAAAA,CAAAA,KAAAA,IAAuBrB,KAAK,CAA5BqB,KAAuBrB,EAAvBqB,GAAP,KAAA;AAXc,KAAA;AAahBU,IAAAA,SAbgB,qBAaP,KAbO,EAaP;AACP,aACEV,KAAK,CAALA,OAAAA,CAAAA,KAAAA,KAAAA,4CAC0CtB,KAAK,CAFjD,KAEiD,CAFjD;AAID;AAlBe,GAAX,CAAP;AAoBD;AAED;;;;;SAIgBgE,O,GAAAA;AACd,SAAOjB,MAAM,CAAA,SAAA,EAAa9C,UAAAA,KAAD,EAAA;AACvB,WAAO,OAAA,KAAA,KAAP,SAAA;AADF,GAAa,CAAb;AAGD;AAED;;;;;;;;SAOgBgE,I,GAAAA;AACd,SAAOlB,MAAM,CAAA,MAAA,EAAU9C,UAAAA,KAAD,EAAA;AACpB,WACGA,KAAK,YAALA,IAAAA,IAAyB,CAACiE,KAAK,CAACjE,KAAK,CAAtC,OAAiCA,EAAD,CAA/BA,IAAD,mDACmDD,KAAK,CAF1D,KAE0D,CAF1D;AADF,GAAa,CAAb;AAMD;;SAeemE,K,CAAiCC,M,EAAAA;AAC/C,MAAMvB,MAAM,GAAZ,EAAA;AACA,MAAMwB,WAAW,GAAGD,MAAM,CAANA,GAAAA,CAAYzC,UAAAA,CAAD;AAAA,WAAO3B,KAAK,CAAvBoE,CAAuB,CAAZ;AAAA,GAAXA,EAApB,IAAoBA,EAApB;;AAF+CA,+CAI/C,MAJ+CA;AAAAA;;AAAAA;AAI/C,8DAA0B;AAAA,UAA1B,GAA0B;AACxBvB,MAAAA,MAAM,CAANA,GAAM,CAANA,GAAAA,GAAAA;AACD;AAN8CuB;AAAAA;AAAAA;AAAAA;AAAAA;;AAQ/C,SAAO,IAAA,MAAA,CAAW;AAChBxD,IAAAA,IAAI,EADY,OAAA;AAEhBiC,IAAAA,MAFgB,EAEhBA,MAFgB;AAGhBb,IAAAA,SAHgB,qBAGP,KAHO,EAGP;AACP,aACEoC,MAAM,CAANA,QAAAA,CAAAA,KAAAA,KAAAA,sBAAAA,WAAAA,GAAAA,mBAAAA,GACqDpE,KAAK,CAF5D,KAE4D,CAF5D;AAID;AARe,GAAX,CAAP;AAUD;AAED;;;;;SAIgBsE,I,GAAAA;AACd,SAAOvB,MAAM,CAAA,MAAA,EAAU9C,UAAAA,KAAD,EAAA;AACpB,WACE,OAAA,KAAA,KAAA,UAAA,IAAA,wCACsCD,KAAK,CAF7C,KAE6C,CAF7C;AADF,GAAa,CAAb;AAMD;AAED;;;;;SAIgBuE,Q,CACdC,K,EAAAA;AAEA,SAAOzB,MAAM,CAAA,UAAA,EAAc9C,UAAAA,KAAD,EAAA;AACxB,WACEA,KAAK,YAALA,KAAAA,IAAAA,iBACgBuE,KAAK,CADrBvE,IAAAA,GAAAA,4BAAAA,GACwDD,KAAK,CAF/D,KAE+D,CAF/D;AADF,GAAa,CAAb;AAMD;AAED;;;;;SAIgByE,O,GAAAA;AACd,SAAO1B,MAAM,CAAA,SAAA,EAAa9C,UAAAA,KAAD,EAAA;AACvB,WACG,OAAA,KAAA,KAAA,QAAA,IAA6B,CAACiE,KAAK,CAAnC,KAAmC,CAAnC,IAA8CQ,MAAM,CAANA,SAAAA,CAA/C,KAA+CA,CAA9C,IAAD,wCACsC1E,KAAK,CAF7C,KAE6C,CAF7C;AADF,GAAa,CAAb;AAMD;;SA0De2E,Y,CAAajC,O,EAAAA;AAC3B,SAAO,IAAA,MAAA,CAAW;AAChB9B,IAAAA,IAAI,EADY,cAAA;AAEhBiC,IAAAA,MAAM,EAFU,IAAA;AAGhB,IAAA,OAHgB,yDAGhB,KAHgB,EAGhB,GAHgB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,uDAId,OAJc;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAId,cAAA,CAJc;AAKZ,6CAAO+B,CAAC,CAADA,OAAAA,CAAAA,KAAAA,EAAP,GAAOA,CAAP;;AALY;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQhB,IAAA,SARgB,2DAQhB,KARgB,EAQhB,GARgB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,uDASd,OATc;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AASd,cAAA,CATc;AAUZ,6CAAOA,CAAC,CAADA,SAAAA,CAAAA,KAAAA,EAAP,GAAOA,CAAP;;AAVY;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAahB,IAAA,OAbgB,yDAahB,KAbgB,EAahB,GAbgB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,uDAcd,OAdc;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAcd,cAAA,CAdc;AAeZ,8CAAOA,CAAC,CAADA,OAAAA,CAAAA,KAAAA,EAAP,GAAOA,CAAP;;AAfY;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAX,CAAP;AAmBD;;SAUeC,O,CAAWC,Q,EAAAA;AACzB,MAAMT,WAAW,GAAGrE,KAAK,CAAzB,QAAyB,CAAzB;AACA,MAAM0B,CAAC,GAAG,OAAV,QAAA;AACA,SAAO,IAAA,MAAA,CAAW;AAChBd,IAAAA,IAAI,EADY,SAAA;AAEhBiC,IAAAA,MAAM,EACJnB,CAAC,KAADA,QAAAA,IAAkBA,CAAC,KAAnBA,QAAAA,IAAoCA,CAAC,KAArCA,SAAAA,GAAAA,QAAAA,GAHc,IAAA;AAIhBM,IAAAA,SAJgB,qBAIP,KAJO,EAIP;AACP,aACE/B,KAAK,KAALA,QAAAA,IAAAA,2BAAAA,WAAAA,GAAAA,mBAAAA,GAC0DD,KAAK,CAFjE,KAEiE,CAFjE;AAID;AATe,GAAX,CAAP;AAWD;;SAYe+E,G,CAAUC,G,EAAiBC,K,EAAAA;AACzC,SAAO,IAAA,MAAA,CAAW;AAChBrE,IAAAA,IAAI,EADY,KAAA;AAEhBiC,IAAAA,MAAM,EAFU,IAAA;AAGhB,IAAA,OAHgB,yDAGhB,KAHgB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,oBAIVmC,GAAG,IAAHA,KAAAA,IAAgB/E,KAAK,YAAzB,GAJc;AAAA;AAAA;AAAA;;AAAA,uDAKSA,KAAK,CAA1B,OAAqBA,EALT;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,gEAKD,CALC,qBAKZ,CALY;AAAA;AAMV,qBAAM,CAAA,CAAA,EAAA,CAAA,EAAN,GAAM,CAAN;;AANU;AAAA;AAOV,qBAAM,CAAA,CAAA,EAAA,CAAA,EAAN,KAAM,CAAN;;AAPU;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWhB6B,IAAAA,OAXgB,mBAWT,KAXS,EAWT;AACL,aAAO7B,KAAK,YAALA,GAAAA,GAAuB,IAAA,GAAA,CAAvBA,KAAuB,CAAvBA,GAAP,KAAA;AAZc,KAAA;AAchB+B,IAAAA,SAdgB,qBAcP,KAdO,EAcP;AACP,aACE/B,KAAK,YAALA,GAAAA,IAAAA,4CAC4CD,KAAK,CAFnD,KAEmD,CAFnD;AAID;AAnBe,GAAX,CAAP;AAqBD;AAED;;;;;SAIgBkF,K,GAAAA;AACd,SAAOnC,MAAM,CAAA,OAAA,EAAU;AAAA,WAAvB,KAAuB;AAAA,GAAV,CAAb;AACD;AAED;;;;;SAIgBoC,Q,CAAe1E,M,EAAAA;AAC7B,SAAO,IAAA,MAAA,iCAAW,MAAX;AAELuB,IAAAA,SAAS,EAAE,mBAAA,KAAA,EAAA,GAAA;AAAA,aAAgB/B,KAAK,KAALA,IAAAA,IAAkBQ,MAAM,CAANA,SAAAA,CAAAA,KAAAA,EAF7B,GAE6BA,CAAlC;AAAA,KAFN;AAGLwB,IAAAA,OAAO,EAAE,iBAAA,KAAA,EAAA,GAAA;AAAA,aAAgBhC,KAAK,KAALA,IAAAA,IAAkBQ,MAAM,CAANA,OAAAA,CAAAA,KAAAA,EAAAA,GAAAA,CAAlC;AAAA;AAHJ,KAAP;AAKD;AAED;;;;;SAIgB2E,M,GAAAA;AACd,SAAOrC,MAAM,CAAA,QAAA,EAAY9C,UAAAA,KAAD,EAAA;AACtB,WACG,OAAA,KAAA,KAAA,QAAA,IAA6B,CAACiE,KAAK,CAApC,KAAoC,CAAnC,IAAD,sCACoClE,KAAK,CAF3C,KAE2C,CAF3C;AADF,GAAa,CAAb;AAMD;;SAae8C,M,CAA+BD,M,EAAAA;AAC7C,MAAMwC,MAAM,GAAGxC,MAAM,GAAGpD,MAAM,CAANA,IAAAA,CAAH,MAAGA,CAAH,GAArB,EAAA;AACA,MAAM6F,KAAK,GAAGJ,KAAd,EAAA;AACA,SAAO,IAAA,MAAA,CAAW;AAChBtE,IAAAA,IAAI,EADY,QAAA;AAEhBiC,IAAAA,MAAM,EAAEA,MAAM,GAAA,MAAA,GAFE,IAAA;AAGhB,IAAA,OAHgB,yDAGhB,KAHgB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,oBAIVA,MAAM,IAAIlD,QAAQ,CAAtB,KAAsB,CAJR;AAAA;AAAA;AAAA;;AAKN4F,cAAAA,QALM,GAKK,IAAA,GAAA,CAAQ9F,MAAM,CAANA,IAAAA,CAAzB,KAAyBA,CAAR,CALL;AAAA,uDAOZ,MAPY;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOZ,cAAA,GAPY;AAQV8F,cAAAA,QAAQ,CAARA,MAAAA,CAAAA,GAAAA;AARU;AASV,qBAAM,CAAA,GAAA,EAAMtF,KAAK,CAAX,GAAW,CAAX,EAAkB4C,MAAM,CAA9B,GAA8B,CAAxB,CAAN;;AATU;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA,uDAYZ,QAZY;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYZ,cAAA,KAZY;AAAA;AAaV,qBAAM,CAAA,KAAA,EAAM5C,KAAK,CAAX,KAAW,CAAX,EAAN,KAAM,CAAN;;AAbU;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBhB+B,IAAAA,SAjBgB,qBAiBP,KAjBO,EAiBP;AACP,aACErC,QAAQ,CAARA,KAAQ,CAARA,IAAAA,uCAAwDK,KAAK,CAD/D,KAC+D,CAD/D;AAlBc,KAAA;AAsBhB8B,IAAAA,OAtBgB,mBAsBT,KAtBS,EAsBT;AACL,aAAO,QAAQ,CAAR,KAAQ,CAAR,qBAAuB7B,KAAvB,IAAP,KAAA;AACD;AAxBe,GAAX,CAAP;AA0BD;AAED;;;;;SAIgByD,Q,CAAejD,M,EAAAA;AAC7B,SAAO,IAAA,MAAA,iCAAW,MAAX;AAELuB,IAAAA,SAAS,EAAE,mBAAA,KAAA,EAAA,GAAA;AAAA,aACT/B,KAAK,KAALA,SAAAA,IAAuBQ,MAAM,CAANA,SAAAA,CAAAA,KAAAA,EAHT,GAGSA,CADd;AAAA,KAFN;AAILwB,IAAAA,OAAO,EAAE,iBAAA,KAAA,EAAA,GAAA;AAAA,aAAgBhC,KAAK,KAALA,SAAAA,IAAuBQ,MAAM,CAANA,OAAAA,CAAAA,KAAAA,EAAAA,GAAAA,CAAvC;AAAA;AAJJ,KAAP;AAMD;AAED;;;;;;;;SAOgB+E,M,CACdR,G,EACAC,K,EAAAA;AAEA,SAAO,IAAA,MAAA,CAAW;AAChBrE,IAAAA,IAAI,EADY,QAAA;AAEhBiC,IAAAA,MAAM,EAFU,IAAA;AAGhB,IAAA,OAHgB,yDAGhB,KAHgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAIVlD,QAAQ,CAAZ,KAAY,CAJE;AAAA;AAAA;AAAA;;AAAA,uDAKZ,KALY;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKZ,cAAA,CALY;AAMJgC,cAAAA,CANI,GAMA1B,KAAK,CAAf,CAAe,CANL;AAAA;AAOV,qBAAM,CAAA,CAAA,EAAA,CAAA,EAAN,GAAM,CAAN;;AAPU;AAAA;AAQV,qBAAM,CAAA,CAAA,EAAA,CAAA,EAAN,KAAM,CAAN;;AARU;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYhB+B,IAAAA,SAZgB,qBAYP,KAZO,EAYP;AACP,aACErC,QAAQ,CAARA,KAAQ,CAARA,IAAAA,uCAAwDK,KAAK,CAD/D,KAC+D,CAD/D;AAGD;AAhBe,GAAX,CAAP;AAkBD;AAED;;;;;;;;SAOgByF,M,GAAAA;AACd,SAAO1C,MAAM,CAAA,QAAA,EAAY9C,UAAAA,KAAD,EAAA;AACtB,WAAOA,KAAK,YAAZ,MAAA;AADF,GAAa,CAAb;AAGD;;SASeyF,G,CAAO3B,O,EAAAA;AACrB,SAAO,IAAA,MAAA,CAAW;AAChBnD,IAAAA,IAAI,EADY,KAAA;AAEhBiC,IAAAA,MAAM,EAFU,IAAA;AAGhB,IAAA,OAHgB,yDAGhB,KAHgB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,oBAIVkB,OAAO,IAAI9D,KAAK,YAApB,GAJc;AAAA;AAAA;AAAA;;AAAA,uDAKZ,KALY;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKZ,cAAA,CALY;AAAA;AAMV,qBAAM,CAAA,CAAA,EAAA,CAAA,EAAN,OAAM,CAAN;;AANU;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUhB6B,IAAAA,OAVgB,mBAUT,KAVS,EAUT;AACL,aAAO7B,KAAK,YAALA,GAAAA,GAAuB,IAAA,GAAA,CAAvBA,KAAuB,CAAvBA,GAAP,KAAA;AAXc,KAAA;AAahB+B,IAAAA,SAbgB,qBAaP,KAbO,EAaP;AACP,aACE/B,KAAK,YAALA,GAAAA,IAAAA,4CAC4CD,KAAK,CAFnD,KAEmD,CAFnD;AAID;AAlBe,GAAX,CAAP;AAoBD;AAED;;;;;SAIgB2F,M,GAAAA;AACd,SAAO5C,MAAM,CAAA,QAAA,EAAY9C,UAAAA,KAAD,EAAA;AACtB,WACE,OAAA,KAAA,KAAA,QAAA,IAAA,sCACoCD,KAAK,CAF3C,KAE2C,CAF3C;AADF,GAAa,CAAb;AAMD;;SAsDeuC,K,CAAMqD,Q,EAAAA;AACpB,MAAMN,KAAK,GAAGJ,KAAd,EAAA;AAEA,SAAO,IAAA,MAAA,CAAW;AAChBtE,IAAAA,IAAI,EADY,OAAA;AAEhBiC,IAAAA,MAAM,EAFU,IAAA;AAGhB,IAAA,OAHgB,yDAGhB,KAHgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAIVvB,KAAK,CAALA,OAAAA,CAAJ,KAAIA,CAJU;AAAA;AAAA;AAAA;;AAKNuE,cAAAA,MALM,GAKGC,IAAI,CAAJA,GAAAA,CAASF,QAAQ,CAAjBE,MAAAA,EAA0B7F,KAAK,CAA9C,MAAe6F,CALH;AAOHC,cAAAA,CAPG,GAOZ,CAPY;;AAAA;AAAA,oBAOIA,CAAC,GAAjB,MAPY;AAAA;AAAA;AAAA;;AAAA;AAQV,qBAAM,CAAA,CAAA,EAAI9F,KAAK,CAAT,CAAS,CAAT,EAAc2F,QAAQ,CAARA,CAAQ,CAARA,IAApB,KAAM,CAAN;;AARU;AAOgBG,cAAAA,CAA5B,EAPY;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYhB/D,IAAAA,SAZgB,qBAYP,KAZO,EAYP;AACP,aACEV,KAAK,CAALA,OAAAA,CAAAA,KAAAA,KAAAA,sCACoCtB,KAAK,CAF3C,KAE2C,CAF3C;AAID;AAjBe,GAAX,CAAP;AAmBD;AAED;;;;;;;;SAOgBY,I,CACdiC,M,EAAAA;AAEA,MAAMU,IAAI,GAAG9D,MAAM,CAANA,IAAAA,CAAb,MAAaA,CAAb;AACA,SAAO,IAAA,MAAA,CAAW;AAChBmB,IAAAA,IAAI,EADY,MAAA;AAEhBiC,IAAAA,MAFgB,EAEhBA,MAFgB;AAGhB,IAAA,OAHgB,yDAGhB,KAHgB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,mBAIVlD,QAAQ,CAAZ,KAAY,CAJE;AAAA;AAAA;AAAA;;AAAA,uDAKZ,IALY;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKZ,cAAA,CALY;AAAA;AAMV,qBAAM,CAAA,CAAA,EAAIM,KAAK,CAAT,CAAS,CAAT,EAAc4C,MAAM,CAA1B,CAA0B,CAApB,CAAN;;AANU;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUhBb,IAAAA,SAVgB,qBAUP,KAVO,EAUP;AACP,aACErC,QAAQ,CAARA,KAAQ,CAARA,IAAAA,uCAAwDK,KAAK,CAD/D,KAC+D,CAD/D;AAGD;AAde,GAAX,CAAP;AAgBD;;SAwDegG,K,CAAMtD,O,EAAAA;AACpB,MAAM2B,WAAW,GAAG3B,OAAO,CAAPA,GAAAA,CAAaE,UAAAA,CAAD;AAAA,WAAOA,CAAC,CAApBF,IAAY;AAAA,GAAZA,EAAAA,IAAAA,CAApB,KAAoBA,CAApB;AACA,SAAO,IAAA,MAAA,CAAW;AAChB9B,IAAAA,IAAI,EADY,OAAA;AAEhBiC,IAAAA,MAAM,EAFU,IAAA;AAGhBb,IAAAA,SAHgB,qBAGP,KAHO,EAGP,GAHO,EAGP;AACP,UAAM3C,QAAQ,GAAd,EAAA;;AADO,mDAGP,OAHO;AAAA;;AAAA;AAGP,kEAAyB;AAAA,cAAzB,CAAyB;;AACvB,qBAAoB4B,GAAG,CAAA,KAAA,EAAA,CAAA,EAAvB,GAAuB,CAAvB;AAAA;AAAA,cAAM,MAAN;;AACA,uCAAA,MAAA;AAAA,cAAM,KAAN;;AAEA,cAAI,CAACgF,KAAK,CAAV,CAAU,CAAV,EAAe;AACb,mBAAA,EAAA;AADF,WAAA,MAEO;AAAA,yDACL,MADK;AAAA;;AAAA;AACL,wEAAgC;AAAA;AAAA,oBAAhC,OAAgC;;AAC9B,oBAAA,OAAA,EAAa;AACX5G,kBAAAA,QAAQ,CAARA,IAAAA,CAAAA,OAAAA;AACD;AACF;AALI;AAAA;AAAA;AAAA;AAAA;AAMN;AACF;AAhBM;AAAA;AAAA;AAAA;AAAA;;AAkBP,cAAO,+CAAA,WAAA,GAAA,mBAAA,GACyEW,KAAK,CAD9E,KAC8E,CADrF,SAAA,QAAA;AAMD;AA3Be,GAAX,CAAP;AA6BD;AAED;;;;;SAIgBkG,O,GAAAA;AACd,SAAOnD,MAAM,CAAA,SAAA,EAAY;AAAA,WAAzB,IAAyB;AAAA,GAAZ,CAAb;AACD;ACjpBD;;;;;;;;;;;;SAWgB5B,M,CACdV,M,EACA0F,S,EACArE,Q,EAAAA;AAEA,SAAO,IAAA,MAAA,iCAAW,MAAX;AAELA,IAAAA,OAAO,EAAE,iBAAA,KAAA,EAAA,GAAA,EAAA;AACP,aAAOM,GAAE,CAAA,KAAA,EAAFA,SAAE,CAAFA,GACH3B,MAAM,CAANA,OAAAA,CAAeqB,QAAO,CAAA,KAAA,EAAtBrB,GAAsB,CAAtBA,EADG2B,GACH3B,CADG2B,GAEH3B,MAAM,CAANA,OAAAA,CAAAA,KAAAA,EAFJ,GAEIA,CAFJ;AAGD;AANI,KAAP;AAQD;AAED;;;;;;;;SAOgB2F,S,CACd3F,M,EACA4F,Q,EAGI;AAAA,MAFJnF,OAEI,uEAAA,EAAA;AAEJ,SAAOC,MAAM,CAAA,MAAA,EAAS+E,OAAT,EAAA,EAAqBtG,UAAAA,CAAD,EAAA;AAC/B,QAAM0G,CAAC,GAAG,OAAA,QAAA,KAAA,UAAA,GAAiCD,QAAjC,EAAA,GAAV,QAAA;;AAEA,QAAIzG,CAAC,KAAL,SAAA,EAAqB;AACnB,aAAA,CAAA;AACD;;AAED,QAAI,CAACsB,OAAO,CAAR,MAAA,IAAmBpB,aAAa,CAAhC,CAAgC,CAAhC,IAAuCA,aAAa,CAAxD,CAAwD,CAAxD,EAA6D;AAC3D,UAAMyG,GAAG,qBAAQ3G,CAAR,CAAT;;AACA,UAAI4G,OAAO,GAAX,KAAA;;AAEA,WAAK,IAAL,GAAA,IAAA,CAAA,EAAqB;AACnB,YAAID,GAAG,CAAHA,GAAG,CAAHA,KAAJ,SAAA,EAA4B;AAC1BA,UAAAA,GAAG,CAAHA,GAAG,CAAHA,GAAWD,CAAC,CAAZC,GAAY,CAAZA;AACAC,UAAAA,OAAO,GAAPA,IAAAA;AACD;AACF;;AAED,UAAA,OAAA,EAAa;AACX,eAAA,GAAA;AACD;AACF;;AAED,WAAA,CAAA;AAvBF,GAAa,CAAb;AAyBD;AAED;;;;;;;;SAOgBC,O,CAAchG,M,EAAAA;AAC5B,SAAOU,MAAM,CAAA,MAAA,EAASwE,MAAT,EAAA,EAAoB/F,UAAAA,CAAD;AAAA,WAAOA,CAAC,CAAxC,IAAuCA,EAAP;AAAA,GAAnB,CAAb;AACD;AC7ED;;;;;SAIgB8G,K,CAGdjG,M,EAAAA;AACA,MAAMkG,QAAQ,GAAA,uBAAwBlG,MAAM,CAA5C,IAAA;AAEA,SAAOmG,MAAM,CAAA,MAAA,EAAA,OAAA,EAAmB3G,UAAAA,KAAD,EAAA;AAC7B,QAAIA,KAAK,YAALA,GAAAA,IAAwBA,KAAK,YAAjC,GAAA,EAAkD;AAChD,UAAQ4G,KAAR,GAAA,KAAA,CAAQA,IAAR;AACA,aACEA,KAAI,KAAJA,CAAAA,IAAiBF,QAAjBE,GAAAA,oCAAiBF,GAAjBE,KAAiBF,GADnB,GAAA;AAFF,KAAA,MAKO;AACL,UAAQd,MAAR,GAAA,KAAA,CAAQA,MAAR;AACA,aACEA,MAAM,KAANA,CAAAA,IACGc,QADHd,GAAAA,sCACGc,GADHd,MACGc,GAFL,GAAA;AAID;AAZH,GAAa,CAAb;AAcD;AAED;;;;;SAIgBG,G,CACdrG,M,EACAsG,S,EAGI;AAAA,MAFJ7F,OAEI,uEAAA,EAAA;AAEJ,MAAQ8F,SAAR,GAAA,OAAA,CAAQA,SAAR;AACA,SAAOJ,MAAM,CAAA,MAAA,EAAA,KAAA,EAAiB3G,UAAAA,KAAD,EAAA;AAC3B,WAAO+G,SAAS,GACZ/G,KAAK,GADO,SAAA,GAEZA,KAAK,IAALA,SAAAA,IAAAA,gBACgBQ,MAAM,CADtBR,IAAAA,GAAAA,gBAAAA,IAEI+G,SAAS,GAAA,EAAA,GAFb/G,cAAAA,IAAAA,SAAAA,GAAAA,iBAAAA,GAAAA,KAAAA,GAFJ,GAAA;AADF,GAAa,CAAb;AAQD;AAED;;;;;SAIgBgH,G,CACdxG,M,EACAsG,S,EAGI;AAAA,MAFJ7F,OAEI,uEAAA,EAAA;AAEJ,MAAQ8F,SAAR,GAAA,OAAA,CAAQA,SAAR;AACA,SAAOJ,MAAM,CAAA,MAAA,EAAA,KAAA,EAAiB3G,UAAAA,KAAD,EAAA;AAC3B,WAAO+G,SAAS,GACZ/G,KAAK,GADO,SAAA,GAEZA,KAAK,IAALA,SAAAA,IAAAA,gBACgBQ,MAAM,CADtBR,IAAAA,GAAAA,gBAAAA,IAEI+G,SAAS,GAAA,EAAA,GAFb/G,cAAAA,IAAAA,SAAAA,GAAAA,iBAAAA,GAAAA,KAAAA,GAFJ,GAAA;AADF,GAAa,CAAb;AAQD;AACD;;;;;SAIgBiH,O,CACdzG,M,EACAgF,M,EAAAA;AAEA,SAAOmB,MAAM,CAAA,MAAA,EAAA,SAAA,EAAqB3G,UAAAA,KAAD,EAAA;AAC/B,WACEwF,MAAM,CAANA,IAAAA,CAAAA,KAAAA,KAAAA,gBACchF,MAAM,CADpBgF,IAAAA,GAAAA,cAAAA,GACyCA,MAAM,CAD/CA,MAAAA,GAAAA,oBAAAA,GAAAA,KAAAA,GADF,IAAA;AADF,GAAa,CAAb;AAMD;AAED;;;;;SAIgBoB,I,CAGdpG,M,EAAsBwG,G,EAA2BA;AAAAA,MAAdH,GAAcG,uEAAAA,GAAAA;AACjD,MAAMN,QAAQ,GAAA,gBAAiBlG,MAAM,CAArC,IAAA;AACA,MAAM0G,EAAE,GAAGF,GAAG,KAAHA,GAAAA,GAAAA,SAAAA,GAAAA,GAAAA,GAAAA,GAAAA,cAAAA,GAAAA,GAAAA,SAAAA,GAAAA,GAAAA,GAAX,GAAA;AAEA,SAAOL,MAAM,CAAA,MAAA,EAAA,MAAA,EAAkB3G,UAAAA,KAAD,EAAA;AAC5B,QAAI,OAAA,KAAA,KAAA,QAAA,IAA6BA,KAAK,YAAtC,IAAA,EAAwD;AACtD,aACGgH,GAAG,IAAHA,KAAAA,IAAgBhH,KAAK,IAAtB,GAACgH,IACEN,QADH,GAAA,GACGA,GADH,EACGA,GADH,iBACGA,GADH,KACGA,GAFL,GAAA;AADF,KAAA,MAKO,IAAI1G,KAAK,YAALA,GAAAA,IAAwBA,KAAK,YAAjC,GAAA,EAAkD;AACvD,UAAQ4G,MAAR,GAAA,KAAA,CAAQA,IAAR;AACA,aACGI,GAAG,IAAHA,MAAAA,IAAeJ,MAAI,IAApB,GAACI,IACEN,QADH,GAAA,eACGA,GADH,EACGA,GADH,oCACGA,GADH,MACGA,GAFL,GAAA;AAFK,KAAA,MAMA;AACL,UAAQd,MAAR,GAAA,KAAA,CAAQA,MAAR;AACA,aACGoB,GAAG,IAAHA,MAAAA,IAAiBpB,MAAM,IAAxB,GAACoB,IACEN,QADH,GAAA,iBACGA,GADH,EACGA,GADH,sCACGA,GADH,MACGA,GAFL,GAAA;AAID;AAlBH,GAAa,CAAb;AAoBD;AAED;;;;;;;;;SAQgBC,M,CACdnG,M,EACAuC,I,EACAf,O,EAAAA;AAEA,SAAO,IAAA,MAAA,iCAAW,MAAX;AAEL,IAAA,OAFK;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,+DAEL,KAFK,EAEL,GAFK;AAAA;;AAAA;AAAA;AAAA;AAAA;AAGH,8CAAOxB,MAAM,CAANA,OAAAA,CAAAA,KAAAA,EAAP,GAAOA,CAAP;;AAHG;AAIGF,cAAAA,MAJH,GAIY0B,OAAO,CAAA,KAAA,EAAtB,GAAsB,CAJnB;AAKG5C,cAAAA,QALH,GAKc0B,UAAU,CAAA,MAAA,EAAA,GAAA,EAAA,MAAA,EAA3B,KAA2B,CALxB;AAAA,uDAOH,QAPG;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOH,cAAA,OAPG;AAAA;AAQD,qDAAM,OAAN;AAAoBF,gBAAAA,UAAU,EAAEmC;AAAhC;;AARC;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAP;AAYD","sourcesContent":["/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\nexport type Failure = {\n  value: any\n  key: any\n  type: string\n  refinement: string | undefined\n  message: string\n  branch: Array<any>\n  path: Array<any>\n}\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\n\nexport class StructError extends TypeError {\n  value: any\n  key!: any\n  type!: string\n  refinement!: string | undefined\n  path!: Array<any>\n  branch!: Array<any>\n  failures: () => Array<Failure>;\n  [x: string]: any\n\n  constructor(failure: Failure, failures: () => Generator<Failure>) {\n    let cached: Array<Failure> | undefined\n    const { message, ...rest } = failure\n    const { path } = failure\n    const msg =\n      path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`\n    super(msg)\n    Object.assign(this, rest)\n    this.name = this.constructor.name\n    this.failures = () => {\n      return (cached ??= [failure, ...failures()])\n    }\n  }\n}\n","import { Struct, Infer, Result, Context, Describe } from './struct'\nimport { Failure } from './error'\n\n/**\n * Check if a value is an iterator.\n */\n\nfunction isIterable<T>(x: unknown): x is Iterable<T> {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function'\n}\n\n/**\n * Check if a value is a plain object.\n */\n\nexport function isObject(x: unknown): x is object {\n  return typeof x === 'object' && x != null\n}\n\n/**\n * Check if a value is a plain object.\n */\n\nexport function isPlainObject(x: unknown): x is { [key: string]: any } {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(x)\n  return prototype === null || prototype === Object.prototype\n}\n\n/**\n * Return a value as a printable string.\n */\n\nexport function print(value: any): string {\n  return typeof value === 'string' ? JSON.stringify(value) : `${value}`\n}\n\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nexport function shiftIterator<T>(input: Iterator<T>): T | undefined {\n  const { done, value } = input.next()\n  return done ? undefined : value\n}\n\n/**\n * Convert a single validation result to a failure.\n */\n\nexport function toFailure<T, S>(\n  result: string | boolean | Partial<Failure>,\n  context: Context,\n  struct: Struct<T, S>,\n  value: any\n): Failure | undefined {\n  if (result === true) {\n    return\n  } else if (result === false) {\n    result = {}\n  } else if (typeof result === 'string') {\n    result = { message: result }\n  }\n\n  const { path, branch } = context\n  const { type } = struct\n  const {\n    refinement,\n    message = `Expected a value of type \\`${type}\\`${\n      refinement ? ` with refinement \\`${refinement}\\`` : ''\n    }, but received: \\`${print(value)}\\``,\n  } = result\n\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message,\n  }\n}\n\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nexport function* toFailures<T, S>(\n  result: Result,\n  context: Context,\n  struct: Struct<T, S>,\n  value: any\n): IterableIterator<Failure> {\n  if (!isIterable(result)) {\n    result = [result]\n  }\n\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value)\n\n    if (failure) {\n      yield failure\n    }\n  }\n}\n\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\nexport function* run<T, S>(\n  value: unknown,\n  struct: Struct<T, S>,\n  options: {\n    path?: any[]\n    branch?: any[]\n    coerce?: boolean\n    mask?: boolean\n  } = {}\n): IterableIterator<[Failure, undefined] | [undefined, T]> {\n  const { path = [], branch = [value], coerce = false, mask = false } = options\n  const ctx: Context = { path, branch }\n\n  if (coerce) {\n    value = struct.coercer(value, ctx)\n\n    if (\n      mask &&\n      struct.type !== 'type' &&\n      isObject(struct.schema) &&\n      isObject(value) &&\n      !Array.isArray(value)\n    ) {\n      for (const key in value) {\n        if (struct.schema[key] === undefined) {\n          delete value[key]\n        }\n      }\n    }\n  }\n\n  let valid = true\n\n  for (const failure of struct.validator(value, ctx)) {\n    valid = false\n    yield [failure, undefined]\n  }\n\n  for (let [k, v, s] of struct.entries(value, ctx)) {\n    const ts = run(v, s as Struct, {\n      path: k === undefined ? path : [...path, k],\n      branch: k === undefined ? branch : [...branch, v],\n      coerce,\n      mask,\n    })\n\n    for (const t of ts) {\n      if (t[0]) {\n        valid = false\n        yield [t[0], undefined]\n      } else if (coerce) {\n        v = t[1]\n\n        if (k === undefined) {\n          value = v\n        } else if (value instanceof Map) {\n          value.set(k, v)\n        } else if (value instanceof Set) {\n          value.add(v)\n        } else if (isObject(value)) {\n          value[k] = v\n        }\n      }\n    }\n  }\n\n  if (valid) {\n    for (const failure of struct.refiner(value as T, ctx)) {\n      valid = false\n      yield [failure, undefined]\n    }\n  }\n\n  if (valid) {\n    yield [undefined, value as T]\n  }\n}\n\n/**\n * Assign properties from one type to another, overwriting existing.\n */\n\nexport type Assign<T, U> = Simplify<U & Omit<T, keyof U>>\n\n/**\n * A schema for enum structs.\n */\n\nexport type EnumSchema<T extends string | number> = { [K in T]: K }\n\n/**\n * Check if a type is an exact match.\n */\n\nexport type IsMatch<T, G> = T extends G ? (G extends T ? T : never) : never\n\n/**\n * Check if a type is a record type.\n */\n\nexport type IsRecord<T> = T extends object\n  ? string extends keyof T\n    ? T\n    : never\n  : never\n/**\n * Check if a type is a tuple.\n */\n\nexport type IsTuple<T> = T extends [any]\n  ? T\n  : T extends [any, any]\n  ? T\n  : T extends [any, any, any]\n  ? T\n  : T extends [any, any, any, any]\n  ? T\n  : T extends [any, any, any, any, any]\n  ? T\n  : never\n\n/**\n * Check if a type is a union.\n */\n\nexport type IsUnion<T, U extends T = T> = (\n  T extends any ? (U extends T ? false : true) : false\n) extends false\n  ? never\n  : T\n\n/**\n * A schema for object structs.\n */\n\nexport type ObjectSchema = Record<string, Struct<any, any>>\n\n/**\n * Infer a type from an object struct schema.\n */\n\nexport type ObjectType<S extends ObjectSchema> = Simplify<\n  Optionalize<{ [K in keyof S]: Infer<S[K]> }>\n>\n\n/**\n * Omit properties from a type that extend from a specific type.\n */\n\nexport type OmitBy<T, V> = Omit<\n  T,\n  { [K in keyof T]: V extends Extract<T[K], V> ? K : never }[keyof T]\n>\n\n/**\n * Normalize properties of a type that allow `undefined` to make them optional.\n */\n\nexport type Optionalize<S extends object> = OmitBy<S, undefined> &\n  Partial<PickBy<S, undefined>>\n\n/**\n * Transform an object schema type to represent a partial.\n */\n\nexport type PartialObjectSchema<S extends ObjectSchema> = {\n  [K in keyof S]: Struct<Infer<S[K]> | undefined>\n}\n\n/**\n * Pick properties from a type that extend from a specific type.\n */\n\nexport type PickBy<T, V> = Pick<\n  T,\n  { [K in keyof T]: V extends Extract<T[K], V> ? K : never }[keyof T]\n>\n\n/**\n * Simplifies a type definition to its most basic representation.\n */\n\nexport type Simplify<T> = T extends any[] | Date\n  ? T\n  : { [K in keyof T]: T[K] } & {}\n\nexport type If<B extends Boolean, Then, Else> = B extends true ? Then : Else\n\n/**\n * A schema for any type of struct.\n */\n\nexport type StructSchema<T> = [T] extends [string]\n  ? [T] extends [IsMatch<T, string>]\n    ? null\n    : [T] extends [IsUnion<T>]\n    ? EnumSchema<T>\n    : T\n  : [T] extends [number]\n  ? [T] extends [IsMatch<T, number>]\n    ? null\n    : [T] extends [IsUnion<T>]\n    ? EnumSchema<T>\n    : T\n  : [T] extends [boolean]\n  ? [T] extends [IsMatch<T, boolean>]\n    ? null\n    : T\n  : T extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : T extends Array<infer E>\n  ? T extends IsTuple<T>\n    ? null\n    : Struct<E>\n  : T extends object\n  ? T extends IsRecord<T>\n    ? null\n    : { [K in keyof T]: Describe<T[K]> }\n  : null\n\n/**\n * A schema for tuple structs.\n */\n\nexport type TupleSchema<T> = { [K in keyof T]: Struct<T[K]> }\n","import { toFailures, shiftIterator, StructSchema, run } from './utils'\nimport { StructError, Failure } from './error'\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\nexport class Struct<T = unknown, S = unknown> {\n  readonly TYPE!: T\n  type: string\n  schema: S\n  coercer: (value: unknown, context: Context) => unknown\n  validator: (value: unknown, context: Context) => Iterable<Failure>\n  refiner: (value: T, context: Context) => Iterable<Failure>\n  entries: (\n    value: unknown,\n    context: Context\n  ) => Iterable<[string | number, unknown, Struct<any> | Struct<never>]>\n\n  constructor(props: {\n    type: string\n    schema: S\n    coercer?: Coercer\n    validator?: Validator\n    refiner?: Refiner<T>\n    entries?: Struct<T, S>['entries']\n  }) {\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = (value: unknown) => value,\n      entries = function* () {},\n    } = props\n\n    this.type = type\n    this.schema = schema\n    this.entries = entries\n    this.coercer = coercer\n\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context)\n        return toFailures(result, context, this, value)\n      }\n    } else {\n      this.validator = () => []\n    }\n\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context)\n        return toFailures(result, context, this, value)\n      }\n    } else {\n      this.refiner = () => []\n    }\n  }\n\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n  assert(value: unknown): asserts value is T {\n    return assert(value, this)\n  }\n\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n  create(value: unknown): T {\n    return create(value, this)\n  }\n\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n  is(value: unknown): value is T {\n    return is(value, this)\n  }\n\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n  mask(value: unknown): T {\n    return mask(value, this)\n  }\n\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n  validate(\n    value: unknown,\n    options: {\n      coerce?: boolean\n    } = {}\n  ): [StructError, undefined] | [undefined, T] {\n    return validate(value, this, options)\n  }\n}\n\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\n\nexport function assert<T, S>(\n  value: unknown,\n  struct: Struct<T, S>\n): asserts value is T {\n  const result = validate(value, struct)\n\n  if (result[0]) {\n    throw result[0]\n  }\n}\n\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\nexport function create<T, S>(value: unknown, struct: Struct<T, S>): T {\n  const result = validate(value, struct, { coerce: true })\n\n  if (result[0]) {\n    throw result[0]\n  } else {\n    return result[1]\n  }\n}\n\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\nexport function mask<T, S>(value: unknown, struct: Struct<T, S>): T {\n  const result = validate(value, struct, { coerce: true, mask: true })\n\n  if (result[0]) {\n    throw result[0]\n  } else {\n    return result[1]\n  }\n}\n\n/**\n * Check if a value passes a struct.\n */\n\nexport function is<T, S>(value: unknown, struct: Struct<T, S>): value is T {\n  const result = validate(value, struct)\n  return !result[0]\n}\n\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\nexport function validate<T, S>(\n  value: unknown,\n  struct: Struct<T, S>,\n  options: {\n    coerce?: boolean\n    mask?: boolean\n  } = {}\n): [StructError, undefined] | [undefined, T] {\n  const tuples = run(value, struct, options)\n  const tuple = shiftIterator(tuples)!\n\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0]\n        }\n      }\n    })\n\n    return [error, undefined]\n  } else {\n    const v = tuple[1]\n    return [undefined, v]\n  }\n}\n\n/**\n * A `Context` contains information about the current location of the\n * validation inside the initial input value.\n */\n\nexport type Context = {\n  branch: Array<any>\n  path: Array<any>\n}\n\n/**\n * A type utility to extract the type from a `Struct` class.\n */\n\nexport type Infer<T extends Struct<any, any>> = T['TYPE']\n\n/**\n * A type utility to describe that a struct represents a TypeScript type.\n */\n\nexport type Describe<T> = Struct<T, StructSchema<T>>\n\n/**\n * A `Result` is returned from validation functions.\n */\n\nexport type Result =\n  | boolean\n  | string\n  | Partial<Failure>\n  | Iterable<boolean | string | Partial<Failure>>\n\n/**\n * A `Coercer` takes an unknown value and optionally coerces it.\n */\n\nexport type Coercer<T = unknown> = (value: T, context: Context) => unknown\n\n/**\n * A `Validator` takes an unknown value and validates it.\n */\n\nexport type Validator = (value: unknown, context: Context) => Result\n\n/**\n * A `Refiner` takes a value of a known type and validates it against a further\n * constraint.\n */\n\nexport type Refiner<T> = (value: T, context: Context) => Result\n","import { Struct, Context, Validator } from '../struct'\nimport { object, optional } from './types'\nimport { ObjectSchema, Assign, ObjectType, PartialObjectSchema } from '../utils'\n\n/**\n * Create a new struct that combines the properties properties from multiple\n * object structs.\n *\n * Like JavaScript's `Object.assign` utility.\n */\n\nexport function assign<A extends ObjectSchema, B extends ObjectSchema>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>\n): Struct<ObjectType<Assign<A, B>>, Assign<A, B>>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>\n): Struct<ObjectType<Assign<Assign<A, B>, C>>, Assign<Assign<A, B>, C>>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema,\n  D extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>,\n  D: Struct<ObjectType<D>, D>\n): Struct<\n  ObjectType<Assign<Assign<Assign<A, B>, C>, D>>,\n  Assign<Assign<Assign<A, B>, C>, D>\n>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema,\n  D extends ObjectSchema,\n  E extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>,\n  D: Struct<ObjectType<D>, D>,\n  E: Struct<ObjectType<E>, E>\n): Struct<\n  ObjectType<Assign<Assign<Assign<Assign<A, B>, C>, D>, E>>,\n  Assign<Assign<Assign<Assign<A, B>, C>, D>, E>\n>\nexport function assign(...Structs: Struct<any>[]): any {\n  const schemas = Structs.map((s) => s.schema)\n  const schema = Object.assign({}, ...schemas)\n  return object(schema)\n}\n\n/**\n * Define a new struct type with a custom validation function.\n */\n\nexport function define<T>(name: string, validator: Validator): Struct<T, null> {\n  return new Struct({ type: name, schema: null, validator })\n}\n\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\n\nexport function deprecated<T>(\n  struct: Struct<T>,\n  log: (value: unknown, ctx: Context) => void\n): Struct<T> {\n  return new Struct({\n    ...struct,\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    validator(value, ctx) {\n      if (value === undefined) {\n        return true\n      } else {\n        log(value, ctx)\n        return struct.validator(value, ctx)\n      }\n    },\n  })\n}\n\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\nexport function dynamic<T>(\n  fn: (value: unknown, ctx: Context) => Struct<T, any>\n): Struct<T, null> {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n    *entries(value, ctx) {\n      const struct = fn(value, ctx)\n      yield* struct.entries(value, ctx)\n    },\n    validator(value, ctx) {\n      const struct = fn(value, ctx)\n      return struct.validator(value, ctx)\n    },\n    coercer(value, ctx) {\n      const struct = fn(value, ctx)\n      return struct.coercer(value, ctx)\n    },\n  })\n}\n\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\nexport function lazy<T>(fn: () => Struct<T, any>): Struct<T, null> {\n  let struct: Struct<T, any> | undefined\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n    *entries(value, ctx) {\n      struct ??= fn()\n      yield* struct.entries(value, ctx)\n    },\n    validator(value, ctx) {\n      struct ??= fn()\n      return struct.validator(value, ctx)\n    },\n    coercer(value, ctx) {\n      struct ??= fn()\n      return struct.coercer(value, ctx)\n    },\n  })\n}\n\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\nexport function omit<S extends ObjectSchema, K extends keyof S>(\n  struct: Struct<ObjectType<S>, S>,\n  keys: K[]\n): Struct<ObjectType<Omit<S, K>>, Omit<S, K>> {\n  const { schema } = struct\n  const subschema: any = { ...schema }\n\n  for (const key of keys) {\n    delete subschema[key]\n  }\n\n  return object(subschema as Omit<S, K>)\n}\n\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\nexport function partial<S extends ObjectSchema>(\n  struct: Struct<ObjectType<S>, S> | S\n): Struct<ObjectType<PartialObjectSchema<S>>, PartialObjectSchema<S>> {\n  const schema: any =\n    struct instanceof Struct ? { ...struct.schema } : { ...struct }\n\n  for (const key in schema) {\n    schema[key] = optional(schema[key])\n  }\n\n  return object(schema) as any\n}\n\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\nexport function pick<S extends ObjectSchema, K extends keyof S>(\n  struct: Struct<ObjectType<S>, S>,\n  keys: K[]\n): Struct<ObjectType<Pick<S, K>>, Pick<S, K>> {\n  const { schema } = struct\n  const subschema: any = {}\n\n  for (const key of keys) {\n    subschema[key] = schema[key]\n  }\n\n  return object(subschema as Pick<S, K>)\n}\n\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\nexport function struct<T>(name: string, validator: Validator): Struct<T, null> {\n  console.warn(\n    'superstruct@0.11 - The `struct` helper has been renamed to `define`.'\n  )\n\n  return define(name, validator)\n}\n","import { Infer, Struct } from '../struct'\nimport { define } from './utilities'\nimport {\n  TupleSchema,\n  ObjectSchema,\n  ObjectType,\n  print,\n  run,\n  isObject,\n} from '../utils'\n\n/**\n * Ensure that any value passes validation.\n */\n\nexport function any(): Struct<any, null> {\n  return define('any', () => true)\n}\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n */\n\nexport function array<T extends Struct<any>>(Element: T): Struct<Infer<T>[], T>\nexport function array(): Struct<unknown[], undefined>\nexport function array<T extends Struct<any>>(Element?: T): any {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element]\n        }\n      }\n    },\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array value, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a boolean.\n */\n\nexport function boolean(): Struct<boolean, null> {\n  return define('boolean', (value) => {\n    return typeof value === 'boolean'\n  })\n}\n\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nexport function date(): Struct<Date, null> {\n  return define('date', (value) => {\n    return (\n      (value instanceof Date && !isNaN(value.getTime())) ||\n      `Expected a valid \\`Date\\` object, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n */\n\nexport function enums<T extends number>(\n  values: readonly T[]\n): Struct<T, { [K in T[][number]]: K }>\nexport function enums<T extends string>(\n  values: readonly T[]\n): Struct<T, { [K in T[][number]]: K }>\nexport function enums<T extends number | string>(values: readonly T[]): any {\n  const schema: any = {}\n  const description = values.map((v) => print(v)).join()\n\n  for (const key of values) {\n    schema[key] = key\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n    validator(value) {\n      return (\n        values.includes(value as any) ||\n        `Expected one of \\`${description}\\`, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a function.\n */\n\nexport function func(): Struct<Function, null> {\n  return define('func', (value) => {\n    return (\n      typeof value === 'function' ||\n      `Expected a function, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\nexport function instance<T extends { new (...args: any): any }>(\n  Class: T\n): Struct<InstanceType<T>, null> {\n  return define('instance', (value) => {\n    return (\n      value instanceof Class ||\n      `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an integer.\n */\n\nexport function integer(): Struct<number, null> {\n  return define('integer', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n      `Expected an integer, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value matches all of a set of types.\n */\n\nexport function intersection<A>(Structs: TupleSchema<[A]>): Struct<A, null>\nexport function intersection<A, B>(\n  Structs: TupleSchema<[A, B]>\n): Struct<A & B, null>\nexport function intersection<A, B, C>(\n  Structs: TupleSchema<[A, B, C]>\n): Struct<A & B & C, null>\nexport function intersection<A, B, C, D>(\n  Structs: TupleSchema<[A, B, C, D]>\n): Struct<A & B & C & D, null>\nexport function intersection<A, B, C, D, E>(\n  Structs: TupleSchema<[A, B, C, D, E]>\n): Struct<A & B & C & D & E, null>\nexport function intersection<A, B, C, D, E, F>(\n  Structs: TupleSchema<[A, B, C, D, E, F]>\n): Struct<A & B & C & D & E & F, null>\nexport function intersection<A, B, C, D, E, F, G>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G]>\n): Struct<A & B & C & D & E & F & G, null>\nexport function intersection<A, B, C, D, E, F, G, H>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H]>\n): Struct<A & B & C & D & E & F & G & H, null>\nexport function intersection<A, B, C, D, E, F, G, H, I>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I]>\n): Struct<A & B & C & D & E & F & G & H & I, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<A & B & C & D & E & F & G & H & I & J, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<\n  A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P & Q,\n  null\n>\nexport function intersection(Structs: Array<Struct<any, any>>): any {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    *entries(value, ctx) {\n      for (const S of Structs) {\n        yield* S.entries(value, ctx)\n      }\n    },\n    *validator(value, ctx) {\n      for (const S of Structs) {\n        yield* S.validator(value, ctx)\n      }\n    },\n    *refiner(value, ctx) {\n      for (const S of Structs) {\n        yield* S.refiner(value, ctx)\n      }\n    },\n  })\n}\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n */\n\nexport function literal<T extends boolean>(constant: T): Struct<T, T>\nexport function literal<T extends number>(constant: T): Struct<T, T>\nexport function literal<T extends string>(constant: T): Struct<T, T>\nexport function literal<T>(constant: T): Struct<T, null>\nexport function literal<T>(constant: T): any {\n  const description = print(constant)\n  const t = typeof constant\n  return new Struct({\n    type: 'literal',\n    schema:\n      t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n    validator(value) {\n      return (\n        value === constant ||\n        `Expected the literal \\`${description}\\`, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n */\n\nexport function map(): Struct<Map<unknown, unknown>, null>\nexport function map<K, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Map<K, V>, null>\nexport function map<K, V>(Key?: Struct<K>, Value?: Struct<V>): any {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [k, v] of value.entries()) {\n          yield [k as string, k, Key]\n          yield [k as string, v, Value]\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value\n    },\n    validator(value) {\n      return (\n        value instanceof Map ||\n        `Expected a \\`Map\\` object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that no value ever passes validation.\n */\n\nexport function never(): Struct<never, null> {\n  return define('never', () => false)\n}\n\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nexport function nullable<T, S>(struct: Struct<T, S>): Struct<T | null, S> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n  })\n}\n\n/**\n * Ensure that a value is a number.\n */\n\nexport function number(): Struct<number, null> {\n  return define('number', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value)) ||\n      `Expected a number, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an object, that is has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n */\n\nexport function object(): Struct<Record<string, unknown>, null>\nexport function object<S extends ObjectSchema>(\n  schema: S\n): Struct<ObjectType<S>, S>\nexport function object<S extends ObjectSchema>(schema?: S): any {\n  const knowns = schema ? Object.keys(schema) : []\n  const Never = never()\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value))\n\n        for (const key of knowns) {\n          unknowns.delete(key)\n          yield [key, value[key], schema[key]]\n        }\n\n        for (const key of unknowns) {\n          yield [key, value[key], Never]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n    coercer(value) {\n      return isObject(value) ? { ...value } : value\n    },\n  })\n}\n\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nexport function optional<T, S>(struct: Struct<T, S>): Struct<T | undefined, S> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) =>\n      value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n  })\n}\n\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\nexport function record<K extends string, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Record<K, V>, null> {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k in value) {\n          const v = value[k]\n          yield [k, k, Key]\n          yield [k, v, Value]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\nexport function regexp(): Struct<RegExp, null> {\n  return define('regexp', (value) => {\n    return value instanceof RegExp\n  })\n}\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n */\n\nexport function set(): Struct<Set<unknown>, null>\nexport function set<T>(Element: Struct<T>): Struct<Set<T>, null>\nexport function set<T>(Element?: Struct<T>): any {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const v of value) {\n          yield [v as string, v, Element]\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value\n    },\n    validator(value) {\n      return (\n        value instanceof Set ||\n        `Expected a \\`Set\\` object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a string.\n */\n\nexport function string(): Struct<string, null> {\n  return define('string', (value) => {\n    return (\n      typeof value === 'string' ||\n      `Expected a string, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\n\nexport function tuple<A>(Structs: TupleSchema<[A]>): Struct<[A], null>\nexport function tuple<A, B>(Structs: TupleSchema<[A, B]>): Struct<[A, B], null>\nexport function tuple<A, B, C>(\n  Structs: TupleSchema<[A, B, C]>\n): Struct<[A, B, C], null>\nexport function tuple<A, B, C, D>(\n  Structs: TupleSchema<[A, B, C, D]>\n): Struct<[A, B, C, D], null>\nexport function tuple<A, B, C, D, E>(\n  Structs: TupleSchema<[A, B, C, D, E]>\n): Struct<[A, B, C, D, E], null>\nexport function tuple<A, B, C, D, E, F>(\n  Structs: TupleSchema<[A, B, C, D, E, F]>\n): Struct<[A, B, C, D, E, F], null>\nexport function tuple<A, B, C, D, E, F, G>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G]>\n): Struct<[A, B, C, D, E, F, G], null>\nexport function tuple<A, B, C, D, E, F, G, H>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H]>\n): Struct<[A, B, C, D, E, F, G, H], null>\nexport function tuple<A, B, C, D, E, F, G, H, I>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I]>\n): Struct<[A, B, C, D, E, F, G, H, I], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<[A, B, C, D, E, F, G, H, I, J], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q], null>\nexport function tuple(Elements: Struct<any>[]): any {\n  const Never = never()\n\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Elements.length, value.length)\n\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Elements[i] || Never]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nexport function type<S extends ObjectSchema>(\n  schema: S\n): Struct<ObjectType<S>, S> {\n  const keys = Object.keys(schema)\n  return new Struct({\n    type: 'type',\n    schema,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value matches one of a set of types.\n */\n\nexport function union<A>(Structs: TupleSchema<[A]>): Struct<A, null>\nexport function union<A, B>(Structs: TupleSchema<[A, B]>): Struct<A | B, null>\nexport function union<A, B, C>(\n  Structs: TupleSchema<[A, B, C]>\n): Struct<A | B | C, null>\nexport function union<A, B, C, D>(\n  Structs: TupleSchema<[A, B, C, D]>\n): Struct<A | B | C | D, null>\nexport function union<A, B, C, D, E>(\n  Structs: TupleSchema<[A, B, C, D, E]>\n): Struct<A | B | C | D | E, null>\nexport function union<A, B, C, D, E, F>(\n  Structs: TupleSchema<[A, B, C, D, E, F]>\n): Struct<A | B | C | D | E | F, null>\nexport function union<A, B, C, D, E, F, G>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G]>\n): Struct<A | B | C | D | E | F | G, null>\nexport function union<A, B, C, D, E, F, G, H>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H]>\n): Struct<A | B | C | D | E | F | G | H, null>\nexport function union<A, B, C, D, E, F, G, H, I>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I]>\n): Struct<A | B | C | D | E | F | G | H | I, null>\nexport function union<A, B, C, D, E, F, G, H, I, J>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<A | B | C | D | E | F | G | H | I | J, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<\n  A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q,\n  null\n>\nexport function union(Structs: Struct<any>[]): any {\n  const description = Structs.map((s) => s.type).join(' | ')\n  return new Struct({\n    type: 'union',\n    schema: null,\n    validator(value, ctx) {\n      const failures = []\n\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx)\n        const [first] = tuples\n\n        if (!first[0]) {\n          return []\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure)\n            }\n          }\n        }\n      }\n\n      return [\n        `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(\n          value\n        )}`,\n        ...failures,\n      ]\n    },\n  })\n}\n\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nexport function unknown(): Struct<unknown, null> {\n  return define('unknown', () => true)\n}\n","import { Struct, is, Coercer } from '../struct'\nimport { isPlainObject } from '../utils'\nimport { string, unknown } from './types'\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function coerce<T, S, C>(\n  struct: Struct<T, S>,\n  condition: Struct<C, any>,\n  coercer: Coercer<C>\n): Struct<T, S> {\n  return new Struct({\n    ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition)\n        ? struct.coercer(coercer(value, ctx), ctx)\n        : struct.coercer(value, ctx)\n    },\n  })\n}\n\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function defaulted<T, S>(\n  struct: Struct<T, S>,\n  fallback: any,\n  options: {\n    strict?: boolean\n  } = {}\n): Struct<T, S> {\n  return coerce(struct, unknown(), (x) => {\n    const f = typeof fallback === 'function' ? fallback() : fallback\n\n    if (x === undefined) {\n      return f\n    }\n\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x }\n      let changed = false\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key]\n          changed = true\n        }\n      }\n\n      if (changed) {\n        return ret\n      }\n    }\n\n    return x\n  })\n}\n\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function trimmed<T, S>(struct: Struct<T, S>): Struct<T, S> {\n  return coerce(struct, string(), (x) => x.trim())\n}\n","import { Struct, Refiner } from '../struct'\nimport { toFailures } from '../utils'\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\nexport function empty<\n  T extends string | any[] | Map<any, any> | Set<any>,\n  S extends any\n>(struct: Struct<T, S>): Struct<T, S> {\n  const expected = `Expected an empty ${struct.type}`\n\n  return refine(struct, 'empty', (value) => {\n    if (value instanceof Map || value instanceof Set) {\n      const { size } = value\n      return (\n        size === 0 || `${expected} but received one with a size of \\`${size}\\``\n      )\n    } else {\n      const { length } = value as string | any[]\n      return (\n        length === 0 ||\n        `${expected} but received one with a length of \\`${length}\\``\n      )\n    }\n  })\n}\n\n/**\n * Ensure that a number or date is below a threshold.\n */\n\nexport function max<T extends number | Date, S extends any>(\n  struct: Struct<T, S>,\n  threshold: T,\n  options: {\n    exclusive?: boolean\n  } = {}\n): Struct<T, S> {\n  const { exclusive } = options\n  return refine(struct, 'max', (value) => {\n    return exclusive\n      ? value < threshold\n      : value <= threshold ||\n          `Expected a ${struct.type} greater than ${\n            exclusive ? '' : 'or equal to '\n          }${threshold} but received \\`${value}\\``\n  })\n}\n\n/**\n * Ensure that a number or date is above a threshold.\n */\n\nexport function min<T extends number | Date, S extends any>(\n  struct: Struct<T, S>,\n  threshold: T,\n  options: {\n    exclusive?: boolean\n  } = {}\n): Struct<T, S> {\n  const { exclusive } = options\n  return refine(struct, 'min', (value) => {\n    return exclusive\n      ? value > threshold\n      : value >= threshold ||\n          `Expected a ${struct.type} greater than ${\n            exclusive ? '' : 'or equal to '\n          }${threshold} but received \\`${value}\\``\n  })\n}\n/**\n * Ensure that a string matches a regular expression.\n */\n\nexport function pattern<T extends string, S extends any>(\n  struct: Struct<T, S>,\n  regexp: RegExp\n): Struct<T, S> {\n  return refine(struct, 'pattern', (value) => {\n    return (\n      regexp.test(value) ||\n      `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`\n    )\n  })\n}\n\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\nexport function size<\n  T extends string | number | Date | any[] | Map<any, any> | Set<any>,\n  S extends any\n>(struct: Struct<T, S>, min: number, max: number = min): Struct<T, S> {\n  const expected = `Expected a ${struct.type}`\n  const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``\n\n  return refine(struct, 'size', (value) => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return (\n        (min <= value && value <= max) ||\n        `${expected} ${of} but received \\`${value}\\``\n      )\n    } else if (value instanceof Map || value instanceof Set) {\n      const { size } = value\n      return (\n        (min <= size && size <= max) ||\n        `${expected} with a size ${of} but received one with a size of \\`${size}\\``\n      )\n    } else {\n      const { length } = value as string | any[]\n      return (\n        (min <= length && length <= max) ||\n        `${expected} with a length ${of} but received one with a length of \\`${length}\\``\n      )\n    }\n  })\n}\n\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\nexport function refine<T, S>(\n  struct: Struct<T, S>,\n  name: string,\n  refiner: Refiner<T>\n): Struct<T, S> {\n  return new Struct({\n    ...struct,\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx)\n      const result = refiner(value, ctx)\n      const failures = toFailures(result, ctx, struct, value)\n\n      for (const failure of failures) {\n        yield { ...failure, refinement: name }\n      }\n    },\n  })\n}\n"]},"metadata":{},"sourceType":"module"}
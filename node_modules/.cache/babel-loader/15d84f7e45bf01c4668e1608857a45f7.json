{"ast":null,"code":"import { isNotNumber } from \"./assertion\";\nimport { warn } from \"./function\";\nexport var minSafeInteger = Number.MIN_SAFE_INTEGER || -9007199254740991;\nexport var maxSafeInteger = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\nfunction toNumber(value) {\n  var num = parseFloat(value);\n  return isNotNumber(num) ? 0 : num;\n}\n/**\n * Converts a value to a specific precision (or decimal points).\n *\n * Returns a string representing a number in fixed-point notation.\n *\n * @param value the value to convert\n * @param precision the precision or decimal points\n */\n\n\nexport function toPrecision(value, precision) {\n  var nextValue = toNumber(value);\n  var scaleFactor = Math.pow(10, precision != null ? precision : 10);\n  nextValue = Math.round(nextValue * scaleFactor) / scaleFactor;\n  return precision ? nextValue.toFixed(precision) : nextValue.toString();\n}\n/**\n * Counts the number of decimal places a number has\n *\n * @param value the decimal value to count\n */\n\nexport function countDecimalPlaces(value) {\n  if (!Number.isFinite(value)) return 0;\n  var e = 1;\n  var p = 0;\n\n  while (Math.round(value * e) / e !== value) {\n    e *= 10;\n    p += 1;\n  }\n\n  return p;\n}\n/**\n * Convert a value to percentage based on lower and upper bound values\n *\n * @param value the value in number\n * @param min the minimum value\n * @param max the maximum value\n */\n\nexport function valueToPercent(value, min, max) {\n  return (value - min) * 100 / (max - min);\n}\n/**\n * Calculate the value based on percentage, lower and upper bound values\n *\n * @param percent the percent value in decimals (e.g 0.6, 0.3)\n * @param min the minimum value\n * @param max the maximum value\n */\n\nexport function percentToValue(percent, min, max) {\n  return (max - min) * percent + min;\n}\n/**\n * Rounds a specific value to the next or previous step\n *\n * @param value the value to round\n * @param from the number that stepping started from\n * @param step the specified step\n */\n\nexport function roundValueToStep(value, from, step) {\n  var nextValue = Math.round((value - from) / step) * step + from;\n  var precision = countDecimalPlaces(step);\n  return toPrecision(nextValue, precision);\n}\n/**\n * Clamps a value to ensure it stays within the min and max range.\n *\n * @param value the value to clamp\n * @param min the minimum value\n * @param max the maximum value\n */\n\nexport function clampValue(value, min, max) {\n  if (value == null) return value;\n  warn({\n    condition: max < min,\n    message: \"clamp: max cannot be less than min\"\n  });\n  return Math.min(Math.max(value, min), max);\n}","map":{"version":3,"sources":["../../src/number.ts"],"names":["minSafeInteger","Number","maxSafeInteger","num","parseFloat","isNotNumber","nextValue","toNumber","scaleFactor","precision","Math","e","p","value","max","countDecimalPlaces","toPrecision","warn","condition","message"],"mappings":"AAAA,SAAA,WAAA,QAAA,aAAA;AACA,SAAA,IAAA,QAAA,YAAA;AAEA,OAAO,IAAMA,cAAc,GAAGC,MAAM,CAANA,gBAAAA,IAA2B,CAAlD,gBAAA;AACP,OAAO,IAAMC,cAAc,GAAGD,MAAM,CAANA,gBAAAA,IAAvB,gBAAA;;AAEP,SAAA,QAAA,CAAA,KAAA,EAA8B;AAC5B,MAAME,GAAG,GAAGC,UAAU,CAAtB,KAAsB,CAAtB;AACA,SAAOC,WAAW,CAAXA,GAAW,CAAXA,GAAAA,CAAAA,GAAP,GAAA;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAAA,WAAA,CAAA,KAAA,EAAA,SAAA,EAAwD;AAC7D,MAAIC,SAA0B,GAAGC,QAAQ,CAAzC,KAAyC,CAAzC;AACA,MAAMC,WAAW,YAAG,EAAH,EAAUC,SAAP,IAAA,IAAOA,GAAP,SAAOA,GAA3B,EAAiB,CAAjB;AACAH,EAAAA,SAAS,GAAGI,IAAI,CAAJA,KAAAA,CAAWJ,SAAS,GAApBI,WAAAA,IAAZJ,WAAAA;AACA,SAAOG,SAAS,GAAGH,SAAS,CAATA,OAAAA,CAAH,SAAGA,CAAH,GAAkCA,SAAS,CAA3D,QAAkDA,EAAlD;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAA,kBAAA,CAAA,KAAA,EAA2C;AAChD,MAAI,CAACL,MAAM,CAANA,QAAAA,CAAL,KAAKA,CAAL,EAA6B,OAAA,CAAA;AAE7B,MAAIU,CAAC,GAAL,CAAA;AACA,MAAIC,CAAC,GAAL,CAAA;;AACA,SAAOF,IAAI,CAAJA,KAAAA,CAAWG,KAAK,GAAhBH,CAAAA,IAAAA,CAAAA,KAAP,KAAA,EAA4C;AAC1CC,IAAAA,CAAC,IAADA,EAAAA;AACAC,IAAAA,CAAC,IAADA,CAAAA;AACD;;AACD,SAAA,CAAA;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAA,cAAA,CAAA,KAAA,EAAA,GAAA,EAAA,GAAA,EAAiE;AACtE,SAAQ,CAACC,KAAK,GAAN,GAAA,IAAD,GAAC,IAAwBC,GAAG,GAAnC,GAAQ,CAAR;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAA,cAAA,CAAA,OAAA,EAAA,GAAA,EAAA,GAAA,EAAmE;AACxE,SAAO,CAACA,GAAG,GAAJ,GAAA,IAAA,OAAA,GAAP,GAAA;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAA,gBAAA,CAAA,KAAA,EAAA,IAAA,EAAA,IAAA,EAAqE;AAC1E,MAAMR,SAAS,GAAGI,IAAI,CAAJA,KAAAA,CAAW,CAACG,KAAK,GAAN,IAAA,IAAXH,IAAAA,IAAAA,IAAAA,GAAlB,IAAA;AACA,MAAMD,SAAS,GAAGM,kBAAkB,CAApC,IAAoC,CAApC;AACA,SAAOC,WAAW,CAAA,SAAA,EAAlB,SAAkB,CAAlB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAA,UAAA,CAAA,KAAA,EAAA,GAAA,EAAA,GAAA,EAA6D;AAClE,MAAIH,KAAK,IAAT,IAAA,EAAmB,OAAA,KAAA;AAEnBI,EAAAA,IAAI,CAAC;AACHC,IAAAA,SAAS,EAAEJ,GAAG,GADX,GAAA;AAEHK,IAAAA,OAAO,EAAE;AAFN,GAAD,CAAJF;AAKA,SAAOP,IAAI,CAAJA,GAAAA,CAASA,IAAI,CAAJA,GAAAA,CAAAA,KAAAA,EAATA,GAASA,CAATA,EAAP,GAAOA,CAAP;AACD","sourcesContent":["import { isNotNumber } from \"./assertion\"\nimport { warn } from \"./function\"\n\nexport const minSafeInteger = Number.MIN_SAFE_INTEGER || -9007199254740991\nexport const maxSafeInteger = Number.MAX_SAFE_INTEGER || 9007199254740991\n\nfunction toNumber(value: any) {\n  const num = parseFloat(value)\n  return isNotNumber(num) ? 0 : num\n}\n\n/**\n * Converts a value to a specific precision (or decimal points).\n *\n * Returns a string representing a number in fixed-point notation.\n *\n * @param value the value to convert\n * @param precision the precision or decimal points\n */\nexport function toPrecision(value: number, precision?: number) {\n  let nextValue: string | number = toNumber(value)\n  const scaleFactor = 10 ** (precision ?? 10)\n  nextValue = Math.round(nextValue * scaleFactor) / scaleFactor\n  return precision ? nextValue.toFixed(precision) : nextValue.toString()\n}\n\n/**\n * Counts the number of decimal places a number has\n *\n * @param value the decimal value to count\n */\nexport function countDecimalPlaces(value: number) {\n  if (!Number.isFinite(value)) return 0\n\n  let e = 1\n  let p = 0\n  while (Math.round(value * e) / e !== value) {\n    e *= 10\n    p += 1\n  }\n  return p\n}\n\n/**\n * Convert a value to percentage based on lower and upper bound values\n *\n * @param value the value in number\n * @param min the minimum value\n * @param max the maximum value\n */\nexport function valueToPercent(value: number, min: number, max: number) {\n  return ((value - min) * 100) / (max - min)\n}\n\n/**\n * Calculate the value based on percentage, lower and upper bound values\n *\n * @param percent the percent value in decimals (e.g 0.6, 0.3)\n * @param min the minimum value\n * @param max the maximum value\n */\nexport function percentToValue(percent: number, min: number, max: number) {\n  return (max - min) * percent + min\n}\n\n/**\n * Rounds a specific value to the next or previous step\n *\n * @param value the value to round\n * @param from the number that stepping started from\n * @param step the specified step\n */\nexport function roundValueToStep(value: number, from: number, step: number) {\n  const nextValue = Math.round((value - from) / step) * step + from\n  const precision = countDecimalPlaces(step)\n  return toPrecision(nextValue, precision)\n}\n\n/**\n * Clamps a value to ensure it stays within the min and max range.\n *\n * @param value the value to clamp\n * @param min the minimum value\n * @param max the maximum value\n */\nexport function clampValue(value: number, min: number, max: number) {\n  if (value == null) return value\n\n  warn({\n    condition: max < min,\n    message: \"clamp: max cannot be less than min\",\n  })\n\n  return Math.min(Math.max(value, min), max)\n}\n"]},"metadata":{},"sourceType":"module"}
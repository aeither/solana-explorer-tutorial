'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var countup_js = require('countup.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

var DEFAULTS = {
  decimal: '.',
  delay: null,
  prefix: '',
  suffix: '',
  start: 0
};
var createCountUpInstance = function createCountUpInstance(el, props) {
  var decimal = props.decimal,
      decimals = props.decimals,
      duration = props.duration,
      easingFn = props.easingFn,
      end = props.end,
      formattingFn = props.formattingFn,
      numerals = props.numerals,
      prefix = props.prefix,
      separator = props.separator,
      start = props.start,
      suffix = props.suffix,
      useEasing = props.useEasing;
  return new countup_js.CountUp(el, end, {
    startVal: start,
    duration: duration,
    decimal: decimal,
    decimalPlaces: decimals,
    easingFn: easingFn,
    formattingFn: formattingFn,
    numerals: numerals,
    separator: separator,
    prefix: prefix,
    suffix: suffix,
    useEasing: useEasing,
    useGrouping: !!separator
  });
};

var CountUp = /*#__PURE__*/function (_Component) {
  _inherits(CountUp, _Component);

  var _super = _createSuper(CountUp);

  function CountUp() {
    var _this;

    _classCallCheck(this, CountUp);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "instance", void 0);

    _defineProperty(_assertThisInitialized(_this), "timeoutId", void 0);

    _defineProperty(_assertThisInitialized(_this), "checkProps", function (updatedProps) {
      var _this$props = _this.props,
          start = _this$props.start,
          suffix = _this$props.suffix,
          prefix = _this$props.prefix,
          redraw = _this$props.redraw,
          duration = _this$props.duration,
          separator = _this$props.separator,
          decimals = _this$props.decimals,
          decimal = _this$props.decimal,
          className = _this$props.className,
          formattingFn = _this$props.formattingFn;
      var hasPropsChanged = duration !== updatedProps.duration || start !== updatedProps.start || suffix !== updatedProps.suffix || prefix !== updatedProps.prefix || separator !== updatedProps.separator || decimals !== updatedProps.decimals || decimal !== updatedProps.decimal || className !== updatedProps.className || formattingFn !== updatedProps.formattingFn;
      return hasPropsChanged || redraw;
    });

    _defineProperty(_assertThisInitialized(_this), "createInstance", function () {
      if (typeof _this.props.children === 'function') {
        // Warn when user didn't use containerRef at all
        if (!(_this.containerRef.current instanceof Element)) {
          console.error("Couldn't find attached element to hook the CountUp instance into! Try to attach \"containerRef\" from the render prop to a an Element, eg. <span ref={containerRef} />.");
          return;
        }
      }

      return createCountUpInstance(_this.containerRef.current, _this.props);
    });

    _defineProperty(_assertThisInitialized(_this), "pauseResume", function () {
      var _this$instance;

      var _assertThisInitialize = _assertThisInitialized(_this),
          reset = _assertThisInitialize.reset,
          start = _assertThisInitialize.restart,
          update = _assertThisInitialize.update;

      var onPauseResume = _this.props.onPauseResume;
      (_this$instance = _this.instance) === null || _this$instance === void 0 ? void 0 : _this$instance.pauseResume();
      onPauseResume === null || onPauseResume === void 0 ? void 0 : onPauseResume({
        reset: reset,
        start: start,
        update: update
      });
    });

    _defineProperty(_assertThisInitialized(_this), "reset", function () {
      var _this$instance2;

      var _assertThisInitialize2 = _assertThisInitialized(_this),
          pauseResume = _assertThisInitialize2.pauseResume,
          start = _assertThisInitialize2.restart,
          update = _assertThisInitialize2.update;

      var onReset = _this.props.onReset;
      (_this$instance2 = _this.instance) === null || _this$instance2 === void 0 ? void 0 : _this$instance2.reset();
      onReset === null || onReset === void 0 ? void 0 : onReset({
        pauseResume: pauseResume,
        start: start,
        update: update
      });
    });

    _defineProperty(_assertThisInitialized(_this), "restart", function () {
      _this.reset();

      _this.start();
    });

    _defineProperty(_assertThisInitialized(_this), "start", function () {
      var _assertThisInitialize3 = _assertThisInitialized(_this),
          pauseResume = _assertThisInitialize3.pauseResume,
          reset = _assertThisInitialize3.reset,
          start = _assertThisInitialize3.restart,
          update = _assertThisInitialize3.update;

      var _this$props2 = _this.props,
          delay = _this$props2.delay,
          onEnd = _this$props2.onEnd,
          onStart = _this$props2.onStart;

      var run = function run() {
        var _this$instance3;

        return (_this$instance3 = _this.instance) === null || _this$instance3 === void 0 ? void 0 : _this$instance3.start(function () {
          return onEnd === null || onEnd === void 0 ? void 0 : onEnd({
            pauseResume: pauseResume,
            reset: reset,
            start: start,
            update: update
          });
        });
      }; // Delay start if delay prop is properly set


      if (delay && delay > 0) {
        _this.timeoutId = setTimeout(run, delay * 1000);
      } else {
        run();
      }

      onStart === null || onStart === void 0 ? void 0 : onStart({
        pauseResume: pauseResume,
        reset: reset,
        update: update
      });
    });

    _defineProperty(_assertThisInitialized(_this), "update", function (newEnd) {
      var _this$instance4;

      var _assertThisInitialize4 = _assertThisInitialized(_this),
          pauseResume = _assertThisInitialize4.pauseResume,
          reset = _assertThisInitialize4.reset,
          start = _assertThisInitialize4.restart;

      var onUpdate = _this.props.onUpdate;
      (_this$instance4 = _this.instance) === null || _this$instance4 === void 0 ? void 0 : _this$instance4.update(newEnd);
      onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate({
        pauseResume: pauseResume,
        reset: reset,
        start: start
      });
    });

    _defineProperty(_assertThisInitialized(_this), "containerRef", /*#__PURE__*/React__default['default'].createRef());

    return _this;
  }

  _createClass(CountUp, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props3 = this.props,
          children = _this$props3.children,
          delay = _this$props3.delay;
      this.instance = this.createInstance(); // Don't invoke start if component is used as a render prop

      if (typeof children === 'function' && delay !== 0) return; // Otherwise just start immediately

      this.start();
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      var end = this.props.end;
      return this.checkProps(nextProps) || end !== nextProps.end;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      // If duration, suffix, prefix, separator or start has changed
      // there's no way to update the values.
      // So we need to re-create the CountUp instance in order to
      // restart it.
      var _this$props4 = this.props,
          end = _this$props4.end,
          preserveValue = _this$props4.preserveValue;

      if (this.checkProps(prevProps)) {
        var _this$instance5;

        (_this$instance5 = this.instance) === null || _this$instance5 === void 0 ? void 0 : _this$instance5.reset();
        this.instance = this.createInstance();
        this.start();
      } // Only end value has changed, so reset and and re-animate with the updated
      // end value.


      if (end !== prevProps.end) {
        var _this$instance7;

        if (!preserveValue) {
          var _this$instance6;

          (_this$instance6 = this.instance) === null || _this$instance6 === void 0 ? void 0 : _this$instance6.reset();
        }

        (_this$instance7 = this.instance) === null || _this$instance7 === void 0 ? void 0 : _this$instance7.update(end);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this$instance8;

      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
      }

      (_this$instance8 = this.instance) === null || _this$instance8 === void 0 ? void 0 : _this$instance8.reset();
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props5 = this.props,
          children = _this$props5.children,
          className = _this$props5.className,
          style = _this$props5.style;
      var containerRef = this.containerRef,
          pauseResume = this.pauseResume,
          reset = this.reset,
          restart = this.restart,
          update = this.update;

      if (typeof children === 'function') {
        return children({
          countUpRef: containerRef,
          pauseResume: pauseResume,
          reset: reset,
          start: restart,
          update: update
        });
      }

      return /*#__PURE__*/React__default['default'].createElement("span", {
        className: className,
        ref: containerRef,
        style: style
      });
    }
  }]);

  return CountUp;
}(React.Component);

_defineProperty(CountUp, "defaultProps", _objectSpread2(_objectSpread2({}, DEFAULTS), {}, {
  redraw: false,
  style: undefined,
  preserveValue: false
}));

var defaults = _objectSpread2(_objectSpread2({}, DEFAULTS), {}, {
  startOnMount: true
});

var useCountUp = function useCountUp(props) {
  var parsedProps = _objectSpread2(_objectSpread2({}, defaults), props);

  var ref = parsedProps.ref;
  var countUpRef = React.useRef();
  var timerRef = React.useRef();

  var createInstance = function createInstance() {
    return createCountUpInstance(typeof ref === 'string' ? ref : ref.current, parsedProps);
  };

  var getCountUp = function getCountUp(recreate) {
    var countUp = countUpRef.current;

    if (countUp && !recreate) {
      return countUp;
    }

    var newCountUp = createInstance();
    countUpRef.current = newCountUp;
    return newCountUp;
  };

  var reset = function reset() {
    var onReset = parsedProps.onReset;
    getCountUp().reset();
    onReset === null || onReset === void 0 ? void 0 : onReset({
      pauseResume: pauseResume,
      start: restart,
      update: update
    });
  };

  var restart = function restart() {
    var onStart = parsedProps.onStart,
        onEnd = parsedProps.onEnd;
    getCountUp().reset();
    onStart === null || onStart === void 0 ? void 0 : onStart({
      pauseResume: pauseResume,
      reset: reset,
      update: update
    });
    getCountUp().start(function () {
      onEnd === null || onEnd === void 0 ? void 0 : onEnd({
        pauseResume: pauseResume,
        reset: reset,
        start: restart,
        update: update
      });
    });
  };

  var pauseResume = function pauseResume() {
    var onPauseResume = parsedProps.onPauseResume;
    getCountUp().pauseResume();
    onPauseResume === null || onPauseResume === void 0 ? void 0 : onPauseResume({
      reset: reset,
      start: restart,
      update: update
    });
  };

  var update = function update(newEnd) {
    var onUpdate = parsedProps.onUpdate;
    getCountUp().update(newEnd);
    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate({
      pauseResume: pauseResume,
      reset: reset,
      start: restart
    });
  };

  React.useEffect(function () {
    var delay = parsedProps.delay,
        onStart = parsedProps.onStart,
        onEnd = parsedProps.onEnd,
        startOnMount = parsedProps.startOnMount;

    if (startOnMount) {
      timerRef.current = setTimeout(function () {
        onStart === null || onStart === void 0 ? void 0 : onStart({
          pauseResume: pauseResume,
          reset: reset,
          update: update
        });
        getCountUp(true).start(function () {
          timerRef.current && clearTimeout(timerRef.current);
          onEnd === null || onEnd === void 0 ? void 0 : onEnd({
            pauseResume: pauseResume,
            reset: reset,
            start: restart,
            update: update
          });
        });
      }, delay ? delay * 1000 : 0);
    }

    return function () {
      timerRef.current && clearTimeout(timerRef.current);
      reset();
    };
  }, [parsedProps]);
  return {
    start: restart,
    pauseResume: pauseResume,
    reset: reset,
    update: update
  };
};

exports['default'] = CountUp;
exports.useCountUp = useCountUp;

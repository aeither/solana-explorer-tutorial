{"ast":null,"code":"import _defineProperty from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport { useClickable } from \"@chakra-ui/clickable\";\nimport { createDescendantContext } from \"@chakra-ui/descendant\";\nimport { useControllableState, useId, useSafeLayoutEffect } from \"@chakra-ui/hooks\";\nimport { createContext, getValidChildren, mergeRefs } from \"@chakra-ui/react-utils\";\nimport { callAllHandlers, determineLazyBehavior, focus, isUndefined, normalizeEventKey } from \"@chakra-ui/utils\";\nimport * as React from \"react\";\n/* -------------------------------------------------------------------------------------------------\n * Create context to track descendants and their indices\n * -----------------------------------------------------------------------------------------------*/\n\nvar _createDescendantCont = createDescendantContext(),\n    _createDescendantCont2 = _slicedToArray(_createDescendantCont, 4),\n    TabsDescendantsProvider = _createDescendantCont2[0],\n    useTabsDescendantsContext = _createDescendantCont2[1],\n    useTabsDescendants = _createDescendantCont2[2],\n    useTabsDescendant = _createDescendantCont2[3];\n/* -------------------------------------------------------------------------------------------------\n * useTabs - The root react hook that manages all tab items\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Tabs hooks that provides all the states, and accessibility\n * helpers to keep all things working properly.\n *\n * Its returned object will be passed unto a Context Provider\n * so all child components can read from it.\n * There is no document link yet\n * @see Docs https://chakra-ui.com/docs/components/useTabs\n */\n\n\nexport { TabsDescendantsProvider, useTabsDescendantsContext, useTabsDescendants, useTabsDescendant };\nexport function useTabs(props) {\n  var defaultIndex = props.defaultIndex,\n      onChange = props.onChange,\n      index = props.index,\n      isManual = props.isManual,\n      isLazy = props.isLazy,\n      _props$lazyBehavior = props.lazyBehavior,\n      lazyBehavior = _props$lazyBehavior === void 0 ? \"unmount\" : _props$lazyBehavior,\n      _props$orientation = props.orientation,\n      orientation = _props$orientation === void 0 ? \"horizontal\" : _props$orientation,\n      _props$direction = props.direction,\n      direction = _props$direction === void 0 ? \"ltr\" : _props$direction,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"defaultIndex\", \"onChange\", \"index\", \"isManual\", \"isLazy\", \"lazyBehavior\", \"orientation\", \"direction\"]);\n  /**\n   * We use this to keep track of the index of the focused tab.\n   *\n   * Tabs can be automatically activated, this means selection follows focus.\n   * When we navigate with the arrow keys, we move focus and selection to next/prev tab\n   *\n   * Tabs can also be manually activated, this means selection does not follow focus.\n   * When we navigate with the arrow keys, we only move focus NOT selection. The user\n   * will need not manually activate the tab using `Enter` or `Space`.\n   *\n   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`\n   */\n\n\n  var _React$useState = React.useState(defaultIndex != null ? defaultIndex : 0),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      focusedIndex = _React$useState2[0],\n      setFocusedIndex = _React$useState2[1];\n\n  var _useControllableState = useControllableState({\n    defaultValue: defaultIndex != null ? defaultIndex : 0,\n    value: index,\n    onChange: onChange\n  }),\n      _useControllableState2 = _slicedToArray(_useControllableState, 2),\n      selectedIndex = _useControllableState2[0],\n      setSelectedIndex = _useControllableState2[1];\n  /**\n   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)\n   */\n\n\n  React.useEffect(function () {\n    if (index != null) {\n      setFocusedIndex(index);\n    }\n  }, [index]);\n  /**\n   * Think of `useDescendants` as a register for the tab nodes.\n   */\n\n  var descendants = useTabsDescendants();\n  /**\n   * Generate a unique id or use user-provided id for the tabs widget\n   */\n\n  var id = useId(props.id, \"tabs\");\n  return {\n    id: id,\n    selectedIndex: selectedIndex,\n    focusedIndex: focusedIndex,\n    setSelectedIndex: setSelectedIndex,\n    setFocusedIndex: setFocusedIndex,\n    isManual: isManual,\n    isLazy: isLazy,\n    lazyBehavior: lazyBehavior,\n    orientation: orientation,\n    descendants: descendants,\n    direction: direction,\n    htmlProps: htmlProps\n  };\n}\n\nvar _createContext = createContext({\n  name: \"TabsContext\",\n  errorMessage: \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\"\n}),\n    _createContext2 = _slicedToArray(_createContext, 2),\n    TabsProvider = _createContext2[0],\n    useTabsContext = _createContext2[1];\n/**\n * Tabs hook to manage multiple tab buttons,\n * and ensures only one tab is selected per time.\n *\n * @param props props object for the tablist\n */\n\n\nexport { TabsProvider, useTabsContext };\nexport function useTabList(props) {\n  var _useTabsContext = useTabsContext(),\n      focusedIndex = _useTabsContext.focusedIndex,\n      orientation = _useTabsContext.orientation,\n      direction = _useTabsContext.direction;\n\n  var descendants = useTabsDescendantsContext();\n  var onKeyDown = React.useCallback(function (event) {\n    var _keyMap;\n\n    var nextTab = function nextTab() {\n      var next = descendants.nextEnabled(focusedIndex);\n      if (next) focus(next.node);\n    };\n\n    var prevTab = function prevTab() {\n      var prev = descendants.prevEnabled(focusedIndex);\n      if (prev) focus(prev.node);\n    };\n\n    var firstTab = function firstTab() {\n      var first = descendants.firstEnabled();\n      if (first) focus(first.node);\n    };\n\n    var lastTab = function lastTab() {\n      var last = descendants.lastEnabled();\n      if (last) focus(last.node);\n    };\n\n    var isHorizontal = orientation === \"horizontal\";\n    var isVertical = orientation === \"vertical\";\n    var eventKey = normalizeEventKey(event);\n    var ArrowStart = direction === \"ltr\" ? \"ArrowLeft\" : \"ArrowRight\";\n    var ArrowEnd = direction === \"ltr\" ? \"ArrowRight\" : \"ArrowLeft\";\n    var keyMap = (_keyMap = {}, _defineProperty(_keyMap, ArrowStart, function () {\n      return isHorizontal && prevTab();\n    }), _defineProperty(_keyMap, ArrowEnd, function () {\n      return isHorizontal && nextTab();\n    }), _defineProperty(_keyMap, \"ArrowDown\", function ArrowDown() {\n      return isVertical && nextTab();\n    }), _defineProperty(_keyMap, \"ArrowUp\", function ArrowUp() {\n      return isVertical && prevTab();\n    }), _defineProperty(_keyMap, \"Home\", firstTab), _defineProperty(_keyMap, \"End\", lastTab), _keyMap);\n    var action = keyMap[eventKey];\n\n    if (action) {\n      event.preventDefault();\n      action(event);\n    }\n  }, [descendants, focusedIndex, orientation, direction]);\n  return _extends({}, props, {\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n  });\n}\n/**\n * Tabs hook to manage each tab button.\n *\n * A tab can be disabled and focusable, or both,\n * hence the use of `useClickable` to handle this scenario\n */\n\nexport function useTab(props) {\n  var isDisabled = props.isDisabled,\n      isFocusable = props.isFocusable,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"isDisabled\", \"isFocusable\"]);\n\n  var _useTabsContext2 = useTabsContext(),\n      setSelectedIndex = _useTabsContext2.setSelectedIndex,\n      isManual = _useTabsContext2.isManual,\n      id = _useTabsContext2.id,\n      setFocusedIndex = _useTabsContext2.setFocusedIndex,\n      selectedIndex = _useTabsContext2.selectedIndex;\n\n  var _useTabsDescendant = useTabsDescendant({\n    disabled: isDisabled && !isFocusable\n  }),\n      index = _useTabsDescendant.index,\n      register = _useTabsDescendant.register;\n\n  var isSelected = index === selectedIndex;\n\n  var onClick = function onClick() {\n    setSelectedIndex(index);\n  };\n\n  var onFocus = function onFocus() {\n    setFocusedIndex(index);\n    var isDisabledButFocusable = isDisabled && isFocusable;\n    var shouldSelect = !isManual && !isDisabledButFocusable;\n\n    if (shouldSelect) {\n      setSelectedIndex(index);\n    }\n  };\n\n  var clickableProps = useClickable(_extends({}, htmlProps, {\n    ref: mergeRefs(register, props.ref),\n    isDisabled: isDisabled,\n    isFocusable: isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick)\n  }));\n  var type = \"button\";\n  return _extends({}, clickableProps, {\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type: type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus)\n  });\n}\n/**\n * Tabs hook for managing the visibility of multiple tab panels.\n *\n * Since only one panel can be show at a time, we use `cloneElement`\n * to inject `selected` panel to each TabPanel.\n *\n * It returns a cloned version of its children with\n * all functionality included.\n */\n\nexport function useTabPanels(props) {\n  var context = useTabsContext();\n  var id = context.id,\n      selectedIndex = context.selectedIndex;\n  var validChildren = getValidChildren(props.children);\n  var children = validChildren.map(function (child, index) {\n    return /*#__PURE__*/React.cloneElement(child, {\n      isSelected: index === selectedIndex,\n      id: makeTabPanelId(id, index),\n      // Refers to the associated tab element, and also provides an accessible name to the tab panel.\n      \"aria-labelledby\": makeTabId(id, index)\n    });\n  });\n  return _extends({}, props, {\n    children: children\n  });\n}\n/**\n * Tabs hook for managing the visible/hidden states\n * of the tab panel.\n *\n * @param props props object for the tab panel\n */\n\nexport function useTabPanel(props) {\n  var isSelected = props.isSelected,\n      id = props.id,\n      children = props.children,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"isSelected\", \"id\", \"children\"]);\n\n  var _useTabsContext3 = useTabsContext(),\n      isLazy = _useTabsContext3.isLazy,\n      lazyBehavior = _useTabsContext3.lazyBehavior;\n\n  var hasBeenSelected = React.useRef(false);\n\n  if (isSelected) {\n    hasBeenSelected.current = true;\n  }\n\n  var shouldRenderChildren = determineLazyBehavior({\n    hasBeenSelected: hasBeenSelected.current,\n    isSelected: isSelected,\n    isLazy: isLazy,\n    lazyBehavior: lazyBehavior\n  });\n  return _extends({\n    // Puts the tabpanel in the page `Tab` sequence.\n    tabIndex: 0\n  }, htmlProps, {\n    children: shouldRenderChildren ? children : null,\n    role: \"tabpanel\",\n    hidden: !isSelected,\n    id: id\n  });\n}\n/**\n * Tabs hook to show an animated indicators that\n * follows the active tab.\n *\n * The way we do it is by measuring the DOM Rect (or dimensions)\n * of the active tab, and return that as CSS style for\n * the indicator.\n */\n\nexport function useTabIndicator() {\n  var context = useTabsContext();\n  var descendants = useTabsDescendantsContext();\n  var selectedIndex = context.selectedIndex,\n      orientation = context.orientation;\n  var isHorizontal = orientation === \"horizontal\";\n  var isVertical = orientation === \"vertical\"; // Get the clientRect of the selected tab\n\n  var _React$useState3 = React.useState(function () {\n    if (isHorizontal) return {\n      left: 0,\n      width: 0\n    };\n    if (isVertical) return {\n      top: 0,\n      height: 0\n    };\n    return undefined;\n  }),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      rect = _React$useState4[0],\n      setRect = _React$useState4[1];\n\n  var _React$useState5 = React.useState(false),\n      _React$useState6 = _slicedToArray(_React$useState5, 2),\n      hasMeasured = _React$useState6[0],\n      setHasMeasured = _React$useState6[1]; // Update the selected tab rect when the selectedIndex changes\n\n\n  useSafeLayoutEffect(function () {\n    if (isUndefined(selectedIndex)) return undefined;\n    var tab = descendants.item(selectedIndex);\n    if (isUndefined(tab)) return undefined; // Horizontal Tab: Calculate width and left distance\n\n    if (isHorizontal) {\n      setRect({\n        left: tab.node.offsetLeft,\n        width: tab.node.offsetWidth\n      });\n    } // Vertical Tab: Calculate height and top distance\n\n\n    if (isVertical) {\n      setRect({\n        top: tab.node.offsetTop,\n        height: tab.node.offsetHeight\n      });\n    } // Prevent unwanted transition from 0 to measured rect\n    // by setting the measured state in the next tick\n\n\n    var id = requestAnimationFrame(function () {\n      setHasMeasured(true);\n    });\n    return function () {\n      if (id) {\n        cancelAnimationFrame(id);\n      }\n    };\n  }, [selectedIndex, isHorizontal, isVertical, descendants]);\n  return _extends({\n    position: \"absolute\",\n    transitionProperty: \"left, right, top, bottom\",\n    transitionDuration: hasMeasured ? \"200ms\" : \"0ms\",\n    transitionTimingFunction: \"cubic-bezier(0, 0, 0.2, 1)\"\n  }, rect);\n}\n\nfunction makeTabId(id, index) {\n  return id + \"--tab-\" + index;\n}\n\nfunction makeTabPanelId(id, index) {\n  return id + \"--tabpanel-\" + index;\n}","map":{"version":3,"sources":["../../src/use-tabs.ts"],"names":["createDescendantContext","lazyBehavior","orientation","direction","React","defaultIndex","useControllableState","defaultValue","value","onChange","index","setFocusedIndex","descendants","useTabsDescendants","id","useId","props","selectedIndex","focusedIndex","setSelectedIndex","isManual","isLazy","htmlProps","createContext","name","errorMessage","useTabsContext","useTabsDescendantsContext","onKeyDown","event","nextTab","next","focus","prevTab","prev","firstTab","first","lastTab","last","isHorizontal","isVertical","eventKey","normalizeEventKey","ArrowStart","ArrowEnd","keyMap","action","role","callAllHandlers","isFocusable","register","useTabsDescendant","disabled","isDisabled","isSelected","onClick","onFocus","isDisabledButFocusable","shouldSelect","clickableProps","useClickable","ref","mergeRefs","type","makeTabId","tabIndex","makeTabPanelId","context","validChildren","getValidChildren","children","hasBeenSelected","shouldRenderChildren","determineLazyBehavior","hidden","left","width","top","height","useSafeLayoutEffect","isUndefined","tab","setRect","offsetWidth","offsetHeight","requestAnimationFrame","setHasMeasured","cancelAnimationFrame","position","transitionProperty","transitionDuration","hasMeasured","transitionTimingFunction"],"mappings":"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","sourcesContent":["import { useClickable, UseClickableProps } from \"@chakra-ui/clickable\"\nimport { createDescendantContext } from \"@chakra-ui/descendant\"\nimport {\n  useControllableState,\n  useId,\n  useSafeLayoutEffect,\n} from \"@chakra-ui/hooks\"\nimport {\n  createContext,\n  EventKeyMap,\n  getValidChildren,\n  mergeRefs,\n} from \"@chakra-ui/react-utils\"\nimport {\n  callAllHandlers,\n  determineLazyBehavior,\n  Dict,\n  focus,\n  isUndefined,\n  LazyBehavior,\n  normalizeEventKey,\n} from \"@chakra-ui/utils\"\nimport * as React from \"react\"\n\n/* -------------------------------------------------------------------------------------------------\n * Create context to track descendants and their indices\n * -----------------------------------------------------------------------------------------------*/\n\nexport const [\n  TabsDescendantsProvider,\n  useTabsDescendantsContext,\n  useTabsDescendants,\n  useTabsDescendant,\n] = createDescendantContext<HTMLButtonElement>()\n\n/* -------------------------------------------------------------------------------------------------\n * useTabs - The root react hook that manages all tab items\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseTabsProps {\n  /**\n   * The orientation of the tab list.\n   */\n  orientation?: \"vertical\" | \"horizontal\"\n  /**\n   * If `true`, the tabs will be manually activated and\n   * display its panel by pressing Space or Enter.\n   *\n   * If `false`, the tabs will be automatically activated\n   * and their panel is displayed when they receive focus.\n   */\n  isManual?: boolean\n  /**\n   * Callback when the index (controlled or un-controlled) changes.\n   */\n  onChange?: (index: number) => void\n  /**\n   * The index of the selected tab (in controlled mode)\n   */\n  index?: number\n  /**\n   * The initial index of the selected tab (in uncontrolled mode)\n   */\n  defaultIndex?: number\n  /**\n   * The id of the tab\n   */\n  id?: string\n  /**\n   * Performance 🚀:\n   * If `true`, rendering of the tab panel's will be deferred until it is selected.\n   */\n  isLazy?: boolean\n  /**\n   * Performance 🚀:\n   * The lazy behavior of tab panels' content when not active.\n   * Only works when `isLazy={true}`\n   *\n   * - \"unmount\": The content of inactive tab panels are always unmounted.\n   * - \"keepMounted\": The content of inactive tab panels is initially unmounted,\n   * but stays mounted when selected.\n   *\n   * @default \"unmount\"\n   */\n  lazyBehavior?: LazyBehavior\n  /**\n   * The writing mode direction.\n   *\n   * - When in RTL, the left and right navigation is flipped\n   */\n  direction?: \"rtl\" | \"ltr\"\n}\n\n/**\n * Tabs hooks that provides all the states, and accessibility\n * helpers to keep all things working properly.\n *\n * Its returned object will be passed unto a Context Provider\n * so all child components can read from it.\n * There is no document link yet\n * @see Docs https://chakra-ui.com/docs/components/useTabs\n */\nexport function useTabs(props: UseTabsProps) {\n  const {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    lazyBehavior = \"unmount\",\n    orientation = \"horizontal\",\n    direction = \"ltr\",\n    ...htmlProps\n  } = props\n\n  /**\n   * We use this to keep track of the index of the focused tab.\n   *\n   * Tabs can be automatically activated, this means selection follows focus.\n   * When we navigate with the arrow keys, we move focus and selection to next/prev tab\n   *\n   * Tabs can also be manually activated, this means selection does not follow focus.\n   * When we navigate with the arrow keys, we only move focus NOT selection. The user\n   * will need not manually activate the tab using `Enter` or `Space`.\n   *\n   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`\n   */\n  const [focusedIndex, setFocusedIndex] = React.useState(defaultIndex ?? 0)\n\n  const [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex ?? 0,\n    value: index,\n    onChange,\n  })\n\n  /**\n   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)\n   */\n  React.useEffect(() => {\n    if (index != null) {\n      setFocusedIndex(index)\n    }\n  }, [index])\n\n  /**\n   * Think of `useDescendants` as a register for the tab nodes.\n   */\n  const descendants = useTabsDescendants()\n\n  /**\n   * Generate a unique id or use user-provided id for the tabs widget\n   */\n  const id = useId(props.id, `tabs`)\n\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    lazyBehavior,\n    orientation,\n    descendants,\n    direction,\n    htmlProps,\n  }\n}\n\nexport type UseTabsReturn = Omit<\n  ReturnType<typeof useTabs>,\n  \"htmlProps\" | \"descendants\"\n>\n\nexport const [TabsProvider, useTabsContext] = createContext<UseTabsReturn>({\n  name: \"TabsContext\",\n  errorMessage:\n    \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\",\n})\n\ntype Child = React.ReactElement<any>\n\nexport interface UseTabListProps {\n  children?: React.ReactNode\n  onKeyDown?: React.KeyboardEventHandler\n  ref?: React.Ref<any>\n}\n\n/**\n * Tabs hook to manage multiple tab buttons,\n * and ensures only one tab is selected per time.\n *\n * @param props props object for the tablist\n */\nexport function useTabList<P extends UseTabListProps>(props: P) {\n  const { focusedIndex, orientation, direction } = useTabsContext()\n\n  const descendants = useTabsDescendantsContext()\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      const nextTab = () => {\n        const next = descendants.nextEnabled(focusedIndex)\n        if (next) focus(next.node)\n      }\n      const prevTab = () => {\n        const prev = descendants.prevEnabled(focusedIndex)\n        if (prev) focus(prev.node)\n      }\n      const firstTab = () => {\n        const first = descendants.firstEnabled()\n        if (first) focus(first.node)\n      }\n      const lastTab = () => {\n        const last = descendants.lastEnabled()\n        if (last) focus(last.node)\n      }\n\n      const isHorizontal = orientation === \"horizontal\"\n      const isVertical = orientation === \"vertical\"\n\n      const eventKey = normalizeEventKey(event)\n\n      const ArrowStart = direction === \"ltr\" ? \"ArrowLeft\" : \"ArrowRight\"\n      const ArrowEnd = direction === \"ltr\" ? \"ArrowRight\" : \"ArrowLeft\"\n\n      const keyMap: EventKeyMap = {\n        [ArrowStart]: () => isHorizontal && prevTab(),\n        [ArrowEnd]: () => isHorizontal && nextTab(),\n        ArrowDown: () => isVertical && nextTab(),\n        ArrowUp: () => isVertical && prevTab(),\n        Home: firstTab,\n        End: lastTab,\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [descendants, focusedIndex, orientation, direction],\n  )\n\n  return {\n    ...props,\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  }\n}\n\nexport type UseTabListReturn = ReturnType<typeof useTabList>\n\nexport interface UseTabOptions {\n  id?: string\n  isSelected?: boolean\n  panelId?: string\n  /**\n   * If `true`, the `Tab` won't be toggleable\n   */\n  isDisabled?: boolean\n}\n\nexport interface UseTabProps\n  extends Omit<UseClickableProps, \"color\">,\n    UseTabOptions {}\n\n/**\n * Tabs hook to manage each tab button.\n *\n * A tab can be disabled and focusable, or both,\n * hence the use of `useClickable` to handle this scenario\n */\nexport function useTab<P extends UseTabProps>(props: P) {\n  const { isDisabled, isFocusable, ...htmlProps } = props\n\n  const {\n    setSelectedIndex,\n    isManual,\n    id,\n    setFocusedIndex,\n    selectedIndex,\n  } = useTabsContext()\n\n  const { index, register } = useTabsDescendant({\n    disabled: isDisabled && !isFocusable,\n  })\n\n  const isSelected = index === selectedIndex\n\n  const onClick = () => {\n    setSelectedIndex(index)\n  }\n\n  const onFocus = () => {\n    setFocusedIndex(index)\n    const isDisabledButFocusable = isDisabled && isFocusable\n    const shouldSelect = !isManual && !isDisabledButFocusable\n    if (shouldSelect) {\n      setSelectedIndex(index)\n    }\n  }\n\n  const clickableProps = useClickable({\n    ...htmlProps,\n    ref: mergeRefs(register, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick),\n  })\n\n  const type: \"button\" | \"submit\" | \"reset\" = \"button\"\n\n  return {\n    ...clickableProps,\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus),\n  }\n}\n\nexport interface UseTabPanelsProps {\n  children?: React.ReactNode\n}\n\n/**\n * Tabs hook for managing the visibility of multiple tab panels.\n *\n * Since only one panel can be show at a time, we use `cloneElement`\n * to inject `selected` panel to each TabPanel.\n *\n * It returns a cloned version of its children with\n * all functionality included.\n */\nexport function useTabPanels<P extends UseTabPanelsProps>(props: P) {\n  const context = useTabsContext()\n\n  const { id, selectedIndex } = context\n\n  const validChildren = getValidChildren(props.children)\n\n  const children = validChildren.map((child, index) =>\n    React.cloneElement(child as Child, {\n      isSelected: index === selectedIndex,\n      id: makeTabPanelId(id, index),\n      // Refers to the associated tab element, and also provides an accessible name to the tab panel.\n      \"aria-labelledby\": makeTabId(id, index),\n    }),\n  )\n\n  return { ...props, children }\n}\n\n/**\n * Tabs hook for managing the visible/hidden states\n * of the tab panel.\n *\n * @param props props object for the tab panel\n */\nexport function useTabPanel(props: Dict) {\n  const { isSelected, id, children, ...htmlProps } = props\n  const { isLazy, lazyBehavior } = useTabsContext()\n\n  const hasBeenSelected = React.useRef(false)\n  if (isSelected) {\n    hasBeenSelected.current = true\n  }\n\n  const shouldRenderChildren = determineLazyBehavior({\n    hasBeenSelected: hasBeenSelected.current,\n    isSelected,\n    isLazy,\n    lazyBehavior,\n  })\n\n  return {\n    // Puts the tabpanel in the page `Tab` sequence.\n    tabIndex: 0,\n    ...htmlProps,\n    children: shouldRenderChildren ? children : null,\n    role: \"tabpanel\",\n    hidden: !isSelected,\n    id,\n  }\n}\n\n/**\n * Tabs hook to show an animated indicators that\n * follows the active tab.\n *\n * The way we do it is by measuring the DOM Rect (or dimensions)\n * of the active tab, and return that as CSS style for\n * the indicator.\n */\nexport function useTabIndicator(): React.CSSProperties {\n  const context = useTabsContext()\n  const descendants = useTabsDescendantsContext()\n\n  const { selectedIndex, orientation } = context\n\n  const isHorizontal = orientation === \"horizontal\"\n  const isVertical = orientation === \"vertical\"\n\n  // Get the clientRect of the selected tab\n  const [rect, setRect] = React.useState(() => {\n    if (isHorizontal) return { left: 0, width: 0 }\n    if (isVertical) return { top: 0, height: 0 }\n    return undefined\n  })\n\n  const [hasMeasured, setHasMeasured] = React.useState(false)\n\n  // Update the selected tab rect when the selectedIndex changes\n  useSafeLayoutEffect(() => {\n    if (isUndefined(selectedIndex)) return undefined\n\n    const tab = descendants.item(selectedIndex)\n    if (isUndefined(tab)) return undefined\n\n    // Horizontal Tab: Calculate width and left distance\n    if (isHorizontal) {\n      setRect({ left: tab.node.offsetLeft, width: tab.node.offsetWidth })\n    }\n\n    // Vertical Tab: Calculate height and top distance\n    if (isVertical) {\n      setRect({ top: tab.node.offsetTop, height: tab.node.offsetHeight })\n    }\n\n    // Prevent unwanted transition from 0 to measured rect\n    // by setting the measured state in the next tick\n    const id = requestAnimationFrame(() => {\n      setHasMeasured(true)\n    })\n\n    return () => {\n      if (id) {\n        cancelAnimationFrame(id)\n      }\n    }\n  }, [selectedIndex, isHorizontal, isVertical, descendants])\n\n  return {\n    position: \"absolute\",\n    transitionProperty: \"left, right, top, bottom\",\n    transitionDuration: hasMeasured ? \"200ms\" : \"0ms\",\n    transitionTimingFunction: \"cubic-bezier(0, 0, 0.2, 1)\",\n    ...rect,\n  }\n}\n\nfunction makeTabId(id: string, index: number) {\n  return `${id}--tab-${index}`\n}\n\nfunction makeTabPanelId(id: string, index: number) {\n  return `${id}--tabpanel-${index}`\n}\n"]},"metadata":{},"sourceType":"module"}
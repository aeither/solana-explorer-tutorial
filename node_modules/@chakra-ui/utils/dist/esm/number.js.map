{"version":3,"sources":["../../src/number.ts"],"names":["isNotNumber","warn","minSafeInteger","Number","MIN_SAFE_INTEGER","maxSafeInteger","MAX_SAFE_INTEGER","toNumber","value","num","parseFloat","toPrecision","precision","nextValue","scaleFactor","Math","round","toFixed","toString","countDecimalPlaces","isFinite","e","p","valueToPercent","min","max","percentToValue","percent","roundValueToStep","from","step","clampValue","condition","message"],"mappings":"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","sourcesContent":["import { isNotNumber } from \"./assertion\"\nimport { warn } from \"./function\"\n\nexport const minSafeInteger = Number.MIN_SAFE_INTEGER || -9007199254740991\nexport const maxSafeInteger = Number.MAX_SAFE_INTEGER || 9007199254740991\n\nfunction toNumber(value: any) {\n  const num = parseFloat(value)\n  return isNotNumber(num) ? 0 : num\n}\n\n/**\n * Converts a value to a specific precision (or decimal points).\n *\n * Returns a string representing a number in fixed-point notation.\n *\n * @param value the value to convert\n * @param precision the precision or decimal points\n */\nexport function toPrecision(value: number, precision?: number) {\n  let nextValue: string | number = toNumber(value)\n  const scaleFactor = 10 ** (precision ?? 10)\n  nextValue = Math.round(nextValue * scaleFactor) / scaleFactor\n  return precision ? nextValue.toFixed(precision) : nextValue.toString()\n}\n\n/**\n * Counts the number of decimal places a number has\n *\n * @param value the decimal value to count\n */\nexport function countDecimalPlaces(value: number) {\n  if (!Number.isFinite(value)) return 0\n\n  let e = 1\n  let p = 0\n  while (Math.round(value * e) / e !== value) {\n    e *= 10\n    p += 1\n  }\n  return p\n}\n\n/**\n * Convert a value to percentage based on lower and upper bound values\n *\n * @param value the value in number\n * @param min the minimum value\n * @param max the maximum value\n */\nexport function valueToPercent(value: number, min: number, max: number) {\n  return ((value - min) * 100) / (max - min)\n}\n\n/**\n * Calculate the value based on percentage, lower and upper bound values\n *\n * @param percent the percent value in decimals (e.g 0.6, 0.3)\n * @param min the minimum value\n * @param max the maximum value\n */\nexport function percentToValue(percent: number, min: number, max: number) {\n  return (max - min) * percent + min\n}\n\n/**\n * Rounds a specific value to the next or previous step\n *\n * @param value the value to round\n * @param from the number that stepping started from\n * @param step the specified step\n */\nexport function roundValueToStep(value: number, from: number, step: number) {\n  const nextValue = Math.round((value - from) / step) * step + from\n  const precision = countDecimalPlaces(step)\n  return toPrecision(nextValue, precision)\n}\n\n/**\n * Clamps a value to ensure it stays within the min and max range.\n *\n * @param value the value to clamp\n * @param min the minimum value\n * @param max the maximum value\n */\nexport function clampValue(value: number, min: number, max: number) {\n  if (value == null) return value\n\n  warn({\n    condition: max < min,\n    message: \"clamp: max cannot be less than min\",\n  })\n\n  return Math.min(Math.max(value, min), max)\n}\n"],"file":"number.js"}
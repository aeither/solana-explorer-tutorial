{"ast":null,"code":"import _slicedToArray from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Used to define the anatomy/parts of a component in a way that provides\n * a consistent API for `className`, css selector and `theming`.\n */\n\n\nexport var Anatomy = /*#__PURE__*/function () {\n  function Anatomy(name) {\n    var _this2 = this;\n\n    _classCallCheck(this, Anatomy);\n\n    var _this = this;\n\n    this.name = name;\n\n    _defineProperty(this, \"map\", {});\n\n    _defineProperty(this, \"called\", false);\n\n    _defineProperty(this, \"assert\", function () {\n      if (!_this2.called) {\n        _this2.called = true;\n        return;\n      }\n\n      throw new Error(\"[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?\");\n    });\n\n    _defineProperty(this, \"parts\", function () {\n      _this.assert();\n\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n\n      for (var _i = 0, _values = values; _i < _values.length; _i++) {\n        var part = _values[_i];\n        ;\n        _this.map[part] = _this.toPart(part);\n      }\n\n      return _this;\n    });\n\n    _defineProperty(this, \"extend\", function () {\n      for (var _len2 = arguments.length, parts = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        parts[_key2] = arguments[_key2];\n      }\n\n      for (var _i2 = 0, _parts = parts; _i2 < _parts.length; _i2++) {\n        var part = _parts[_i2];\n        if (part in _this.map) continue;\n        _this.map[part] = _this.toPart(part);\n      }\n\n      return _this;\n    });\n\n    _defineProperty(this, \"toPart\", function (part) {\n      var el = [\"container\", \"root\"].includes(part != null ? part : \"\") ? [_this2.name] : [_this2.name, part];\n      var attr = el.filter(Boolean).join(\"__\");\n      var className = \"chakra-\" + attr;\n      var partObj = {\n        className: className,\n        selector: \".\" + className,\n        toString: function toString() {\n          return part;\n        }\n      };\n      return partObj;\n    });\n\n    _defineProperty(this, \"__type\", {});\n  }\n  /**\n   * Prevents user from calling `.parts` multiple times.\n   * It should only be called once.\n   */\n\n  /**\n   * Get all selectors for the component anatomy\n   */\n\n\n  _createClass(Anatomy, [{\n    key: \"selectors\",\n    get: function get() {\n      var value = Object.fromEntries(Object.entries(this.map).map(function (_ref) {\n        var _ref3 = _slicedToArray(_ref, 2),\n            key = _ref3[0],\n            part = _ref3[1];\n\n        return [key, part.selector];\n      }));\n      return value;\n    }\n    /**\n     * Get all classNames for the component anatomy\n     */\n\n  }, {\n    key: \"classNames\",\n    get: function get() {\n      var value = Object.fromEntries(Object.entries(this.map).map(function (_ref2) {\n        var _ref4 = _slicedToArray(_ref2, 2),\n            key = _ref4[0],\n            part = _ref4[1];\n\n        return [key, part.className];\n      }));\n      return value;\n    }\n    /**\n     * Get all parts as array of string\n     */\n\n  }, {\n    key: \"keys\",\n    get: function get() {\n      return Object.keys(this.map);\n    }\n    /**\n     * Creates the part object for the given part\n     */\n\n  }]);\n\n  return Anatomy;\n}();\nexport function anatomy(name) {\n  return new Anatomy(name);\n}","map":{"version":3,"sources":["../../src/anatomy.ts"],"names":["constructor","name","values","part","parts","value","Object","el","attr","className","partObj","selector","toString"],"mappings":"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","sourcesContent":["/**\n * Used to define the anatomy/parts of a component in a way that provides\n * a consistent API for `className`, css selector and `theming`.\n */\nexport class Anatomy<T extends string = string> {\n  private map: Record<T, Part> = {} as Record<T, Part>\n  private called = false\n\n  constructor(private name: string) {}\n\n  /**\n   * Prevents user from calling `.parts` multiple times.\n   * It should only be called once.\n   */\n  private assert = () => {\n    if (!this.called) {\n      this.called = true\n      return\n    }\n\n    throw new Error(\n      \"[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?\",\n    )\n  }\n\n  /**\n   * Add the core parts of the components\n   */\n  public parts = <V extends string>(...values: V[]) => {\n    this.assert()\n    for (const part of values) {\n      ;(this.map as any)[part] = this.toPart(part)\n    }\n    return (this as unknown) as Omit<Anatomy<V>, \"parts\">\n  }\n\n  /**\n   * Extend the component anatomy to includes new parts\n   */\n  public extend = <U extends string>(...parts: U[]) => {\n    for (const part of parts) {\n      if (part in this.map) continue\n      ;(this.map as any)[part] = this.toPart(part)\n    }\n    return (this as unknown) as Omit<Anatomy<T | U>, \"parts\">\n  }\n\n  /**\n   * Get all selectors for the component anatomy\n   */\n  get selectors() {\n    const value = Object.fromEntries(\n      Object.entries(this.map).map(([key, part]) => [\n        key,\n        (part as any).selector,\n      ]),\n    )\n    return value as Record<T, string>\n  }\n\n  /**\n   * Get all classNames for the component anatomy\n   */\n  get classNames() {\n    const value = Object.fromEntries(\n      Object.entries(this.map).map(([key, part]) => [\n        key,\n        (part as any).className,\n      ]),\n    )\n    return value as Record<T, string>\n  }\n\n  /**\n   * Get all parts as array of string\n   */\n  get keys() {\n    return Object.keys(this.map) as T[]\n  }\n\n  /**\n   * Creates the part object for the given part\n   */\n  toPart = (part: string) => {\n    const el = [\"container\", \"root\"].includes(part ?? \"\")\n      ? [this.name]\n      : [this.name, part]\n    const attr = el.filter(Boolean).join(\"__\")\n    const className = `chakra-${attr}`\n\n    const partObj = {\n      className,\n      selector: `.${className}`,\n      toString: () => part,\n    }\n\n    return partObj as typeof partObj & string\n  }\n\n  /**\n   * Used to get the derived type of the anatomy\n   */\n  __type = {} as T\n}\n\ntype Part = {\n  className: string\n  selector: string\n  toString: () => string\n}\n\nexport function anatomy(name: string) {\n  return new Anatomy(name)\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { mix, distance, clamp, progress } from 'popmotion';\n\nvar clampProgress = function clampProgress(v) {\n  return clamp(0, 1, v);\n};\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\n\n\nfunction isNear(value, target, maxDistance) {\n  if (target === void 0) {\n    target = 0;\n  }\n\n  if (maxDistance === void 0) {\n    maxDistance = 0.01;\n  }\n\n  return distance(value, target) < maxDistance;\n}\n\nfunction calcLength(axis) {\n  return axis.max - axis.min;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\n\n\nfunction calcOrigin(source, target) {\n  var origin = 0.5;\n  var sourceLength = calcLength(source);\n  var targetLength = calcLength(target);\n\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n\n  return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\n\n\nfunction updateAxisDelta(delta, source, target, origin) {\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n\n  delta.origin = origin;\n  delta.originPoint = mix(source.min, source.max, delta.origin);\n  delta.scale = calcLength(target) / calcLength(source);\n  if (isNear(delta.scale, 1, 0.0001)) delta.scale = 1;\n  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;\n  if (isNear(delta.translate)) delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\n\n\nfunction updateBoxDelta(delta, source, target, origin) {\n  updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\n  updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\n}\n/**\n * Currently this only accepts numerical origins, measured as 0-1, but could\n * accept pixel values by comparing to the target axis.\n */\n\n\nfunction defaultOrigin(origin) {\n  return typeof origin === \"number\" ? origin : 0.5;\n}\n\nfunction calcRelativeAxis(target, relative, parent) {\n  target.min = parent.min + relative.min;\n  target.max = target.min + calcLength(relative);\n}\n\nfunction calcRelativeBox(projection, parentProjection) {\n  calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\n  calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\n}\n\nexport { calcOrigin, calcRelativeAxis, calcRelativeBox, isNear, updateAxisDelta, updateBoxDelta };","map":{"version":3,"sources":["/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/framer-motion/dist/es/utils/geometry/delta-calc.js"],"names":["mix","distance","clamp","progress","clampProgress","v","isNear","value","target","maxDistance","calcLength","axis","max","min","calcOrigin","source","origin","sourceLength","targetLength","updateAxisDelta","delta","originPoint","scale","translate","updateBoxDelta","x","defaultOrigin","originX","y","originY","calcRelativeAxis","relative","parent","calcRelativeBox","projection","parentProjection","relativeTarget"],"mappings":"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","sourcesContent":["import { mix, distance, clamp, progress } from 'popmotion';\n\nvar clampProgress = function (v) { return clamp(0, 1, v); };\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\nfunction isNear(value, target, maxDistance) {\n    if (target === void 0) { target = 0; }\n    if (maxDistance === void 0) { maxDistance = 0.01; }\n    return distance(value, target) < maxDistance;\n}\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    var origin = 0.5;\n    var sourceLength = calcLength(source);\n    var targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = progress(source.min, source.max - targetLength, target.min);\n    }\n    return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateAxisDelta(delta, source, target, origin) {\n    if (origin === void 0) { origin = 0.5; }\n    delta.origin = origin;\n    delta.originPoint = mix(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    if (isNear(delta.scale, 1, 0.0001))\n        delta.scale = 1;\n    delta.translate =\n        mix(target.min, target.max, delta.origin) - delta.originPoint;\n    if (isNear(delta.translate))\n        delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateBoxDelta(delta, source, target, origin) {\n    updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\n    updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\n}\n/**\n * Currently this only accepts numerical origins, measured as 0-1, but could\n * accept pixel values by comparing to the target axis.\n */\nfunction defaultOrigin(origin) {\n    return typeof origin === \"number\" ? origin : 0.5;\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(projection, parentProjection) {\n    calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\n    calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\n}\n\nexport { calcOrigin, calcRelativeAxis, calcRelativeBox, isNear, updateAxisDelta, updateBoxDelta };\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { correctNodes } from './utils/correctFocus';\nimport { pickFocusable } from './utils/firstFocus';\nimport { isGuard } from './utils/is';\nexport var NEW_FOCUS = 'NEW_FOCUS';\nexport var newFocus = function newFocus(innerNodes, outerNodes, activeElement, lastNode) {\n  var cnt = innerNodes.length;\n  var firstFocus = innerNodes[0];\n  var lastFocus = innerNodes[cnt - 1];\n  var isOnGuard = isGuard(activeElement);\n\n  if (innerNodes.indexOf(activeElement) >= 0) {\n    return undefined;\n  }\n\n  var activeIndex = outerNodes.indexOf(activeElement);\n  var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;\n  var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;\n  var indexDiff = activeIndex - lastIndex;\n  var firstNodeIndex = outerNodes.indexOf(firstFocus);\n  var lastNodeIndex = outerNodes.indexOf(lastFocus);\n  var correctedNodes = correctNodes(outerNodes);\n  var correctedIndexDiff = correctedNodes.indexOf(activeElement) - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);\n  var returnFirstNode = pickFocusable(innerNodes, 0);\n  var returnLastNode = pickFocusable(innerNodes, cnt - 1);\n\n  if (activeIndex === -1 || lastNodeInside === -1) {\n    return NEW_FOCUS;\n  }\n\n  if (!indexDiff && lastNodeInside >= 0) {\n    return lastNodeInside;\n  }\n\n  if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n    return returnLastNode;\n  }\n\n  if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n    return returnFirstNode;\n  }\n\n  if (indexDiff && Math.abs(correctedIndexDiff) > 1) {\n    return lastNodeInside;\n  }\n\n  if (activeIndex <= firstNodeIndex) {\n    return returnLastNode;\n  }\n\n  if (activeIndex > lastNodeIndex) {\n    return returnFirstNode;\n  }\n\n  if (indexDiff) {\n    if (Math.abs(indexDiff) > 1) {\n      return lastNodeInside;\n    }\n\n    return (cnt + lastNodeInside + indexDiff) % cnt;\n  }\n\n  return undefined;\n};","map":{"version":3,"sources":["/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/focus-lock/dist/es2015/solver.js"],"names":["correctNodes","pickFocusable","isGuard","NEW_FOCUS","newFocus","innerNodes","outerNodes","activeElement","lastNode","cnt","length","firstFocus","lastFocus","isOnGuard","indexOf","undefined","activeIndex","lastIndex","lastNodeInside","indexDiff","firstNodeIndex","lastNodeIndex","correctedNodes","correctedIndexDiff","returnFirstNode","returnLastNode","Math","abs"],"mappings":"AAAA,SAASA,YAAT,QAA6B,sBAA7B;AACA,SAASC,aAAT,QAA8B,oBAA9B;AACA,SAASC,OAAT,QAAwB,YAAxB;AACA,OAAO,IAAIC,SAAS,GAAG,WAAhB;AACP,OAAO,IAAIC,QAAQ,GAAG,SAAXA,QAAW,CAAUC,UAAV,EAAsBC,UAAtB,EAAkCC,aAAlC,EAAiDC,QAAjD,EAA2D;AAC7E,MAAIC,GAAG,GAAGJ,UAAU,CAACK,MAArB;AACA,MAAIC,UAAU,GAAGN,UAAU,CAAC,CAAD,CAA3B;AACA,MAAIO,SAAS,GAAGP,UAAU,CAACI,GAAG,GAAG,CAAP,CAA1B;AACA,MAAII,SAAS,GAAGX,OAAO,CAACK,aAAD,CAAvB;;AACA,MAAIF,UAAU,CAACS,OAAX,CAAmBP,aAAnB,KAAqC,CAAzC,EAA4C;AACxC,WAAOQ,SAAP;AACH;;AACD,MAAIC,WAAW,GAAGV,UAAU,CAACQ,OAAX,CAAmBP,aAAnB,CAAlB;AACA,MAAIU,SAAS,GAAGT,QAAQ,GAAGF,UAAU,CAACQ,OAAX,CAAmBN,QAAnB,CAAH,GAAkCQ,WAA1D;AACA,MAAIE,cAAc,GAAGV,QAAQ,GAAGH,UAAU,CAACS,OAAX,CAAmBN,QAAnB,CAAH,GAAkC,CAAC,CAAhE;AACA,MAAIW,SAAS,GAAGH,WAAW,GAAGC,SAA9B;AACA,MAAIG,cAAc,GAAGd,UAAU,CAACQ,OAAX,CAAmBH,UAAnB,CAArB;AACA,MAAIU,aAAa,GAAGf,UAAU,CAACQ,OAAX,CAAmBF,SAAnB,CAApB;AACA,MAAIU,cAAc,GAAGtB,YAAY,CAACM,UAAD,CAAjC;AACA,MAAIiB,kBAAkB,GAAGD,cAAc,CAACR,OAAf,CAAuBP,aAAvB,KAAyCC,QAAQ,GAAGc,cAAc,CAACR,OAAf,CAAuBN,QAAvB,CAAH,GAAsCQ,WAAvF,CAAzB;AACA,MAAIQ,eAAe,GAAGvB,aAAa,CAACI,UAAD,EAAa,CAAb,CAAnC;AACA,MAAIoB,cAAc,GAAGxB,aAAa,CAACI,UAAD,EAAaI,GAAG,GAAG,CAAnB,CAAlC;;AACA,MAAIO,WAAW,KAAK,CAAC,CAAjB,IAAsBE,cAAc,KAAK,CAAC,CAA9C,EAAiD;AAC7C,WAAOf,SAAP;AACH;;AACD,MAAI,CAACgB,SAAD,IAAcD,cAAc,IAAI,CAApC,EAAuC;AACnC,WAAOA,cAAP;AACH;;AACD,MAAIF,WAAW,IAAII,cAAf,IAAiCP,SAAjC,IAA8Ca,IAAI,CAACC,GAAL,CAASR,SAAT,IAAsB,CAAxE,EAA2E;AACvE,WAAOM,cAAP;AACH;;AACD,MAAIT,WAAW,IAAIK,aAAf,IAAgCR,SAAhC,IAA6Ca,IAAI,CAACC,GAAL,CAASR,SAAT,IAAsB,CAAvE,EAA0E;AACtE,WAAOK,eAAP;AACH;;AACD,MAAIL,SAAS,IAAIO,IAAI,CAACC,GAAL,CAASJ,kBAAT,IAA+B,CAAhD,EAAmD;AAC/C,WAAOL,cAAP;AACH;;AACD,MAAIF,WAAW,IAAII,cAAnB,EAAmC;AAC/B,WAAOK,cAAP;AACH;;AACD,MAAIT,WAAW,GAAGK,aAAlB,EAAiC;AAC7B,WAAOG,eAAP;AACH;;AACD,MAAIL,SAAJ,EAAe;AACX,QAAIO,IAAI,CAACC,GAAL,CAASR,SAAT,IAAsB,CAA1B,EAA6B;AACzB,aAAOD,cAAP;AACH;;AACD,WAAO,CAACT,GAAG,GAAGS,cAAN,GAAuBC,SAAxB,IAAqCV,GAA5C;AACH;;AACD,SAAOM,SAAP;AACH,CA9CM","sourcesContent":["import { correctNodes } from './utils/correctFocus';\nimport { pickFocusable } from './utils/firstFocus';\nimport { isGuard } from './utils/is';\nexport var NEW_FOCUS = 'NEW_FOCUS';\nexport var newFocus = function (innerNodes, outerNodes, activeElement, lastNode) {\n    var cnt = innerNodes.length;\n    var firstFocus = innerNodes[0];\n    var lastFocus = innerNodes[cnt - 1];\n    var isOnGuard = isGuard(activeElement);\n    if (innerNodes.indexOf(activeElement) >= 0) {\n        return undefined;\n    }\n    var activeIndex = outerNodes.indexOf(activeElement);\n    var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;\n    var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;\n    var indexDiff = activeIndex - lastIndex;\n    var firstNodeIndex = outerNodes.indexOf(firstFocus);\n    var lastNodeIndex = outerNodes.indexOf(lastFocus);\n    var correctedNodes = correctNodes(outerNodes);\n    var correctedIndexDiff = correctedNodes.indexOf(activeElement) - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);\n    var returnFirstNode = pickFocusable(innerNodes, 0);\n    var returnLastNode = pickFocusable(innerNodes, cnt - 1);\n    if (activeIndex === -1 || lastNodeInside === -1) {\n        return NEW_FOCUS;\n    }\n    if (!indexDiff && lastNodeInside >= 0) {\n        return lastNodeInside;\n    }\n    if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n        return returnLastNode;\n    }\n    if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n        return returnFirstNode;\n    }\n    if (indexDiff && Math.abs(correctedIndexDiff) > 1) {\n        return lastNodeInside;\n    }\n    if (activeIndex <= firstNodeIndex) {\n        return returnLastNode;\n    }\n    if (activeIndex > lastNodeIndex) {\n        return returnFirstNode;\n    }\n    if (indexDiff) {\n        if (Math.abs(indexDiff) > 1) {\n            return lastNodeInside;\n        }\n        return (cnt + lastNodeInside + indexDiff) % cnt;\n    }\n    return undefined;\n};\n"]},"metadata":{},"sourceType":"module"}
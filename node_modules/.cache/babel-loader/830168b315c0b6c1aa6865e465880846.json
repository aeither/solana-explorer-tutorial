{"ast":null,"code":"import { createTransform } from \"./create-transform\";\nexport function toConfig(scale, transform) {\n  return function (property) {\n    var result = {\n      property: property,\n      scale: scale\n    };\n    result.transform = createTransform({\n      scale: scale,\n      transform: transform\n    });\n    return result;\n  };\n}\n\nvar getRtl = function getRtl(_ref) {\n  var rtl = _ref.rtl,\n      ltr = _ref.ltr;\n  return function (theme) {\n    return theme.direction === \"rtl\" ? rtl : ltr;\n  };\n};\n\nexport function logical(options) {\n  var property = options.property,\n      scale = options.scale,\n      transform = options.transform;\n  return {\n    scale: scale,\n    property: getRtl(property),\n    transform: scale ? createTransform({\n      scale: scale,\n      compose: transform\n    }) : transform\n  };\n}","map":{"version":3,"sources":["../../../src/utils/prop-config.ts"],"names":["property","result","scale","createTransform","transform","getRtl","ltr","theme","compose"],"mappings":"AAEA,SAAA,eAAA,QAAA,oBAAA;AAsCA,OAAO,SAAA,QAAA,CAAA,KAAA,EAAA,SAAA,EAA4D;AACjE,SAA2BA,UAAAA,QAApB,EAA0C;AAC/C,QAAMC,MAAkB,GAAG;AAAED,MAAAA,QAAF,EAAEA,QAAF;AAAYE,MAAAA,KAAAA,EAAAA;AAAZ,KAA3B;AACAD,IAAAA,MAAM,CAANA,SAAAA,GAAmBE,eAAe,CAAC;AACjCD,MAAAA,KADiC,EACjCA,KADiC;AAEjCE,MAAAA,SAAAA,EAAAA;AAFiC,KAAD,CAAlCH;AAIA,WAAA,MAAA;AANF,GAAA;AAQD;;AAQD,IAAMI,MAAM,GAAG,SAATA,MAAS,CAAA,IAAA,EAAA;AAAA,MAAC,GAAD,GAAA,IAAA,CAAC,GAAD;AAAA,MAAQC,GAAR,GAAA,IAAA,CAAQA,GAAR;AAAA,SAAqCC,UAAAA,KAAD;AAAA,WACjDA,KAAK,CAALA,SAAAA,KAAAA,KAAAA,GAAAA,GAAAA,GADa,GAAoC;AAAA,GAApC;AAAf,CAAA;;AAGA,OAAO,SAAA,OAAA,CAAA,OAAA,EAA4C;AACjD,MAAM,QAAN,GAAA,OAAA,CAAM,QAAN;AAAA,MAAM,KAAN,GAAA,OAAA,CAAM,KAAN;AAAA,MAAyBH,SAAzB,GAAA,OAAA,CAAyBA,SAAzB;AACA,SAAO;AACLF,IAAAA,KADK,EACLA,KADK;AAELF,IAAAA,QAAQ,EAAEK,MAAM,CAFX,QAEW,CAFX;AAGLD,IAAAA,SAAS,EAAEF,KAAK,GACZC,eAAe,CAAC;AACdD,MAAAA,KADc,EACdA,KADc;AAEdM,MAAAA,OAAO,EAAEJ;AAFK,KAAD,CADH,GAKZA;AARC,GAAP;AAUD","sourcesContent":["import { Dict } from \"@chakra-ui/utils\"\nimport * as CSS from \"csstype\"\nimport { createTransform } from \"./create-transform\"\nimport { ThemeScale } from \"../create-theme-vars\"\nimport type { CssTheme, Transform } from \"./types\"\n\ntype CSSProp = keyof CSS.Properties | (string & {})\ntype MaybeArray<T> = T | T[]\ntype MaybeThemeFunction<T> = T | ((theme: CssTheme) => T)\ntype StringUnion<T> = T | (string & {})\n\nexport interface PropConfig {\n  /**\n   * This is useful for props that need to leverage CSS variables\n   * Static styles to append to the computed styles.\n   *\n   * It does not get replicated if value is responsive or styles are nested.\n   */\n  static?: Dict\n  /**\n   * The theme scale this maps to\n   */\n  scale?: ThemeScale\n  /**\n   * Css property or Css variable the prop maps to\n   */\n  property?: MaybeThemeFunction<MaybeArray<StringUnion<CSSProp>>>\n  /**\n   * Function to transform the value passed\n   */\n  transform?: Transform\n  /**\n   * Useful for `layerStyle`, tex`tStyles and `apply` where their\n   * transform function returns theme aware styles\n   */\n  processResult?: boolean\n}\n\nexport type Config = Record<string, PropConfig | true>\n\nexport function toConfig(scale: ThemeScale, transform?: Transform) {\n  return <T extends CSSProp>(property: T | T[]) => {\n    const result: PropConfig = { property, scale }\n    result.transform = createTransform({\n      scale,\n      transform,\n    })\n    return result\n  }\n}\n\ninterface Opts {\n  scale?: ThemeScale\n  property: { ltr: MaybeArray<CSSProp>; rtl: MaybeArray<CSSProp> }\n  transform?: Transform\n}\n\nconst getRtl = ({ rtl, ltr }: Opts[\"property\"]) => (theme: Dict) =>\n  theme.direction === \"rtl\" ? rtl : ltr\n\nexport function logical(options: Opts): PropConfig {\n  const { property, scale, transform } = options\n  return {\n    scale,\n    property: getRtl(property),\n    transform: scale\n      ? createTransform({\n          scale,\n          compose: transform,\n        })\n      : transform,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
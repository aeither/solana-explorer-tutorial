{"version":3,"sources":["../../src/anatomy.ts"],"names":["Anatomy","name","called","Error","assert","values","part","map","toPart","parts","el","includes","attr","filter","Boolean","join","className","partObj","selector","toString","value","Object","fromEntries","entries","key","keys","anatomy"],"mappings":"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","sourcesContent":["/**\n * Used to define the anatomy/parts of a component in a way that provides\n * a consistent API for `className`, css selector and `theming`.\n */\nexport class Anatomy<T extends string = string> {\n  private map: Record<T, Part> = {} as Record<T, Part>\n  private called = false\n\n  constructor(private name: string) {}\n\n  /**\n   * Prevents user from calling `.parts` multiple times.\n   * It should only be called once.\n   */\n  private assert = () => {\n    if (!this.called) {\n      this.called = true\n      return\n    }\n\n    throw new Error(\n      \"[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?\",\n    )\n  }\n\n  /**\n   * Add the core parts of the components\n   */\n  public parts = <V extends string>(...values: V[]) => {\n    this.assert()\n    for (const part of values) {\n      ;(this.map as any)[part] = this.toPart(part)\n    }\n    return (this as unknown) as Omit<Anatomy<V>, \"parts\">\n  }\n\n  /**\n   * Extend the component anatomy to includes new parts\n   */\n  public extend = <U extends string>(...parts: U[]) => {\n    for (const part of parts) {\n      if (part in this.map) continue\n      ;(this.map as any)[part] = this.toPart(part)\n    }\n    return (this as unknown) as Omit<Anatomy<T | U>, \"parts\">\n  }\n\n  /**\n   * Get all selectors for the component anatomy\n   */\n  get selectors() {\n    const value = Object.fromEntries(\n      Object.entries(this.map).map(([key, part]) => [\n        key,\n        (part as any).selector,\n      ]),\n    )\n    return value as Record<T, string>\n  }\n\n  /**\n   * Get all classNames for the component anatomy\n   */\n  get classNames() {\n    const value = Object.fromEntries(\n      Object.entries(this.map).map(([key, part]) => [\n        key,\n        (part as any).className,\n      ]),\n    )\n    return value as Record<T, string>\n  }\n\n  /**\n   * Get all parts as array of string\n   */\n  get keys() {\n    return Object.keys(this.map) as T[]\n  }\n\n  /**\n   * Creates the part object for the given part\n   */\n  toPart = (part: string) => {\n    const el = [\"container\", \"root\"].includes(part ?? \"\")\n      ? [this.name]\n      : [this.name, part]\n    const attr = el.filter(Boolean).join(\"__\")\n    const className = `chakra-${attr}`\n\n    const partObj = {\n      className,\n      selector: `.${className}`,\n      toString: () => part,\n    }\n\n    return partObj as typeof partObj & string\n  }\n\n  /**\n   * Used to get the derived type of the anatomy\n   */\n  __type = {} as T\n}\n\ntype Part = {\n  className: string\n  selector: string\n  toString: () => string\n}\n\nexport function anatomy(name: string) {\n  return new Anatomy(name)\n}\n"],"file":"anatomy.js"}
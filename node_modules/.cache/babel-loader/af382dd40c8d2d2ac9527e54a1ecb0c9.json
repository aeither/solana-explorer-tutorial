{"ast":null,"code":"import { __spreadArray, __read } from 'tslib';\nimport sync, { flushSync } from 'framesync';\nimport { collectProjectingAncestors, updateLayoutMeasurement } from '../../../render/dom/projection/utils.js';\nimport { batchLayout, flushLayout } from '../../../render/dom/utils/batch-layout.js';\nimport { compareByDepth } from '../../../render/utils/compare-by-depth.js';\nimport { Presence } from '../types.js';\n/**\n * Default handlers for batching VisualElements\n */\n\nvar defaultHandler = {\n  layoutReady: function layoutReady(child) {\n    return child.notifyLayoutReady();\n  }\n};\n/**\n * Create a batcher to process VisualElements\n */\n\nfunction createBatcher() {\n  var queue = new Set();\n  return {\n    add: function add(child) {\n      return queue.add(child);\n    },\n    flush: function flush(_a) {\n      var _b = _a === void 0 ? defaultHandler : _a,\n          layoutReady = _b.layoutReady,\n          parent = _b.parent;\n\n      batchLayout(function (read, write) {\n        var order = Array.from(queue).sort(compareByDepth);\n        var ancestors = parent ? collectProjectingAncestors(parent) : [];\n        write(function () {\n          var allElements = __spreadArray(__spreadArray([], __read(ancestors)), __read(order));\n\n          allElements.forEach(function (element) {\n            return element.resetTransform();\n          });\n        });\n        read(function () {\n          order.forEach(updateLayoutMeasurement);\n        });\n        write(function () {\n          ancestors.forEach(function (element) {\n            return element.restoreTransform();\n          });\n          order.forEach(layoutReady);\n        });\n        read(function () {\n          /**\n           * After all children have started animating, ensure any Entering components are set to Present.\n           * If we add deferred animations (set up all animations and then start them in two loops) this\n           * could be moved to the start loop. But it needs to happen after all the animations configs\n           * are generated in AnimateSharedLayout as this relies on presence data\n           */\n          order.forEach(function (child) {\n            if (child.isPresent) child.presence = Presence.Present;\n          });\n        });\n        write(function () {\n          /**\n           * Starting these animations will have queued jobs on the frame loop. In some situations,\n           * like when removing an element, these will be processed too late after the DOM is manipulated,\n           * leaving a flash of incorrectly-projected content. By manually flushing these jobs\n           * we ensure there's no flash.\n           */\n          flushSync.preRender();\n          flushSync.render();\n        });\n        read(function () {\n          /**\n           * Schedule a callback at the end of the following frame to assign the latest projection\n           * box to the prevViewportBox snapshot. Once global batching is in place this could be run\n           * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\n           * child attempts to calculate its previous relative position against a prevViewportBox\n           * it will be against its latest projection box instead, as the snapshot is useless beyond this\n           * render.\n           */\n          sync.postRender(function () {\n            return order.forEach(assignProjectionToSnapshot);\n          });\n          queue.clear();\n        });\n      }); // TODO: Need to find a layout-synchronous way of flushing this\n\n      flushLayout();\n    }\n  };\n}\n\nfunction assignProjectionToSnapshot(child) {\n  child.prevViewportBox = child.projection.target;\n}\n\nexport { createBatcher };","map":{"version":3,"sources":["/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/batcher.js"],"names":["__spreadArray","__read","sync","flushSync","collectProjectingAncestors","updateLayoutMeasurement","batchLayout","flushLayout","compareByDepth","Presence","defaultHandler","layoutReady","child","notifyLayoutReady","createBatcher","queue","Set","add","flush","_a","_b","parent","read","write","order","Array","from","sort","ancestors","allElements","forEach","element","resetTransform","restoreTransform","isPresent","presence","Present","preRender","render","postRender","assignProjectionToSnapshot","clear","prevViewportBox","projection","target"],"mappings":"AAAA,SAASA,aAAT,EAAwBC,MAAxB,QAAsC,OAAtC;AACA,OAAOC,IAAP,IAAeC,SAAf,QAAgC,WAAhC;AACA,SAASC,0BAAT,EAAqCC,uBAArC,QAAoE,yCAApE;AACA,SAASC,WAAT,EAAsBC,WAAtB,QAAyC,2CAAzC;AACA,SAASC,cAAT,QAA+B,2CAA/B;AACA,SAASC,QAAT,QAAyB,aAAzB;AAEA;AACA;AACA;;AACA,IAAIC,cAAc,GAAG;AACjBC,EAAAA,WAAW,EAAE,qBAAUC,KAAV,EAAiB;AAAE,WAAOA,KAAK,CAACC,iBAAN,EAAP;AAAmC;AADlD,CAArB;AAGA;AACA;AACA;;AACA,SAASC,aAAT,GAAyB;AACrB,MAAIC,KAAK,GAAG,IAAIC,GAAJ,EAAZ;AACA,SAAO;AACHC,IAAAA,GAAG,EAAE,aAAUL,KAAV,EAAiB;AAAE,aAAOG,KAAK,CAACE,GAAN,CAAUL,KAAV,CAAP;AAA0B,KAD/C;AAEHM,IAAAA,KAAK,EAAE,eAAUC,EAAV,EAAc;AACjB,UAAIC,EAAE,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgBT,cAAhB,GAAiCS,EAA1C;AAAA,UAA8CR,WAAW,GAAGS,EAAE,CAACT,WAA/D;AAAA,UAA4EU,MAAM,GAAGD,EAAE,CAACC,MAAxF;;AACAf,MAAAA,WAAW,CAAC,UAAUgB,IAAV,EAAgBC,KAAhB,EAAuB;AAC/B,YAAIC,KAAK,GAAGC,KAAK,CAACC,IAAN,CAAWX,KAAX,EAAkBY,IAAlB,CAAuBnB,cAAvB,CAAZ;AACA,YAAIoB,SAAS,GAAGP,MAAM,GAChBjB,0BAA0B,CAACiB,MAAD,CADV,GAEhB,EAFN;AAGAE,QAAAA,KAAK,CAAC,YAAY;AACd,cAAIM,WAAW,GAAG7B,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKC,MAAM,CAAC2B,SAAD,CAAX,CAAd,EAAuC3B,MAAM,CAACuB,KAAD,CAA7C,CAA/B;;AACAK,UAAAA,WAAW,CAACC,OAAZ,CAAoB,UAAUC,OAAV,EAAmB;AAAE,mBAAOA,OAAO,CAACC,cAAR,EAAP;AAAkC,WAA3E;AACH,SAHI,CAAL;AAIAV,QAAAA,IAAI,CAAC,YAAY;AACbE,UAAAA,KAAK,CAACM,OAAN,CAAczB,uBAAd;AACH,SAFG,CAAJ;AAGAkB,QAAAA,KAAK,CAAC,YAAY;AACdK,UAAAA,SAAS,CAACE,OAAV,CAAkB,UAAUC,OAAV,EAAmB;AAAE,mBAAOA,OAAO,CAACE,gBAAR,EAAP;AAAoC,WAA3E;AACAT,UAAAA,KAAK,CAACM,OAAN,CAAcnB,WAAd;AACH,SAHI,CAAL;AAIAW,QAAAA,IAAI,CAAC,YAAY;AACb;AACpB;AACA;AACA;AACA;AACA;AACoBE,UAAAA,KAAK,CAACM,OAAN,CAAc,UAAUlB,KAAV,EAAiB;AAC3B,gBAAIA,KAAK,CAACsB,SAAV,EACItB,KAAK,CAACuB,QAAN,GAAiB1B,QAAQ,CAAC2B,OAA1B;AACP,WAHD;AAIH,SAXG,CAAJ;AAYAb,QAAAA,KAAK,CAAC,YAAY;AACd;AACpB;AACA;AACA;AACA;AACA;AACoBpB,UAAAA,SAAS,CAACkC,SAAV;AACAlC,UAAAA,SAAS,CAACmC,MAAV;AACH,SATI,CAAL;AAUAhB,QAAAA,IAAI,CAAC,YAAY;AACb;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACoBpB,UAAAA,IAAI,CAACqC,UAAL,CAAgB,YAAY;AACxB,mBAAOf,KAAK,CAACM,OAAN,CAAcU,0BAAd,CAAP;AACH,WAFD;AAGAzB,UAAAA,KAAK,CAAC0B,KAAN;AACH,SAbG,CAAJ;AAcH,OApDU,CAAX,CAFiB,CAuDjB;;AACAlC,MAAAA,WAAW;AACd;AA3DE,GAAP;AA6DH;;AACD,SAASiC,0BAAT,CAAoC5B,KAApC,EAA2C;AACvCA,EAAAA,KAAK,CAAC8B,eAAN,GAAwB9B,KAAK,CAAC+B,UAAN,CAAiBC,MAAzC;AACH;;AAED,SAAS9B,aAAT","sourcesContent":["import { __spreadArray, __read } from 'tslib';\nimport sync, { flushSync } from 'framesync';\nimport { collectProjectingAncestors, updateLayoutMeasurement } from '../../../render/dom/projection/utils.js';\nimport { batchLayout, flushLayout } from '../../../render/dom/utils/batch-layout.js';\nimport { compareByDepth } from '../../../render/utils/compare-by-depth.js';\nimport { Presence } from '../types.js';\n\n/**\n * Default handlers for batching VisualElements\n */\nvar defaultHandler = {\n    layoutReady: function (child) { return child.notifyLayoutReady(); },\n};\n/**\n * Create a batcher to process VisualElements\n */\nfunction createBatcher() {\n    var queue = new Set();\n    return {\n        add: function (child) { return queue.add(child); },\n        flush: function (_a) {\n            var _b = _a === void 0 ? defaultHandler : _a, layoutReady = _b.layoutReady, parent = _b.parent;\n            batchLayout(function (read, write) {\n                var order = Array.from(queue).sort(compareByDepth);\n                var ancestors = parent\n                    ? collectProjectingAncestors(parent)\n                    : [];\n                write(function () {\n                    var allElements = __spreadArray(__spreadArray([], __read(ancestors)), __read(order));\n                    allElements.forEach(function (element) { return element.resetTransform(); });\n                });\n                read(function () {\n                    order.forEach(updateLayoutMeasurement);\n                });\n                write(function () {\n                    ancestors.forEach(function (element) { return element.restoreTransform(); });\n                    order.forEach(layoutReady);\n                });\n                read(function () {\n                    /**\n                     * After all children have started animating, ensure any Entering components are set to Present.\n                     * If we add deferred animations (set up all animations and then start them in two loops) this\n                     * could be moved to the start loop. But it needs to happen after all the animations configs\n                     * are generated in AnimateSharedLayout as this relies on presence data\n                     */\n                    order.forEach(function (child) {\n                        if (child.isPresent)\n                            child.presence = Presence.Present;\n                    });\n                });\n                write(function () {\n                    /**\n                     * Starting these animations will have queued jobs on the frame loop. In some situations,\n                     * like when removing an element, these will be processed too late after the DOM is manipulated,\n                     * leaving a flash of incorrectly-projected content. By manually flushing these jobs\n                     * we ensure there's no flash.\n                     */\n                    flushSync.preRender();\n                    flushSync.render();\n                });\n                read(function () {\n                    /**\n                     * Schedule a callback at the end of the following frame to assign the latest projection\n                     * box to the prevViewportBox snapshot. Once global batching is in place this could be run\n                     * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\n                     * child attempts to calculate its previous relative position against a prevViewportBox\n                     * it will be against its latest projection box instead, as the snapshot is useless beyond this\n                     * render.\n                     */\n                    sync.postRender(function () {\n                        return order.forEach(assignProjectionToSnapshot);\n                    });\n                    queue.clear();\n                });\n            });\n            // TODO: Need to find a layout-synchronous way of flushing this\n            flushLayout();\n        },\n    };\n}\nfunction assignProjectionToSnapshot(child) {\n    child.prevViewportBox = child.projection.target;\n}\n\nexport { createBatcher };\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { __assign } from 'tslib';\nimport { Presence } from '../types.js';\nimport { elementDragControls } from '../../../gestures/drag/VisualElementDragControls.js';\nimport { createCrossfader } from './crossfader.js';\n\nfunction layoutStack() {\n  var stack = new Set();\n  var state = {\n    leadIsExiting: false\n  };\n\n  var prevState = __assign({}, state);\n\n  var prevValues;\n  var prevViewportBox;\n  var prevDragCursor;\n  var crossfader = createCrossfader();\n  var needsCrossfadeAnimation = false;\n\n  function getFollowViewportBox() {\n    return state.follow ? state.follow.prevViewportBox : prevViewportBox;\n  }\n\n  function getFollowLayout() {\n    var _a;\n\n    return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\n  }\n\n  return {\n    add: function add(element) {\n      element.setCrossfader(crossfader);\n      stack.add(element);\n      /**\n       * Hydrate new element with previous drag position if we have one\n       */\n\n      if (prevDragCursor) element.prevDragCursor = prevDragCursor;\n      if (!state.lead) state.lead = element;\n    },\n    remove: function remove(element) {\n      stack.delete(element);\n    },\n    getLead: function getLead() {\n      return state.lead;\n    },\n    updateSnapshot: function updateSnapshot() {\n      if (!state.lead) return;\n      prevValues = crossfader.isActive() ? crossfader.getLatestValues() : state.lead.getLatestValues();\n      prevViewportBox = state.lead.prevViewportBox;\n      var dragControls = elementDragControls.get(state.lead);\n\n      if (dragControls && dragControls.isDragging) {\n        prevDragCursor = dragControls.cursorProgress;\n      }\n    },\n    clearSnapshot: function clearSnapshot() {\n      prevDragCursor = prevViewportBox = undefined;\n    },\n    updateLeadAndFollow: function updateLeadAndFollow() {\n      var _a;\n\n      prevState = __assign({}, state);\n      var lead;\n      var follow;\n      var order = Array.from(stack);\n\n      for (var i = order.length; i--; i >= 0) {\n        var element = order[i];\n        if (lead) follow !== null && follow !== void 0 ? follow : follow = element;\n        lead !== null && lead !== void 0 ? lead : lead = element;\n        if (lead && follow) break;\n      }\n\n      state.lead = lead;\n      state.follow = follow;\n      state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\n      crossfader.setOptions({\n        lead: lead,\n        follow: follow,\n        prevValues: prevValues,\n        crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot)\n      });\n\n      if ( // Don't crossfade if we've just animated back from lead and switched the\n      // old follow to the new lead.\n      state.lead !== prevState.follow && (prevState.lead !== state.lead || prevState.leadIsExiting !== state.leadIsExiting)) {\n        needsCrossfadeAnimation = true;\n      }\n    },\n    animate: function animate(child, shouldCrossfade) {\n      var _a;\n\n      if (shouldCrossfade === void 0) {\n        shouldCrossfade = false;\n      }\n\n      if (child === state.lead) {\n        if (shouldCrossfade) {\n          /**\n           * Point a lead to itself in case it was previously pointing\n           * to a different visual element\n           */\n          child.pointTo(state.lead);\n        } else {\n          child.setVisibility(true);\n        }\n\n        var config = {};\n        var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();\n\n        if (prevParent) {\n          /**\n           * We'll use this to determine if the element or its layoutId has been reparented.\n           */\n          config.prevParent = prevParent;\n        }\n\n        if (child.presence === Presence.Entering) {\n          config.originBox = getFollowViewportBox();\n        } else if (child.presence === Presence.Exiting) {\n          config.targetBox = getFollowLayout();\n        }\n\n        if (needsCrossfadeAnimation) {\n          needsCrossfadeAnimation = false;\n          var transition = child.getDefaultTransition();\n          child.presence === Presence.Entering ? crossfader.toLead(transition) : crossfader.fromLead(transition);\n        }\n\n        child.notifyLayoutReady(config);\n      } else {\n        if (shouldCrossfade) {\n          state.lead && child.pointTo(state.lead);\n        } else {\n          child.setVisibility(false);\n        }\n      }\n    }\n  };\n}\n\nexport { layoutStack };","map":{"version":3,"sources":["/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/stack.js"],"names":["__assign","Presence","elementDragControls","createCrossfader","layoutStack","stack","Set","state","leadIsExiting","prevState","prevValues","prevViewportBox","prevDragCursor","crossfader","needsCrossfadeAnimation","getFollowViewportBox","follow","getFollowLayout","_a","getLayoutState","layout","add","element","setCrossfader","lead","remove","delete","getLead","updateSnapshot","isActive","getLatestValues","dragControls","get","isDragging","cursorProgress","clearSnapshot","undefined","updateLeadAndFollow","order","Array","from","i","length","presence","Exiting","setOptions","crossfadeOpacity","isPresenceRoot","animate","child","shouldCrossfade","pointTo","setVisibility","config","prevParent","getProjectionParent","Entering","originBox","targetBox","transition","getDefaultTransition","toLead","fromLead","notifyLayoutReady"],"mappings":"AAAA,SAASA,QAAT,QAAyB,OAAzB;AACA,SAASC,QAAT,QAAyB,aAAzB;AACA,SAASC,mBAAT,QAAoC,qDAApC;AACA,SAASC,gBAAT,QAAiC,iBAAjC;;AAEA,SAASC,WAAT,GAAuB;AACnB,MAAIC,KAAK,GAAG,IAAIC,GAAJ,EAAZ;AACA,MAAIC,KAAK,GAAG;AAAEC,IAAAA,aAAa,EAAE;AAAjB,GAAZ;;AACA,MAAIC,SAAS,GAAGT,QAAQ,CAAC,EAAD,EAAKO,KAAL,CAAxB;;AACA,MAAIG,UAAJ;AACA,MAAIC,eAAJ;AACA,MAAIC,cAAJ;AACA,MAAIC,UAAU,GAAGV,gBAAgB,EAAjC;AACA,MAAIW,uBAAuB,GAAG,KAA9B;;AACA,WAASC,oBAAT,GAAgC;AAC5B,WAAOR,KAAK,CAACS,MAAN,GAAeT,KAAK,CAACS,MAAN,CAAaL,eAA5B,GAA8CA,eAArD;AACH;;AACD,WAASM,eAAT,GAA2B;AACvB,QAAIC,EAAJ;;AACA,WAAO,CAACA,EAAE,GAAGX,KAAK,CAACS,MAAZ,MAAwB,IAAxB,IAAgCE,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAACC,cAAH,GAAoBC,MAApF;AACH;;AACD,SAAO;AACHC,IAAAA,GAAG,EAAE,aAAUC,OAAV,EAAmB;AACpBA,MAAAA,OAAO,CAACC,aAAR,CAAsBV,UAAtB;AACAR,MAAAA,KAAK,CAACgB,GAAN,CAAUC,OAAV;AACA;AACZ;AACA;;AACY,UAAIV,cAAJ,EACIU,OAAO,CAACV,cAAR,GAAyBA,cAAzB;AACJ,UAAI,CAACL,KAAK,CAACiB,IAAX,EACIjB,KAAK,CAACiB,IAAN,GAAaF,OAAb;AACP,KAXE;AAYHG,IAAAA,MAAM,EAAE,gBAAUH,OAAV,EAAmB;AACvBjB,MAAAA,KAAK,CAACqB,MAAN,CAAaJ,OAAb;AACH,KAdE;AAeHK,IAAAA,OAAO,EAAE,mBAAY;AAAE,aAAOpB,KAAK,CAACiB,IAAb;AAAoB,KAfxC;AAgBHI,IAAAA,cAAc,EAAE,0BAAY;AACxB,UAAI,CAACrB,KAAK,CAACiB,IAAX,EACI;AACJd,MAAAA,UAAU,GAAGG,UAAU,CAACgB,QAAX,KACPhB,UAAU,CAACiB,eAAX,EADO,GAEPvB,KAAK,CAACiB,IAAN,CAAWM,eAAX,EAFN;AAGAnB,MAAAA,eAAe,GAAGJ,KAAK,CAACiB,IAAN,CAAWb,eAA7B;AACA,UAAIoB,YAAY,GAAG7B,mBAAmB,CAAC8B,GAApB,CAAwBzB,KAAK,CAACiB,IAA9B,CAAnB;;AACA,UAAIO,YAAY,IAAIA,YAAY,CAACE,UAAjC,EAA6C;AACzCrB,QAAAA,cAAc,GAAGmB,YAAY,CAACG,cAA9B;AACH;AACJ,KA3BE;AA4BHC,IAAAA,aAAa,EAAE,yBAAY;AACvBvB,MAAAA,cAAc,GAAGD,eAAe,GAAGyB,SAAnC;AACH,KA9BE;AA+BHC,IAAAA,mBAAmB,EAAE,+BAAY;AAC7B,UAAInB,EAAJ;;AACAT,MAAAA,SAAS,GAAGT,QAAQ,CAAC,EAAD,EAAKO,KAAL,CAApB;AACA,UAAIiB,IAAJ;AACA,UAAIR,MAAJ;AACA,UAAIsB,KAAK,GAAGC,KAAK,CAACC,IAAN,CAAWnC,KAAX,CAAZ;;AACA,WAAK,IAAIoC,CAAC,GAAGH,KAAK,CAACI,MAAnB,EAA2BD,CAAC,EAA5B,EAAgCA,CAAC,IAAI,CAArC,EAAwC;AACpC,YAAInB,OAAO,GAAGgB,KAAK,CAACG,CAAD,CAAnB;AACA,YAAIjB,IAAJ,EACIR,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuCA,MAAvC,GAAiDA,MAAM,GAAGM,OAA1D;AACJE,QAAAA,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmCA,IAAnC,GAA2CA,IAAI,GAAGF,OAAlD;AACA,YAAIE,IAAI,IAAIR,MAAZ,EACI;AACP;;AACDT,MAAAA,KAAK,CAACiB,IAAN,GAAaA,IAAb;AACAjB,MAAAA,KAAK,CAACS,MAAN,GAAeA,MAAf;AACAT,MAAAA,KAAK,CAACC,aAAN,GAAsB,CAAC,CAACU,EAAE,GAAGX,KAAK,CAACiB,IAAZ,MAAsB,IAAtB,IAA8BN,EAAE,KAAK,KAAK,CAA1C,GAA8C,KAAK,CAAnD,GAAuDA,EAAE,CAACyB,QAA3D,MAAyE1C,QAAQ,CAAC2C,OAAxG;AACA/B,MAAAA,UAAU,CAACgC,UAAX,CAAsB;AAClBrB,QAAAA,IAAI,EAAEA,IADY;AAElBR,QAAAA,MAAM,EAAEA,MAFU;AAGlBN,QAAAA,UAAU,EAAEA,UAHM;AAIlBoC,QAAAA,gBAAgB,EAAE,CAAC9B,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAAC+B,cAAxD,MAA4EvB,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAACuB,cAA7H;AAJA,OAAtB;;AAMA,WACA;AACA;AACAxC,MAAAA,KAAK,CAACiB,IAAN,KAAef,SAAS,CAACO,MAAzB,KACKP,SAAS,CAACe,IAAV,KAAmBjB,KAAK,CAACiB,IAAzB,IACGf,SAAS,CAACD,aAAV,KAA4BD,KAAK,CAACC,aAF1C,CAHA,EAK0D;AACtDM,QAAAA,uBAAuB,GAAG,IAA1B;AACH;AACJ,KA9DE;AA+DHkC,IAAAA,OAAO,EAAE,iBAAUC,KAAV,EAAiBC,eAAjB,EAAkC;AACvC,UAAIhC,EAAJ;;AACA,UAAIgC,eAAe,KAAK,KAAK,CAA7B,EAAgC;AAAEA,QAAAA,eAAe,GAAG,KAAlB;AAA0B;;AAC5D,UAAID,KAAK,KAAK1C,KAAK,CAACiB,IAApB,EAA0B;AACtB,YAAI0B,eAAJ,EAAqB;AACjB;AACpB;AACA;AACA;AACoBD,UAAAA,KAAK,CAACE,OAAN,CAAc5C,KAAK,CAACiB,IAApB;AACH,SAND,MAOK;AACDyB,UAAAA,KAAK,CAACG,aAAN,CAAoB,IAApB;AACH;;AACD,YAAIC,MAAM,GAAG,EAAb;AACA,YAAIC,UAAU,GAAG,CAACpC,EAAE,GAAGX,KAAK,CAACS,MAAZ,MAAwB,IAAxB,IAAgCE,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAACqC,mBAAH,EAA1E;;AACA,YAAID,UAAJ,EAAgB;AACZ;AACpB;AACA;AACoBD,UAAAA,MAAM,CAACC,UAAP,GAAoBA,UAApB;AACH;;AACD,YAAIL,KAAK,CAACN,QAAN,KAAmB1C,QAAQ,CAACuD,QAAhC,EAA0C;AACtCH,UAAAA,MAAM,CAACI,SAAP,GAAmB1C,oBAAoB,EAAvC;AACH,SAFD,MAGK,IAAIkC,KAAK,CAACN,QAAN,KAAmB1C,QAAQ,CAAC2C,OAAhC,EAAyC;AAC1CS,UAAAA,MAAM,CAACK,SAAP,GAAmBzC,eAAe,EAAlC;AACH;;AACD,YAAIH,uBAAJ,EAA6B;AACzBA,UAAAA,uBAAuB,GAAG,KAA1B;AACA,cAAI6C,UAAU,GAAGV,KAAK,CAACW,oBAAN,EAAjB;AACAX,UAAAA,KAAK,CAACN,QAAN,KAAmB1C,QAAQ,CAACuD,QAA5B,GACM3C,UAAU,CAACgD,MAAX,CAAkBF,UAAlB,CADN,GAEM9C,UAAU,CAACiD,QAAX,CAAoBH,UAApB,CAFN;AAGH;;AACDV,QAAAA,KAAK,CAACc,iBAAN,CAAwBV,MAAxB;AACH,OAjCD,MAkCK;AACD,YAAIH,eAAJ,EAAqB;AACjB3C,UAAAA,KAAK,CAACiB,IAAN,IAAcyB,KAAK,CAACE,OAAN,CAAc5C,KAAK,CAACiB,IAApB,CAAd;AACH,SAFD,MAGK;AACDyB,UAAAA,KAAK,CAACG,aAAN,CAAoB,KAApB;AACH;AACJ;AACJ;AA5GE,GAAP;AA8GH;;AAED,SAAShD,WAAT","sourcesContent":["import { __assign } from 'tslib';\nimport { Presence } from '../types.js';\nimport { elementDragControls } from '../../../gestures/drag/VisualElementDragControls.js';\nimport { createCrossfader } from './crossfader.js';\n\nfunction layoutStack() {\n    var stack = new Set();\n    var state = { leadIsExiting: false };\n    var prevState = __assign({}, state);\n    var prevValues;\n    var prevViewportBox;\n    var prevDragCursor;\n    var crossfader = createCrossfader();\n    var needsCrossfadeAnimation = false;\n    function getFollowViewportBox() {\n        return state.follow ? state.follow.prevViewportBox : prevViewportBox;\n    }\n    function getFollowLayout() {\n        var _a;\n        return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\n    }\n    return {\n        add: function (element) {\n            element.setCrossfader(crossfader);\n            stack.add(element);\n            /**\n             * Hydrate new element with previous drag position if we have one\n             */\n            if (prevDragCursor)\n                element.prevDragCursor = prevDragCursor;\n            if (!state.lead)\n                state.lead = element;\n        },\n        remove: function (element) {\n            stack.delete(element);\n        },\n        getLead: function () { return state.lead; },\n        updateSnapshot: function () {\n            if (!state.lead)\n                return;\n            prevValues = crossfader.isActive()\n                ? crossfader.getLatestValues()\n                : state.lead.getLatestValues();\n            prevViewportBox = state.lead.prevViewportBox;\n            var dragControls = elementDragControls.get(state.lead);\n            if (dragControls && dragControls.isDragging) {\n                prevDragCursor = dragControls.cursorProgress;\n            }\n        },\n        clearSnapshot: function () {\n            prevDragCursor = prevViewportBox = undefined;\n        },\n        updateLeadAndFollow: function () {\n            var _a;\n            prevState = __assign({}, state);\n            var lead;\n            var follow;\n            var order = Array.from(stack);\n            for (var i = order.length; i--; i >= 0) {\n                var element = order[i];\n                if (lead)\n                    follow !== null && follow !== void 0 ? follow : (follow = element);\n                lead !== null && lead !== void 0 ? lead : (lead = element);\n                if (lead && follow)\n                    break;\n            }\n            state.lead = lead;\n            state.follow = follow;\n            state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\n            crossfader.setOptions({\n                lead: lead,\n                follow: follow,\n                prevValues: prevValues,\n                crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot),\n            });\n            if (\n            // Don't crossfade if we've just animated back from lead and switched the\n            // old follow to the new lead.\n            state.lead !== prevState.follow &&\n                (prevState.lead !== state.lead ||\n                    prevState.leadIsExiting !== state.leadIsExiting)) {\n                needsCrossfadeAnimation = true;\n            }\n        },\n        animate: function (child, shouldCrossfade) {\n            var _a;\n            if (shouldCrossfade === void 0) { shouldCrossfade = false; }\n            if (child === state.lead) {\n                if (shouldCrossfade) {\n                    /**\n                     * Point a lead to itself in case it was previously pointing\n                     * to a different visual element\n                     */\n                    child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(true);\n                }\n                var config = {};\n                var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();\n                if (prevParent) {\n                    /**\n                     * We'll use this to determine if the element or its layoutId has been reparented.\n                     */\n                    config.prevParent = prevParent;\n                }\n                if (child.presence === Presence.Entering) {\n                    config.originBox = getFollowViewportBox();\n                }\n                else if (child.presence === Presence.Exiting) {\n                    config.targetBox = getFollowLayout();\n                }\n                if (needsCrossfadeAnimation) {\n                    needsCrossfadeAnimation = false;\n                    var transition = child.getDefaultTransition();\n                    child.presence === Presence.Entering\n                        ? crossfader.toLead(transition)\n                        : crossfader.fromLead(transition);\n                }\n                child.notifyLayoutReady(config);\n            }\n            else {\n                if (shouldCrossfade) {\n                    state.lead && child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(false);\n                }\n            }\n        },\n    };\n}\n\nexport { layoutStack };\n"]},"metadata":{},"sourceType":"module"}
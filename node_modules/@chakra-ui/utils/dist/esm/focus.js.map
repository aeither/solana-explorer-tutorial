{"version":3,"sources":["../../src/focus.ts"],"names":["getOwnerDocument","warn","isActiveElement","isInputElement","focus","element","options","isActive","nextTick","preventScroll","selectTextIfInput","triggerFocus","condition","message","supportsPreventScroll","scrollableElements","getScrollableElements","restoreScrollPosition","select","requestAnimationFrame","supportsPreventScrollCached","div","document","createElement","e","doc","win","defaultView","window","parent","parentNode","rootScrollingElement","scrollingElement","documentElement","HTMLElement","offsetHeight","scrollHeight","offsetWidth","scrollWidth","push","scrollTop","scrollLeft"],"mappings":"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","sourcesContent":["// Original licensing for the following methods can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/calvellido/focus-options-polyfill\n// See https://github.com/adobe/react-spectrum\n\nimport { getOwnerDocument } from \"./dom\"\nimport { warn } from \"./function\"\nimport { FocusableElement, isActiveElement, isInputElement } from \"./tabbable\"\n\nexport interface ExtendedFocusOptions extends FocusOptions {\n  /**\n   * Function that determines if the element is the active element\n   */\n  isActive?: typeof isActiveElement\n  /**\n   * If true, the element will be focused in the next tick\n   */\n  nextTick?: boolean\n  /**\n   * If true and element is an input element, the input's text will be selected\n   */\n  selectTextIfInput?: boolean\n}\n\nexport function focus(\n  element: FocusableElement | null,\n  options: ExtendedFocusOptions = {},\n) {\n  const {\n    isActive = isActiveElement,\n    nextTick,\n    preventScroll = true,\n    selectTextIfInput = true,\n  } = options\n\n  if (!element || isActive(element)) return -1\n\n  function triggerFocus() {\n    if (!element) {\n      warn({\n        condition: true,\n        message:\n          \"[chakra-ui]: can't call focus() on `null` or `undefined` element\",\n      })\n      return\n    }\n    if (supportsPreventScroll()) {\n      element.focus({ preventScroll })\n    } else {\n      element.focus()\n      if (preventScroll) {\n        const scrollableElements = getScrollableElements(element as HTMLElement)\n        restoreScrollPosition(scrollableElements)\n      }\n    }\n\n    if (isInputElement(element) && selectTextIfInput) {\n      element.select()\n    }\n  }\n\n  if (nextTick) {\n    return requestAnimationFrame(triggerFocus)\n  }\n\n  triggerFocus()\n  return -1\n}\n\nlet supportsPreventScrollCached: boolean | null = null\nfunction supportsPreventScroll() {\n  if (supportsPreventScrollCached == null) {\n    supportsPreventScrollCached = false\n    try {\n      const div = document.createElement(\"div\")\n      div.focus({\n        get preventScroll() {\n          supportsPreventScrollCached = true\n          return true\n        },\n      })\n    } catch (e) {\n      // Ignore\n    }\n  }\n\n  return supportsPreventScrollCached\n}\n\ninterface ScrollableElement {\n  element: HTMLElement\n  scrollTop: number\n  scrollLeft: number\n}\n\nfunction getScrollableElements(element: HTMLElement): ScrollableElement[] {\n  const doc = getOwnerDocument(element)\n  const win = doc.defaultView ?? window\n  let parent = element.parentNode\n  const scrollableElements: ScrollableElement[] = []\n  const rootScrollingElement = doc.scrollingElement || doc.documentElement\n\n  while (parent instanceof win.HTMLElement && parent !== rootScrollingElement) {\n    if (\n      parent.offsetHeight < parent.scrollHeight ||\n      parent.offsetWidth < parent.scrollWidth\n    ) {\n      scrollableElements.push({\n        element: parent,\n        scrollTop: parent.scrollTop,\n        scrollLeft: parent.scrollLeft,\n      })\n    }\n    parent = parent.parentNode\n  }\n\n  if (rootScrollingElement instanceof win.HTMLElement) {\n    scrollableElements.push({\n      element: rootScrollingElement,\n      scrollTop: rootScrollingElement.scrollTop,\n      scrollLeft: rootScrollingElement.scrollLeft,\n    })\n  }\n\n  return scrollableElements\n}\n\nfunction restoreScrollPosition(scrollableElements: ScrollableElement[]) {\n  for (const { element, scrollTop, scrollLeft } of scrollableElements) {\n    element.scrollTop = scrollTop\n    element.scrollLeft = scrollLeft\n  }\n}\n"],"file":"focus.js"}
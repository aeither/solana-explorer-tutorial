{"ast":null,"code":"import { zeroLayout } from '../../utils/state.js';\n/**\n * Build a transform style that takes a calculated delta between the element's current\n * space on screen and projects it into the desired space.\n */\n\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n  var x = _a.x,\n      y = _a.y;\n  /**\n   * The translations we use to calculate are always relative to the viewport coordinate space.\n   * But when we apply scales, we also scale the coordinate space of an element and its children.\n   * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n   * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n   */\n\n  var xTranslate = x.translate / treeScale.x;\n  var yTranslate = y.translate / treeScale.y;\n  var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n\n  if (latestTransform) {\n    var rotate = latestTransform.rotate,\n        rotateX = latestTransform.rotateX,\n        rotateY = latestTransform.rotateY;\n    if (rotate) transform += \"rotate(\" + rotate + \") \";\n    if (rotateX) transform += \"rotateX(\" + rotateX + \") \";\n    if (rotateY) transform += \"rotateY(\" + rotateY + \") \";\n  }\n\n  transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n  return !latestTransform && transform === identityProjection ? \"\" : transform;\n}\n/**\n * Take the calculated delta origin and apply it as a transform string.\n */\n\n\nfunction buildLayoutProjectionTransformOrigin(_a) {\n  var deltaFinal = _a.deltaFinal;\n  return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\n\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, {\n  x: 1,\n  y: 1\n});\nexport { buildLayoutProjectionTransform, buildLayoutProjectionTransformOrigin, identityProjection };","map":{"version":3,"sources":["/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/framer-motion/dist/es/render/html/utils/build-projection-transform.js"],"names":["zeroLayout","buildLayoutProjectionTransform","_a","treeScale","latestTransform","x","y","xTranslate","translate","yTranslate","transform","rotate","rotateX","rotateY","scale","identityProjection","buildLayoutProjectionTransformOrigin","deltaFinal","origin","delta"],"mappings":"AAAA,SAASA,UAAT,QAA2B,sBAA3B;AAEA;AACA;AACA;AACA;;AACA,SAASC,8BAAT,CAAwCC,EAAxC,EAA4CC,SAA5C,EAAuDC,eAAvD,EAAwE;AACpE,MAAIC,CAAC,GAAGH,EAAE,CAACG,CAAX;AAAA,MAAcC,CAAC,GAAGJ,EAAE,CAACI,CAArB;AACA;AACJ;AACA;AACA;AACA;AACA;;AACI,MAAIC,UAAU,GAAGF,CAAC,CAACG,SAAF,GAAcL,SAAS,CAACE,CAAzC;AACA,MAAII,UAAU,GAAGH,CAAC,CAACE,SAAF,GAAcL,SAAS,CAACG,CAAzC;AACA,MAAII,SAAS,GAAG,iBAAiBH,UAAjB,GAA8B,MAA9B,GAAuCE,UAAvC,GAAoD,SAApE;;AACA,MAAIL,eAAJ,EAAqB;AACjB,QAAIO,MAAM,GAAGP,eAAe,CAACO,MAA7B;AAAA,QAAqCC,OAAO,GAAGR,eAAe,CAACQ,OAA/D;AAAA,QAAwEC,OAAO,GAAGT,eAAe,CAACS,OAAlG;AACA,QAAIF,MAAJ,EACID,SAAS,IAAI,YAAYC,MAAZ,GAAqB,IAAlC;AACJ,QAAIC,OAAJ,EACIF,SAAS,IAAI,aAAaE,OAAb,GAAuB,IAApC;AACJ,QAAIC,OAAJ,EACIH,SAAS,IAAI,aAAaG,OAAb,GAAuB,IAApC;AACP;;AACDH,EAAAA,SAAS,IAAI,WAAWL,CAAC,CAACS,KAAb,GAAqB,IAArB,GAA4BR,CAAC,CAACQ,KAA9B,GAAsC,GAAnD;AACA,SAAO,CAACV,eAAD,IAAoBM,SAAS,KAAKK,kBAAlC,GAAuD,EAAvD,GAA4DL,SAAnE;AACH;AACD;AACA;AACA;;;AACA,SAASM,oCAAT,CAA8Cd,EAA9C,EAAkD;AAC9C,MAAIe,UAAU,GAAGf,EAAE,CAACe,UAApB;AACA,SAAOA,UAAU,CAACZ,CAAX,CAAaa,MAAb,GAAsB,GAAtB,GAA4B,IAA5B,GAAmCD,UAAU,CAACX,CAAX,CAAaY,MAAb,GAAsB,GAAzD,GAA+D,KAAtE;AACH;;AACD,IAAIH,kBAAkB,GAAGd,8BAA8B,CAACD,UAAU,CAACmB,KAAZ,EAAmBnB,UAAU,CAACG,SAA9B,EAAyC;AAAEE,EAAAA,CAAC,EAAE,CAAL;AAAQC,EAAAA,CAAC,EAAE;AAAX,CAAzC,CAAvD;AAEA,SAASL,8BAAT,EAAyCe,oCAAzC,EAA+ED,kBAA/E","sourcesContent":["import { zeroLayout } from '../../utils/state.js';\n\n/**\n * Build a transform style that takes a calculated delta between the element's current\n * space on screen and projects it into the desired space.\n */\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n    var x = _a.x, y = _a.y;\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    var xTranslate = x.translate / treeScale.x;\n    var yTranslate = y.translate / treeScale.y;\n    var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n    if (latestTransform) {\n        var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;\n        if (rotate)\n            transform += \"rotate(\" + rotate + \") \";\n        if (rotateX)\n            transform += \"rotateX(\" + rotateX + \") \";\n        if (rotateY)\n            transform += \"rotateY(\" + rotateY + \") \";\n    }\n    transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n    return !latestTransform && transform === identityProjection ? \"\" : transform;\n}\n/**\n * Take the calculated delta origin and apply it as a transform string.\n */\nfunction buildLayoutProjectionTransformOrigin(_a) {\n    var deltaFinal = _a.deltaFinal;\n    return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });\n\nexport { buildLayoutProjectionTransform, buildLayoutProjectionTransformOrigin, identityProjection };\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _slicedToArray from \"/Users/lin/Documents/Projects/solana-explorer-tutorial/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nexport { default as mergeWith } from \"lodash.mergewith\";\nexport function omit(object, keys) {\n  var result = {};\n  Object.keys(object).forEach(function (key) {\n    if (keys.includes(key)) return;\n    result[key] = object[key];\n  });\n  return result;\n}\nexport function pick(object, keys) {\n  var result = {};\n  keys.forEach(function (key) {\n    if (key in object) {\n      result[key] = object[key];\n    }\n  });\n  return result;\n}\nexport function split(object, keys) {\n  var picked = {};\n  var omitted = {};\n  Object.keys(object).forEach(function (key) {\n    if (keys.includes(key)) {\n      picked[key] = object[key];\n    } else {\n      omitted[key] = object[key];\n    }\n  });\n  return [picked, omitted];\n}\n/**\n * Get value from a deeply nested object using a string path.\n * Memoizes the value.\n * @param obj - the object\n * @param path - the string path\n * @param def  - the fallback value\n */\n\nexport function get(obj, path, fallback, index) {\n  var key = typeof path === \"string\" ? path.split(\".\") : [path];\n\n  for (index = 0; index < key.length; index += 1) {\n    if (!obj) break;\n    obj = obj[key[index]];\n  }\n\n  return obj === undefined ? fallback : obj;\n}\nexport var memoize = function memoize(fn) {\n  var cache = new WeakMap();\n\n  var memoizedFn = function memoizedFn(obj, path, fallback, index) {\n    if (typeof obj === \"undefined\") {\n      return fn(obj, path, fallback);\n    }\n\n    if (!cache.has(obj)) {\n      cache.set(obj, new Map());\n    }\n\n    var map = cache.get(obj);\n\n    if (map.has(path)) {\n      return map.get(path);\n    }\n\n    var value = fn(obj, path, fallback, index);\n    map.set(path, value);\n    return value;\n  };\n\n  return memoizedFn;\n};\nexport var memoizedGet = memoize(get);\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\n\nexport function getWithDefault(path, scale) {\n  return memoizedGet(scale, path, path);\n}\n/**\n * Returns the items of an object that meet the condition specified in a callback function.\n *\n * @param object the object to loop through\n * @param fn The filter function\n */\n\nexport function objectFilter(object, fn) {\n  var result = {};\n  Object.keys(object).forEach(function (key) {\n    var value = object[key];\n    var shouldPass = fn(value, key, object);\n\n    if (shouldPass) {\n      result[key] = value;\n    }\n  });\n  return result;\n}\nexport var filterUndefined = function filterUndefined(object) {\n  return objectFilter(object, function (val) {\n    return val !== null && val !== undefined;\n  });\n};\nexport var objectKeys = function objectKeys(obj) {\n  return Object.keys(obj);\n};\n/**\n * Object.entries polyfill for Nodev10 compatibility\n */\n\nexport var fromEntries = function fromEntries(entries) {\n  return entries.reduce(function (carry, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    carry[key] = value;\n    return carry;\n  }, {});\n};\n/**\n * Get the CSS variable ref stored in the theme\n */\n\nexport var getCSSVar = function getCSSVar(theme, scale, value) {\n  var _theme$__cssMap$$varR, _theme$__cssMap$;\n\n  return (_theme$__cssMap$$varR = (_theme$__cssMap$ = theme.__cssMap[scale + \".\" + value]) == null ? void 0 : _theme$__cssMap$.varRef) != null ? _theme$__cssMap$$varR : value;\n};","map":{"version":3,"sources":["../../src/object.ts"],"names":["default","result","Object","key","keys","object","picked","omitted","path","index","obj","memoize","fn","cache","memoizedFn","map","value","memoizedGet","shouldPass","filterUndefined","objectFilter","val","objectKeys","fromEntries","entries","carry","getCSSVar","theme","scale"],"mappings":"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","sourcesContent":["import type { Dict, Omit } from \"./types\"\n\nexport { default as mergeWith } from \"lodash.mergewith\"\n\nexport function omit<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    if (keys.includes(key as K)) return\n    result[key] = object[key]\n  })\n\n  return result as Omit<T, K>\n}\n\nexport function pick<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result = {} as { [P in K]: T[P] }\n\n  keys.forEach((key) => {\n    if (key in object) {\n      result[key] = object[key]\n    }\n  })\n\n  return result\n}\n\nexport function split<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const picked: Dict = {}\n  const omitted: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    if (keys.includes(key as T[K])) {\n      picked[key] = object[key]\n    } else {\n      omitted[key] = object[key]\n    }\n  })\n\n  return [picked, omitted] as [{ [P in K]: T[P] }, Omit<T, K>]\n}\n\n/**\n * Get value from a deeply nested object using a string path.\n * Memoizes the value.\n * @param obj - the object\n * @param path - the string path\n * @param def  - the fallback value\n */\nexport function get(\n  obj: object,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) {\n  const key = typeof path === \"string\" ? path.split(\".\") : [path]\n\n  for (index = 0; index < key.length; index += 1) {\n    if (!obj) break\n    obj = obj[key[index]]\n  }\n\n  return obj === undefined ? fallback : obj\n}\n\ntype Get = (\n  obj: Readonly<object>,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) => any\n\nexport const memoize = (fn: Get) => {\n  const cache = new WeakMap()\n\n  const memoizedFn: Get = (obj, path, fallback, index) => {\n    if (typeof obj === \"undefined\") {\n      return fn(obj, path, fallback)\n    }\n\n    if (!cache.has(obj)) {\n      cache.set(obj, new Map())\n    }\n\n    const map = cache.get(obj)\n\n    if (map.has(path)) {\n      return map.get(path)\n    }\n\n    const value = fn(obj, path, fallback, index)\n\n    map.set(path, value)\n\n    return value\n  }\n\n  return memoizedFn\n}\n\nexport const memoizedGet = memoize(get)\n\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\nexport function getWithDefault(path: any, scale: any) {\n  return memoizedGet(scale, path, path)\n}\n\ntype FilterFn<T> = (value: any, key: string, object: T) => boolean\n\n/**\n * Returns the items of an object that meet the condition specified in a callback function.\n *\n * @param object the object to loop through\n * @param fn The filter function\n */\nexport function objectFilter<T extends Dict>(object: T, fn: FilterFn<T>) {\n  const result: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    const value = object[key]\n    const shouldPass = fn(value, key, object)\n    if (shouldPass) {\n      result[key] = value\n    }\n  })\n\n  return result\n}\n\nexport const filterUndefined = (object: Dict) =>\n  objectFilter(object, (val) => val !== null && val !== undefined)\n\nexport const objectKeys = <T extends Dict>(obj: T) =>\n  (Object.keys(obj) as unknown) as (keyof T)[]\n\n/**\n * Object.entries polyfill for Nodev10 compatibility\n */\nexport const fromEntries = <T extends unknown>(entries: [string, any][]) =>\n  entries.reduce((carry, [key, value]) => {\n    carry[key] = value\n    return carry\n  }, {}) as T\n\n/**\n * Get the CSS variable ref stored in the theme\n */\nexport const getCSSVar = (theme: Dict, scale: string, value: any) =>\n  theme.__cssMap[`${scale}.${value}`]?.varRef ?? value\n"]},"metadata":{},"sourceType":"module"}